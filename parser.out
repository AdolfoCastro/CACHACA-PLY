Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    RES_TRUE
    EQ_EQ
    RES_SET
    TAB
    RES_ELIF
    CTE_DOUBLE
    AND
    RES_DOUBLE
    RES_FALSE
    OR

Grammar

Rule 0     S' -> programa
Rule 1     programa -> programa1 programa2 programa3 main programa3
Rule 2     programa -> empty
Rule 3     programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE
Rule 4     programa1 -> empty
Rule 5     programa2 -> programa2 vars
Rule 6     programa2 -> empty
Rule 7     programa3 -> programa3 modulos
Rule 8     programa3 -> empty
Rule 9     prototipos -> RES_FUNC dato ID LPAREN prototipos_1 RPAREN
Rule 10    prototipos_1 -> tipo ID prototipos_2
Rule 11    prototipos_2 -> COMMA prototipos_1
Rule 12    prototipos_2 -> empty
Rule 13    dato -> RES_INT
Rule 14    dato -> RES_FLOAT
Rule 15    dato -> RES_BOOLEAN
Rule 16    dato -> RES_STRING
Rule 17    tipo -> dato
Rule 18    tipo -> estructura
Rule 19    estructura -> list
Rule 20    estructura -> array
Rule 21    vars -> RES_DEF vars1 empty_lines_almost_one
Rule 22    vars1 -> estructura
Rule 23    vars1 -> estructura vars1
Rule 24    vars1 -> dato VAR vars2 vars1_1
Rule 25    vars1_1 -> vars1
Rule 26    vars1_1 -> empty
Rule 27    vars2 -> EQUALS cons
Rule 28    vars2 -> vars3
Rule 29    vars3 -> COMMA VAR vars3
Rule 30    vars3 -> empty
Rule 31    list -> RES_LIST dato ID list1 empty_lines_almost_one
Rule 32    list1 -> LCURLY cons_loop RCURLY
Rule 33    list1 -> empty
Rule 34    cons_loop -> cons cons_loop_1
Rule 35    cons_loop_1 -> COMMA cons_loop
Rule 36    cons_loop_1 -> empty
Rule 37    array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one
Rule 38    array1 -> COL LBRACKET array2 RBRACKET
Rule 39    array1 -> empty
Rule 40    array2 -> cons
Rule 41    array2 -> cons COMMA array2
Rule 42    modulos -> prototipos COL empty_lines_almost_one bloque
Rule 43    bloque -> bloque NEW_LINE
Rule 44    bloque -> estatutos
Rule 45    bloque -> empty
Rule 46    estatutos -> condicion
Rule 47    estatutos -> ciclo
Rule 48    estatutos -> lectura
Rule 49    estatutos -> escritura
Rule 50    estatutos -> asignacion
Rule 51    estatutos -> llamada
Rule 52    estatutos -> vars
Rule 53    ciclo -> while
Rule 54    ciclo -> for
Rule 55    condicion -> if
Rule 56    condicion -> ifelse
Rule 57    condicion -> switch
Rule 58    llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one
Rule 59    llamada1 -> expresion
Rule 60    llamada1 -> expresion COMMA llamada1
Rule 61    lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one
Rule 62    escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
Rule 63    escritura1 -> expresion COMMA escritura1
Rule 64    escritura1 -> CTE_STRING COMMA escritura1
Rule 65    escritura1 -> expresion
Rule 66    escritura1 -> CTE_STRING
Rule 67    asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one
Rule 68    asignacion1 -> cons
Rule 69    asignacion1 -> VAR
Rule 70    asignacion1 -> expresion
Rule 71    asignacion1 -> asignlist
Rule 72    asignacion1 -> asignarray
Rule 73    asignlist -> LCURLY asignlist1 RCURLY
Rule 74    asignlist1 -> cons
Rule 75    asignlist1 -> cons COMMA asignlist1
Rule 76    asignarray -> LBRACKET asignarray1 RBRACKET
Rule 77    asignarray1 -> cons
Rule 78    asignarray1 -> cons COMMA asignarray1
Rule 79    while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
Rule 80    for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque
Rule 81    forexp -> ID EQUALS cons COL ID comparacion ID COL ID EQUALS expresion
Rule 82    forexp -> ID EQUALS cons COL ID comparacion cons COL ID EQUALS expresion
Rule 83    comparacion -> MAY
Rule 84    comparacion -> MAY_EQ
Rule 85    comparacion -> MIN
Rule 86    comparacion -> MIN_EQ
Rule 87    comparacion -> DIF
Rule 88    if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
Rule 89    ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
Rule 90    switch -> RES_SWITCH COL empty_lines_almost_one switch2
Rule 91    switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque
Rule 92    switch2 -> switch2 NEW_LINE
Rule 93    switch2 -> empty
Rule 94    expresion -> exp
Rule 95    expresion -> exp MIN exp
Rule 96    expresion -> exp MIN_EQ exp
Rule 97    expresion -> exp MAY exp
Rule 98    expresion -> exp MAY_EQ exp
Rule 99    expresion -> exp DIF exp
Rule 100   exp -> termino exp1
Rule 101   exp -> termino
Rule 102   exp1 -> PLUS exp
Rule 103   exp1 -> MINUS exp
Rule 104   termino -> factor termino1
Rule 105   termino -> factor
Rule 106   termino1 -> TIMES termino
Rule 107   termino1 -> DIVIDE termino
Rule 108   factor -> LPAREN expresion RPAREN
Rule 109   factor -> PLUS cons
Rule 110   factor -> MINUS cons
Rule 111   cons -> ID
Rule 112   cons -> CTE_INT
Rule 113   cons -> CTE_FLOAT
Rule 114   cons -> CTE_STRING
Rule 115   cons -> consarray
Rule 116   cons -> conslist
Rule 117   main -> RES_START COL NEW_LINE bloque RES_END empty_lines
Rule 118   consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
Rule 119   conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one
Rule 120   conslist1 -> cons
Rule 121   conslist1 -> cons COMMA conslist1
Rule 122   empty_lines -> empty_lines NEW_LINE
Rule 123   empty_lines -> empty
Rule 124   empty_lines_almost_one -> NEW_LINE empty_lines
Rule 125   empty -> <empty>

Terminals, with rules where they appear

AND                  : 
COL                  : 38 42 79 80 81 81 82 82 88 89 89 90 91 117
COMMA                : 11 29 35 41 60 63 64 75 78 121
CTE_DOUBLE           : 
CTE_FLOAT            : 113
CTE_INT              : 37 112 118
CTE_STRING           : 64 66 114
DIF                  : 87 99
DIVIDE               : 107
EQUALS               : 27 67 81 81 82 82 118 119
EQ_EQ                : 
ID                   : 9 10 31 81 81 81 81 82 82 82 111 118 119
LBRACKET             : 37 38 76 118
LCURLY               : 32 73 119
LPAREN               : 9 58 61 62 79 80 88 89 108
MAY                  : 83 97
MAY_EQ               : 84 98
MIN                  : 85 95
MINUS                : 103 110
MIN_EQ               : 86 96
NEW_LINE             : 3 43 92 117 122 124
OR                   : 
PLUS                 : 102 109
RBRACKET             : 37 38 76 118
RCURLY               : 32 73 119
RES_ARRAY            : 37
RES_BOOLEAN          : 15
RES_CASE             : 91
RES_DEF              : 21
RES_DOUBLE           : 
RES_ELIF             : 
RES_ELSE             : 89
RES_END              : 117
RES_FALSE            : 
RES_FLOAT            : 14
RES_FOR              : 80
RES_FUNC             : 9
RES_IF               : 88 89
RES_INT              : 13
RES_LIST             : 31
RES_PRINT            : 62
RES_PROTO            : 3
RES_READ             : 61
RES_SET              : 
RES_START            : 117
RES_STRING           : 16
RES_SWITCH           : 90
RES_TRUE             : 
RES_WHILE            : 79
RPAREN               : 9 58 61 62 79 80 88 89 108
TAB                  : 
TIMES                : 106
VAR                  : 24 29 37 58 67 69
error                : 

Nonterminals, with rules where they appear

array                : 20
array1               : 37
array2               : 38 41
asignacion           : 50
asignacion1          : 67
asignarray           : 72
asignarray1          : 76 78
asignlist            : 71
asignlist1           : 73 75
bloque               : 42 43 79 80 88 89 89 91 117
ciclo                : 47
comparacion          : 81 82
condicion            : 46
cons                 : 27 34 40 41 68 74 75 77 78 81 82 82 109 110 118 120 121
cons_loop            : 32 35
cons_loop_1          : 34
consarray            : 115
conslist             : 116
conslist1            : 119 121
dato                 : 9 17 24 31 37
empty                : 2 4 6 8 12 26 30 33 36 39 45 93 123
empty_lines          : 117 122 124
empty_lines_almost_one : 3 21 31 37 42 58 61 62 67 79 80 88 89 89 90 91 118 119
escritura            : 49
escritura1           : 62 63 64
estatutos            : 44
estructura           : 18 22 23
exp                  : 94 95 95 96 96 97 97 98 98 99 99 102 103
exp1                 : 100
expresion            : 59 60 63 65 70 79 81 82 88 89 91 108
factor               : 104 105
for                  : 54
forexp               : 80
if                   : 55
ifelse               : 56
lectura              : 48
list                 : 19
list1                : 31
llamada              : 51
llamada1             : 58 60
main                 : 1
modulos              : 7
programa             : 0
programa1            : 1 3
programa2            : 1 5
programa3            : 1 1 7
prototipos           : 3 42
prototipos_1         : 9 11
prototipos_2         : 10
switch               : 57
switch2              : 90 92
termino              : 100 101 106 107
termino1             : 104
tipo                 : 10 61
vars                 : 5 52
vars1                : 21 23 25
vars1_1              : 24
vars2                : 24
vars3                : 28 29
while                : 53

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . programa1 programa2 programa3 main programa3
    (2) programa -> . empty
    (3) programa1 -> . RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE
    (4) programa1 -> . empty
    (125) empty -> .

    RES_PROTO       shift and go to state 3
    $end            reduce using rule 125 (empty -> .)
    RES_DEF         reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)

    programa1                      shift and go to state 1
    programa                       shift and go to state 2
    empty                          shift and go to state 4

state 1

    (1) programa -> programa1 . programa2 programa3 main programa3
    (5) programa2 -> . programa2 vars
    (6) programa2 -> . empty
    (125) empty -> .

    RES_DEF         reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)

    programa2                      shift and go to state 5
    empty                          shift and go to state 6

state 2

    (0) S' -> programa .



state 3

    (3) programa1 -> RES_PROTO . prototipos empty_lines_almost_one programa1 NEW_LINE
    (9) prototipos -> . RES_FUNC dato ID LPAREN prototipos_1 RPAREN

    RES_FUNC        shift and go to state 8

    prototipos                     shift and go to state 7

state 4

    (2) programa -> empty .
    (4) programa1 -> empty .

    $end            reduce using rule 2 (programa -> empty .)
    RES_DEF         reduce using rule 4 (programa1 -> empty .)
    RES_START       reduce using rule 4 (programa1 -> empty .)
    RES_FUNC        reduce using rule 4 (programa1 -> empty .)


state 5

    (1) programa -> programa1 programa2 . programa3 main programa3
    (5) programa2 -> programa2 . vars
    (7) programa3 -> . programa3 modulos
    (8) programa3 -> . empty
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (125) empty -> .

    RES_DEF         shift and go to state 11
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)

    vars                           shift and go to state 9
    programa3                      shift and go to state 10
    empty                          shift and go to state 12

state 6

    (6) programa2 -> empty .

    RES_DEF         reduce using rule 6 (programa2 -> empty .)
    RES_START       reduce using rule 6 (programa2 -> empty .)
    RES_FUNC        reduce using rule 6 (programa2 -> empty .)


state 7

    (3) programa1 -> RES_PROTO prototipos . empty_lines_almost_one programa1 NEW_LINE
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 13

state 8

    (9) prototipos -> RES_FUNC . dato ID LPAREN prototipos_1 RPAREN
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16

    dato                           shift and go to state 18

state 9

    (5) programa2 -> programa2 vars .

    RES_DEF         reduce using rule 5 (programa2 -> programa2 vars .)
    RES_START       reduce using rule 5 (programa2 -> programa2 vars .)
    RES_FUNC        reduce using rule 5 (programa2 -> programa2 vars .)


state 10

    (1) programa -> programa1 programa2 programa3 . main programa3
    (7) programa3 -> programa3 . modulos
    (117) main -> . RES_START COL NEW_LINE bloque RES_END empty_lines
    (42) modulos -> . prototipos COL empty_lines_almost_one bloque
    (9) prototipos -> . RES_FUNC dato ID LPAREN prototipos_1 RPAREN

    RES_START       shift and go to state 21
    RES_FUNC        shift and go to state 8

    prototipos                     shift and go to state 20
    modulos                        shift and go to state 22
    main                           shift and go to state 23

state 11

    (21) vars -> RES_DEF . vars1 empty_lines_almost_one
    (22) vars1 -> . estructura
    (23) vars1 -> . estructura vars1
    (24) vars1 -> . dato VAR vars2 vars1_1
    (19) estructura -> . list
    (20) estructura -> . array
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING
    (31) list -> . RES_LIST dato ID list1 empty_lines_almost_one
    (37) array -> . RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16
    RES_LIST        shift and go to state 28
    RES_ARRAY       shift and go to state 30

    estructura                     shift and go to state 26
    list                           shift and go to state 29
    vars1                          shift and go to state 25
    dato                           shift and go to state 27
    array                          shift and go to state 24

state 12

    (8) programa3 -> empty .

    RES_START       reduce using rule 8 (programa3 -> empty .)
    RES_FUNC        reduce using rule 8 (programa3 -> empty .)
    $end            reduce using rule 8 (programa3 -> empty .)


state 13

    (3) programa1 -> RES_PROTO prototipos empty_lines_almost_one . programa1 NEW_LINE
    (3) programa1 -> . RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE
    (4) programa1 -> . empty
    (125) empty -> .

    RES_PROTO       shift and go to state 3
    NEW_LINE        reduce using rule 125 (empty -> .)

    programa1                      shift and go to state 31
    empty                          shift and go to state 32

state 14

    (124) empty_lines_almost_one -> NEW_LINE . empty_lines
    (122) empty_lines -> . empty_lines NEW_LINE
    (123) empty_lines -> . empty
    (125) empty -> .

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_PROTO       reduce using rule 125 (empty -> .)
    RES_DEF         reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)
    RES_READ        reduce using rule 125 (empty -> .)
    RES_PRINT       reduce using rule 125 (empty -> .)
    VAR             reduce using rule 125 (empty -> .)
    RES_IF          reduce using rule 125 (empty -> .)
    RES_SWITCH      reduce using rule 125 (empty -> .)
    RES_WHILE       reduce using rule 125 (empty -> .)
    RES_FOR         reduce using rule 125 (empty -> .)
    RES_INT         reduce using rule 125 (empty -> .)
    RES_FLOAT       reduce using rule 125 (empty -> .)
    RES_BOOLEAN     reduce using rule 125 (empty -> .)
    RES_STRING      reduce using rule 125 (empty -> .)
    RES_LIST        reduce using rule 125 (empty -> .)
    RES_ARRAY       reduce using rule 125 (empty -> .)
    ID              reduce using rule 125 (empty -> .)
    RPAREN          reduce using rule 125 (empty -> .)
    RES_CASE        reduce using rule 125 (empty -> .)
    COMMA           reduce using rule 125 (empty -> .)
    RCURLY          reduce using rule 125 (empty -> .)
    TIMES           reduce using rule 125 (empty -> .)
    DIVIDE          reduce using rule 125 (empty -> .)
    PLUS            reduce using rule 125 (empty -> .)
    MINUS           reduce using rule 125 (empty -> .)
    MIN             reduce using rule 125 (empty -> .)
    MIN_EQ          reduce using rule 125 (empty -> .)
    MAY             reduce using rule 125 (empty -> .)
    MAY_EQ          reduce using rule 125 (empty -> .)
    DIF             reduce using rule 125 (empty -> .)
    COL             reduce using rule 125 (empty -> .)
    RBRACKET        reduce using rule 125 (empty -> .)

    empty_lines                    shift and go to state 33
    empty                          shift and go to state 34

state 15

    (13) dato -> RES_INT .

    VAR             reduce using rule 13 (dato -> RES_INT .)
    RPAREN          reduce using rule 13 (dato -> RES_INT .)
    ID              reduce using rule 13 (dato -> RES_INT .)


state 16

    (16) dato -> RES_STRING .

    VAR             reduce using rule 16 (dato -> RES_STRING .)
    RPAREN          reduce using rule 16 (dato -> RES_STRING .)
    ID              reduce using rule 16 (dato -> RES_STRING .)


state 17

    (15) dato -> RES_BOOLEAN .

    VAR             reduce using rule 15 (dato -> RES_BOOLEAN .)
    RPAREN          reduce using rule 15 (dato -> RES_BOOLEAN .)
    ID              reduce using rule 15 (dato -> RES_BOOLEAN .)


state 18

    (9) prototipos -> RES_FUNC dato . ID LPAREN prototipos_1 RPAREN

    ID              shift and go to state 35


state 19

    (14) dato -> RES_FLOAT .

    VAR             reduce using rule 14 (dato -> RES_FLOAT .)
    RPAREN          reduce using rule 14 (dato -> RES_FLOAT .)
    ID              reduce using rule 14 (dato -> RES_FLOAT .)


state 20

    (42) modulos -> prototipos . COL empty_lines_almost_one bloque

    COL             shift and go to state 36


state 21

    (117) main -> RES_START . COL NEW_LINE bloque RES_END empty_lines

    COL             shift and go to state 37


state 22

    (7) programa3 -> programa3 modulos .

    RES_START       reduce using rule 7 (programa3 -> programa3 modulos .)
    RES_FUNC        reduce using rule 7 (programa3 -> programa3 modulos .)
    $end            reduce using rule 7 (programa3 -> programa3 modulos .)


state 23

    (1) programa -> programa1 programa2 programa3 main . programa3
    (7) programa3 -> . programa3 modulos
    (8) programa3 -> . empty
    (125) empty -> .

    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)

    programa3                      shift and go to state 38
    empty                          shift and go to state 12

state 24

    (20) estructura -> array .

    RES_INT         reduce using rule 20 (estructura -> array .)
    RES_FLOAT       reduce using rule 20 (estructura -> array .)
    RES_BOOLEAN     reduce using rule 20 (estructura -> array .)
    RES_STRING      reduce using rule 20 (estructura -> array .)
    RES_LIST        reduce using rule 20 (estructura -> array .)
    RES_ARRAY       reduce using rule 20 (estructura -> array .)
    NEW_LINE        reduce using rule 20 (estructura -> array .)
    ID              reduce using rule 20 (estructura -> array .)
    RPAREN          reduce using rule 20 (estructura -> array .)


state 25

    (21) vars -> RES_DEF vars1 . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 39

state 26

    (22) vars1 -> estructura .
    (23) vars1 -> estructura . vars1
    (22) vars1 -> . estructura
    (23) vars1 -> . estructura vars1
    (24) vars1 -> . dato VAR vars2 vars1_1
    (19) estructura -> . list
    (20) estructura -> . array
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING
    (31) list -> . RES_LIST dato ID list1 empty_lines_almost_one
    (37) array -> . RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    NEW_LINE        reduce using rule 22 (vars1 -> estructura .)
    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16
    RES_LIST        shift and go to state 28
    RES_ARRAY       shift and go to state 30

    list                           shift and go to state 29
    estructura                     shift and go to state 26
    dato                           shift and go to state 27
    vars1                          shift and go to state 40
    array                          shift and go to state 24

state 27

    (24) vars1 -> dato . VAR vars2 vars1_1

    VAR             shift and go to state 41


state 28

    (31) list -> RES_LIST . dato ID list1 empty_lines_almost_one
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16

    dato                           shift and go to state 42

state 29

    (19) estructura -> list .

    RES_INT         reduce using rule 19 (estructura -> list .)
    RES_FLOAT       reduce using rule 19 (estructura -> list .)
    RES_BOOLEAN     reduce using rule 19 (estructura -> list .)
    RES_STRING      reduce using rule 19 (estructura -> list .)
    RES_LIST        reduce using rule 19 (estructura -> list .)
    RES_ARRAY       reduce using rule 19 (estructura -> list .)
    NEW_LINE        reduce using rule 19 (estructura -> list .)
    ID              reduce using rule 19 (estructura -> list .)
    RPAREN          reduce using rule 19 (estructura -> list .)


state 30

    (37) array -> RES_ARRAY . dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16

    dato                           shift and go to state 43

state 31

    (3) programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 . NEW_LINE

    NEW_LINE        shift and go to state 44


state 32

    (4) programa1 -> empty .

    NEW_LINE        reduce using rule 4 (programa1 -> empty .)


state 33

    (124) empty_lines_almost_one -> NEW_LINE empty_lines .
    (122) empty_lines -> empty_lines . NEW_LINE

  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_READ        reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_PRINT       reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    VAR             reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_DEF         reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_IF          reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_SWITCH      reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_WHILE       reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_FOR         reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_START       reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_FUNC        reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    $end            reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_END         reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_ELSE        reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_INT         reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_FLOAT       reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_BOOLEAN     reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_STRING      reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_LIST        reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_ARRAY       reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    COMMA           reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RCURLY          reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    TIMES           reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    DIVIDE          reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    PLUS            reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    MINUS           reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    MIN             reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    MIN_EQ          reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    MAY             reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    MAY_EQ          reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    DIF             reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RPAREN          reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    COL             reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RBRACKET        reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_PROTO       reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    RES_CASE        reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    ID              reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .)
    NEW_LINE        shift and go to state 45

  ! NEW_LINE        [ reduce using rule 124 (empty_lines_almost_one -> NEW_LINE empty_lines .) ]


state 34

    (123) empty_lines -> empty .

    NEW_LINE        reduce using rule 123 (empty_lines -> empty .)
    RES_PROTO       reduce using rule 123 (empty_lines -> empty .)
    RES_DEF         reduce using rule 123 (empty_lines -> empty .)
    RES_START       reduce using rule 123 (empty_lines -> empty .)
    RES_FUNC        reduce using rule 123 (empty_lines -> empty .)
    $end            reduce using rule 123 (empty_lines -> empty .)
    RES_END         reduce using rule 123 (empty_lines -> empty .)
    RES_ELSE        reduce using rule 123 (empty_lines -> empty .)
    RES_READ        reduce using rule 123 (empty_lines -> empty .)
    RES_PRINT       reduce using rule 123 (empty_lines -> empty .)
    VAR             reduce using rule 123 (empty_lines -> empty .)
    RES_IF          reduce using rule 123 (empty_lines -> empty .)
    RES_SWITCH      reduce using rule 123 (empty_lines -> empty .)
    RES_WHILE       reduce using rule 123 (empty_lines -> empty .)
    RES_FOR         reduce using rule 123 (empty_lines -> empty .)
    RES_INT         reduce using rule 123 (empty_lines -> empty .)
    RES_FLOAT       reduce using rule 123 (empty_lines -> empty .)
    RES_BOOLEAN     reduce using rule 123 (empty_lines -> empty .)
    RES_STRING      reduce using rule 123 (empty_lines -> empty .)
    RES_LIST        reduce using rule 123 (empty_lines -> empty .)
    RES_ARRAY       reduce using rule 123 (empty_lines -> empty .)
    ID              reduce using rule 123 (empty_lines -> empty .)
    RPAREN          reduce using rule 123 (empty_lines -> empty .)
    RES_CASE        reduce using rule 123 (empty_lines -> empty .)
    COMMA           reduce using rule 123 (empty_lines -> empty .)
    RCURLY          reduce using rule 123 (empty_lines -> empty .)
    TIMES           reduce using rule 123 (empty_lines -> empty .)
    DIVIDE          reduce using rule 123 (empty_lines -> empty .)
    PLUS            reduce using rule 123 (empty_lines -> empty .)
    MINUS           reduce using rule 123 (empty_lines -> empty .)
    MIN             reduce using rule 123 (empty_lines -> empty .)
    MIN_EQ          reduce using rule 123 (empty_lines -> empty .)
    MAY             reduce using rule 123 (empty_lines -> empty .)
    MAY_EQ          reduce using rule 123 (empty_lines -> empty .)
    DIF             reduce using rule 123 (empty_lines -> empty .)
    COL             reduce using rule 123 (empty_lines -> empty .)
    RBRACKET        reduce using rule 123 (empty_lines -> empty .)


state 35

    (9) prototipos -> RES_FUNC dato ID . LPAREN prototipos_1 RPAREN

    LPAREN          shift and go to state 46


state 36

    (42) modulos -> prototipos COL . empty_lines_almost_one bloque
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 47

state 37

    (117) main -> RES_START COL . NEW_LINE bloque RES_END empty_lines

    NEW_LINE        shift and go to state 48


state 38

    (1) programa -> programa1 programa2 programa3 main programa3 .
    (7) programa3 -> programa3 . modulos
    (42) modulos -> . prototipos COL empty_lines_almost_one bloque
    (9) prototipos -> . RES_FUNC dato ID LPAREN prototipos_1 RPAREN

    $end            reduce using rule 1 (programa -> programa1 programa2 programa3 main programa3 .)
    RES_FUNC        shift and go to state 8

    prototipos                     shift and go to state 20
    modulos                        shift and go to state 22

state 39

    (21) vars -> RES_DEF vars1 empty_lines_almost_one .

    NEW_LINE        reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)
    RES_START       reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)
    RES_FUNC        reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)
    $end            reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)
    RES_END         reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)
    RES_ELSE        reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)
    RES_DEF         reduce using rule 21 (vars -> RES_DEF vars1 empty_lines_almost_one .)


state 40

    (23) vars1 -> estructura vars1 .

    NEW_LINE        reduce using rule 23 (vars1 -> estructura vars1 .)


state 41

    (24) vars1 -> dato VAR . vars2 vars1_1
    (27) vars2 -> . EQUALS cons
    (28) vars2 -> . vars3
    (29) vars3 -> . COMMA VAR vars3
    (30) vars3 -> . empty
    (125) empty -> .

    EQUALS          shift and go to state 49
    COMMA           shift and go to state 52
    RES_INT         reduce using rule 125 (empty -> .)
    RES_FLOAT       reduce using rule 125 (empty -> .)
    RES_BOOLEAN     reduce using rule 125 (empty -> .)
    RES_STRING      reduce using rule 125 (empty -> .)
    RES_LIST        reduce using rule 125 (empty -> .)
    RES_ARRAY       reduce using rule 125 (empty -> .)
    NEW_LINE        reduce using rule 125 (empty -> .)

    vars3                          shift and go to state 50
    vars2                          shift and go to state 51
    empty                          shift and go to state 53

state 42

    (31) list -> RES_LIST dato . ID list1 empty_lines_almost_one

    ID              shift and go to state 54


state 43

    (37) array -> RES_ARRAY dato . VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    VAR             shift and go to state 55


state 44

    (3) programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE .

    RES_DEF         reduce using rule 3 (programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE .)
    RES_START       reduce using rule 3 (programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE .)
    RES_FUNC        reduce using rule 3 (programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE .)
    NEW_LINE        reduce using rule 3 (programa1 -> RES_PROTO prototipos empty_lines_almost_one programa1 NEW_LINE .)


state 45

    (122) empty_lines -> empty_lines NEW_LINE .

    NEW_LINE        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_PROTO       reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_DEF         reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_START       reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_FUNC        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    $end            reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_END         reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_ELSE        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_READ        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_PRINT       reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    VAR             reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_IF          reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_SWITCH      reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_WHILE       reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_FOR         reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_INT         reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_FLOAT       reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_BOOLEAN     reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_STRING      reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_LIST        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_ARRAY       reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    ID              reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RPAREN          reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RES_CASE        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    COMMA           reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RCURLY          reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    TIMES           reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    DIVIDE          reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    PLUS            reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    MINUS           reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    MIN             reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    MIN_EQ          reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    MAY             reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    MAY_EQ          reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    DIF             reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    COL             reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)
    RBRACKET        reduce using rule 122 (empty_lines -> empty_lines NEW_LINE .)


state 46

    (9) prototipos -> RES_FUNC dato ID LPAREN . prototipos_1 RPAREN
    (10) prototipos_1 -> . tipo ID prototipos_2
    (17) tipo -> . dato
    (18) tipo -> . estructura
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING
    (19) estructura -> . list
    (20) estructura -> . array
    (31) list -> . RES_LIST dato ID list1 empty_lines_almost_one
    (37) array -> . RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16
    RES_LIST        shift and go to state 28
    RES_ARRAY       shift and go to state 30

    tipo                           shift and go to state 57
    prototipos_1                   shift and go to state 56
    list                           shift and go to state 29
    estructura                     shift and go to state 58
    dato                           shift and go to state 59
    array                          shift and go to state 24

state 47

    (42) modulos -> prototipos COL empty_lines_almost_one . bloque
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 62
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 48

    (117) main -> RES_START COL NEW_LINE . bloque RES_END empty_lines
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    RES_END         reduce using rule 125 (empty -> .)
    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 82
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 49

    (27) vars2 -> EQUALS . cons
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    cons                           shift and go to state 84
    consarray                      shift and go to state 85

state 50

    (28) vars2 -> vars3 .

    RES_INT         reduce using rule 28 (vars2 -> vars3 .)
    RES_FLOAT       reduce using rule 28 (vars2 -> vars3 .)
    RES_BOOLEAN     reduce using rule 28 (vars2 -> vars3 .)
    RES_STRING      reduce using rule 28 (vars2 -> vars3 .)
    RES_LIST        reduce using rule 28 (vars2 -> vars3 .)
    RES_ARRAY       reduce using rule 28 (vars2 -> vars3 .)
    NEW_LINE        reduce using rule 28 (vars2 -> vars3 .)


state 51

    (24) vars1 -> dato VAR vars2 . vars1_1
    (25) vars1_1 -> . vars1
    (26) vars1_1 -> . empty
    (22) vars1 -> . estructura
    (23) vars1 -> . estructura vars1
    (24) vars1 -> . dato VAR vars2 vars1_1
    (125) empty -> .
    (19) estructura -> . list
    (20) estructura -> . array
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING
    (31) list -> . RES_LIST dato ID list1 empty_lines_almost_one
    (37) array -> . RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16
    RES_LIST        shift and go to state 28
    RES_ARRAY       shift and go to state 30

    list                           shift and go to state 29
    estructura                     shift and go to state 26
    dato                           shift and go to state 27
    vars1                          shift and go to state 91
    vars1_1                        shift and go to state 90
    array                          shift and go to state 24
    empty                          shift and go to state 92

state 52

    (29) vars3 -> COMMA . VAR vars3

    VAR             shift and go to state 93


state 53

    (30) vars3 -> empty .

    RES_INT         reduce using rule 30 (vars3 -> empty .)
    RES_FLOAT       reduce using rule 30 (vars3 -> empty .)
    RES_BOOLEAN     reduce using rule 30 (vars3 -> empty .)
    RES_STRING      reduce using rule 30 (vars3 -> empty .)
    RES_LIST        reduce using rule 30 (vars3 -> empty .)
    RES_ARRAY       reduce using rule 30 (vars3 -> empty .)
    NEW_LINE        reduce using rule 30 (vars3 -> empty .)


state 54

    (31) list -> RES_LIST dato ID . list1 empty_lines_almost_one
    (32) list1 -> . LCURLY cons_loop RCURLY
    (33) list1 -> . empty
    (125) empty -> .

    LCURLY          shift and go to state 95
    NEW_LINE        reduce using rule 125 (empty -> .)

    list1                          shift and go to state 94
    empty                          shift and go to state 96

state 55

    (37) array -> RES_ARRAY dato VAR . LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    LBRACKET        shift and go to state 97


state 56

    (9) prototipos -> RES_FUNC dato ID LPAREN prototipos_1 . RPAREN

    RPAREN          shift and go to state 98


state 57

    (10) prototipos_1 -> tipo . ID prototipos_2

    ID              shift and go to state 99


state 58

    (18) tipo -> estructura .

    RPAREN          reduce using rule 18 (tipo -> estructura .)
    ID              reduce using rule 18 (tipo -> estructura .)


state 59

    (17) tipo -> dato .

    RPAREN          reduce using rule 17 (tipo -> dato .)
    ID              reduce using rule 17 (tipo -> dato .)


state 60

    (52) estatutos -> vars .

    NEW_LINE        reduce using rule 52 (estatutos -> vars .)
    RES_START       reduce using rule 52 (estatutos -> vars .)
    RES_FUNC        reduce using rule 52 (estatutos -> vars .)
    $end            reduce using rule 52 (estatutos -> vars .)
    RES_END         reduce using rule 52 (estatutos -> vars .)
    RES_ELSE        reduce using rule 52 (estatutos -> vars .)


state 61

    (80) for -> RES_FOR . LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    LPAREN          shift and go to state 100


state 62

    (42) modulos -> prototipos COL empty_lines_almost_one bloque .
    (43) bloque -> bloque . NEW_LINE

    RES_START       reduce using rule 42 (modulos -> prototipos COL empty_lines_almost_one bloque .)
    RES_FUNC        reduce using rule 42 (modulos -> prototipos COL empty_lines_almost_one bloque .)
    $end            reduce using rule 42 (modulos -> prototipos COL empty_lines_almost_one bloque .)
    NEW_LINE        shift and go to state 101


state 63

    (88) if -> RES_IF . LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> RES_IF . LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque

    LPAREN          shift and go to state 102


state 64

    (55) condicion -> if .

    NEW_LINE        reduce using rule 55 (condicion -> if .)
    RES_START       reduce using rule 55 (condicion -> if .)
    RES_FUNC        reduce using rule 55 (condicion -> if .)
    $end            reduce using rule 55 (condicion -> if .)
    RES_END         reduce using rule 55 (condicion -> if .)
    RES_ELSE        reduce using rule 55 (condicion -> if .)


state 65

    (47) estatutos -> ciclo .

    NEW_LINE        reduce using rule 47 (estatutos -> ciclo .)
    RES_START       reduce using rule 47 (estatutos -> ciclo .)
    RES_FUNC        reduce using rule 47 (estatutos -> ciclo .)
    $end            reduce using rule 47 (estatutos -> ciclo .)
    RES_END         reduce using rule 47 (estatutos -> ciclo .)
    RES_ELSE        reduce using rule 47 (estatutos -> ciclo .)


state 66

    (57) condicion -> switch .

    NEW_LINE        reduce using rule 57 (condicion -> switch .)
    RES_START       reduce using rule 57 (condicion -> switch .)
    RES_FUNC        reduce using rule 57 (condicion -> switch .)
    $end            reduce using rule 57 (condicion -> switch .)
    RES_END         reduce using rule 57 (condicion -> switch .)
    RES_ELSE        reduce using rule 57 (condicion -> switch .)


state 67

    (54) ciclo -> for .

    RES_END         reduce using rule 54 (ciclo -> for .)
    NEW_LINE        reduce using rule 54 (ciclo -> for .)
    RES_START       reduce using rule 54 (ciclo -> for .)
    RES_FUNC        reduce using rule 54 (ciclo -> for .)
    $end            reduce using rule 54 (ciclo -> for .)
    RES_ELSE        reduce using rule 54 (ciclo -> for .)


state 68

    (51) estatutos -> llamada .

    NEW_LINE        reduce using rule 51 (estatutos -> llamada .)
    RES_START       reduce using rule 51 (estatutos -> llamada .)
    RES_FUNC        reduce using rule 51 (estatutos -> llamada .)
    $end            reduce using rule 51 (estatutos -> llamada .)
    RES_END         reduce using rule 51 (estatutos -> llamada .)
    RES_ELSE        reduce using rule 51 (estatutos -> llamada .)


state 69

    (46) estatutos -> condicion .

    NEW_LINE        reduce using rule 46 (estatutos -> condicion .)
    RES_START       reduce using rule 46 (estatutos -> condicion .)
    RES_FUNC        reduce using rule 46 (estatutos -> condicion .)
    $end            reduce using rule 46 (estatutos -> condicion .)
    RES_END         reduce using rule 46 (estatutos -> condicion .)
    RES_ELSE        reduce using rule 46 (estatutos -> condicion .)


state 70

    (56) condicion -> ifelse .

    NEW_LINE        reduce using rule 56 (condicion -> ifelse .)
    RES_START       reduce using rule 56 (condicion -> ifelse .)
    RES_FUNC        reduce using rule 56 (condicion -> ifelse .)
    $end            reduce using rule 56 (condicion -> ifelse .)
    RES_END         reduce using rule 56 (condicion -> ifelse .)
    RES_ELSE        reduce using rule 56 (condicion -> ifelse .)


state 71

    (48) estatutos -> lectura .

    NEW_LINE        reduce using rule 48 (estatutos -> lectura .)
    RES_START       reduce using rule 48 (estatutos -> lectura .)
    RES_FUNC        reduce using rule 48 (estatutos -> lectura .)
    $end            reduce using rule 48 (estatutos -> lectura .)
    RES_END         reduce using rule 48 (estatutos -> lectura .)
    RES_ELSE        reduce using rule 48 (estatutos -> lectura .)


state 72

    (45) bloque -> empty .

    NEW_LINE        reduce using rule 45 (bloque -> empty .)
    RES_START       reduce using rule 45 (bloque -> empty .)
    RES_FUNC        reduce using rule 45 (bloque -> empty .)
    $end            reduce using rule 45 (bloque -> empty .)
    RES_END         reduce using rule 45 (bloque -> empty .)
    RES_ELSE        reduce using rule 45 (bloque -> empty .)


state 73

    (44) bloque -> estatutos .

    NEW_LINE        reduce using rule 44 (bloque -> estatutos .)
    RES_START       reduce using rule 44 (bloque -> estatutos .)
    RES_FUNC        reduce using rule 44 (bloque -> estatutos .)
    $end            reduce using rule 44 (bloque -> estatutos .)
    RES_END         reduce using rule 44 (bloque -> estatutos .)
    RES_ELSE        reduce using rule 44 (bloque -> estatutos .)


state 74

    (79) while -> RES_WHILE . LPAREN expresion RPAREN COL empty_lines_almost_one bloque

    LPAREN          shift and go to state 103


state 75

    (67) asignacion -> VAR . EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> VAR . LPAREN llamada1 RPAREN empty_lines_almost_one

    EQUALS          shift and go to state 104
    LPAREN          shift and go to state 105


state 76

    (61) lectura -> RES_READ . LPAREN tipo RPAREN empty_lines_almost_one

    LPAREN          shift and go to state 106


state 77

    (50) estatutos -> asignacion .

    NEW_LINE        reduce using rule 50 (estatutos -> asignacion .)
    RES_START       reduce using rule 50 (estatutos -> asignacion .)
    RES_FUNC        reduce using rule 50 (estatutos -> asignacion .)
    $end            reduce using rule 50 (estatutos -> asignacion .)
    RES_END         reduce using rule 50 (estatutos -> asignacion .)
    RES_ELSE        reduce using rule 50 (estatutos -> asignacion .)


state 78

    (90) switch -> RES_SWITCH . COL empty_lines_almost_one switch2

    COL             shift and go to state 107


state 79

    (62) escritura -> RES_PRINT . LPAREN escritura1 RPAREN empty_lines_almost_one

    LPAREN          shift and go to state 108


state 80

    (53) ciclo -> while .

    RES_END         reduce using rule 53 (ciclo -> while .)
    NEW_LINE        reduce using rule 53 (ciclo -> while .)
    RES_START       reduce using rule 53 (ciclo -> while .)
    RES_FUNC        reduce using rule 53 (ciclo -> while .)
    $end            reduce using rule 53 (ciclo -> while .)
    RES_ELSE        reduce using rule 53 (ciclo -> while .)


state 81

    (49) estatutos -> escritura .

    NEW_LINE        reduce using rule 49 (estatutos -> escritura .)
    RES_START       reduce using rule 49 (estatutos -> escritura .)
    RES_FUNC        reduce using rule 49 (estatutos -> escritura .)
    $end            reduce using rule 49 (estatutos -> escritura .)
    RES_END         reduce using rule 49 (estatutos -> escritura .)
    RES_ELSE        reduce using rule 49 (estatutos -> escritura .)


state 82

    (117) main -> RES_START COL NEW_LINE bloque . RES_END empty_lines
    (43) bloque -> bloque . NEW_LINE

    RES_END         shift and go to state 109
    NEW_LINE        shift and go to state 101


state 83

    (114) cons -> CTE_STRING .

    NEW_LINE        reduce using rule 114 (cons -> CTE_STRING .)
    COL             reduce using rule 114 (cons -> CTE_STRING .)
    COMMA           reduce using rule 114 (cons -> CTE_STRING .)
    RCURLY          reduce using rule 114 (cons -> CTE_STRING .)
    TIMES           reduce using rule 114 (cons -> CTE_STRING .)
    DIVIDE          reduce using rule 114 (cons -> CTE_STRING .)
    PLUS            reduce using rule 114 (cons -> CTE_STRING .)
    MINUS           reduce using rule 114 (cons -> CTE_STRING .)
    MIN             reduce using rule 114 (cons -> CTE_STRING .)
    MIN_EQ          reduce using rule 114 (cons -> CTE_STRING .)
    MAY             reduce using rule 114 (cons -> CTE_STRING .)
    MAY_EQ          reduce using rule 114 (cons -> CTE_STRING .)
    DIF             reduce using rule 114 (cons -> CTE_STRING .)
    RPAREN          reduce using rule 114 (cons -> CTE_STRING .)
    RBRACKET        reduce using rule 114 (cons -> CTE_STRING .)
    RES_INT         reduce using rule 114 (cons -> CTE_STRING .)
    RES_FLOAT       reduce using rule 114 (cons -> CTE_STRING .)
    RES_BOOLEAN     reduce using rule 114 (cons -> CTE_STRING .)
    RES_STRING      reduce using rule 114 (cons -> CTE_STRING .)
    RES_LIST        reduce using rule 114 (cons -> CTE_STRING .)
    RES_ARRAY       reduce using rule 114 (cons -> CTE_STRING .)


state 84

    (27) vars2 -> EQUALS cons .

    RES_INT         reduce using rule 27 (vars2 -> EQUALS cons .)
    RES_FLOAT       reduce using rule 27 (vars2 -> EQUALS cons .)
    RES_BOOLEAN     reduce using rule 27 (vars2 -> EQUALS cons .)
    RES_STRING      reduce using rule 27 (vars2 -> EQUALS cons .)
    RES_LIST        reduce using rule 27 (vars2 -> EQUALS cons .)
    RES_ARRAY       reduce using rule 27 (vars2 -> EQUALS cons .)
    NEW_LINE        reduce using rule 27 (vars2 -> EQUALS cons .)


state 85

    (115) cons -> consarray .

    NEW_LINE        reduce using rule 115 (cons -> consarray .)
    COL             reduce using rule 115 (cons -> consarray .)
    COMMA           reduce using rule 115 (cons -> consarray .)
    RCURLY          reduce using rule 115 (cons -> consarray .)
    TIMES           reduce using rule 115 (cons -> consarray .)
    DIVIDE          reduce using rule 115 (cons -> consarray .)
    PLUS            reduce using rule 115 (cons -> consarray .)
    MINUS           reduce using rule 115 (cons -> consarray .)
    MIN             reduce using rule 115 (cons -> consarray .)
    MIN_EQ          reduce using rule 115 (cons -> consarray .)
    MAY             reduce using rule 115 (cons -> consarray .)
    MAY_EQ          reduce using rule 115 (cons -> consarray .)
    DIF             reduce using rule 115 (cons -> consarray .)
    RPAREN          reduce using rule 115 (cons -> consarray .)
    RBRACKET        reduce using rule 115 (cons -> consarray .)
    RES_INT         reduce using rule 115 (cons -> consarray .)
    RES_FLOAT       reduce using rule 115 (cons -> consarray .)
    RES_BOOLEAN     reduce using rule 115 (cons -> consarray .)
    RES_STRING      reduce using rule 115 (cons -> consarray .)
    RES_LIST        reduce using rule 115 (cons -> consarray .)
    RES_ARRAY       reduce using rule 115 (cons -> consarray .)


state 86

    (113) cons -> CTE_FLOAT .

    NEW_LINE        reduce using rule 113 (cons -> CTE_FLOAT .)
    COL             reduce using rule 113 (cons -> CTE_FLOAT .)
    COMMA           reduce using rule 113 (cons -> CTE_FLOAT .)
    RCURLY          reduce using rule 113 (cons -> CTE_FLOAT .)
    TIMES           reduce using rule 113 (cons -> CTE_FLOAT .)
    DIVIDE          reduce using rule 113 (cons -> CTE_FLOAT .)
    PLUS            reduce using rule 113 (cons -> CTE_FLOAT .)
    MINUS           reduce using rule 113 (cons -> CTE_FLOAT .)
    MIN             reduce using rule 113 (cons -> CTE_FLOAT .)
    MIN_EQ          reduce using rule 113 (cons -> CTE_FLOAT .)
    MAY             reduce using rule 113 (cons -> CTE_FLOAT .)
    MAY_EQ          reduce using rule 113 (cons -> CTE_FLOAT .)
    DIF             reduce using rule 113 (cons -> CTE_FLOAT .)
    RPAREN          reduce using rule 113 (cons -> CTE_FLOAT .)
    RBRACKET        reduce using rule 113 (cons -> CTE_FLOAT .)
    RES_INT         reduce using rule 113 (cons -> CTE_FLOAT .)
    RES_FLOAT       reduce using rule 113 (cons -> CTE_FLOAT .)
    RES_BOOLEAN     reduce using rule 113 (cons -> CTE_FLOAT .)
    RES_STRING      reduce using rule 113 (cons -> CTE_FLOAT .)
    RES_LIST        reduce using rule 113 (cons -> CTE_FLOAT .)
    RES_ARRAY       reduce using rule 113 (cons -> CTE_FLOAT .)


state 87

    (116) cons -> conslist .

    NEW_LINE        reduce using rule 116 (cons -> conslist .)
    COL             reduce using rule 116 (cons -> conslist .)
    COMMA           reduce using rule 116 (cons -> conslist .)
    RCURLY          reduce using rule 116 (cons -> conslist .)
    TIMES           reduce using rule 116 (cons -> conslist .)
    DIVIDE          reduce using rule 116 (cons -> conslist .)
    PLUS            reduce using rule 116 (cons -> conslist .)
    MINUS           reduce using rule 116 (cons -> conslist .)
    MIN             reduce using rule 116 (cons -> conslist .)
    MIN_EQ          reduce using rule 116 (cons -> conslist .)
    MAY             reduce using rule 116 (cons -> conslist .)
    MAY_EQ          reduce using rule 116 (cons -> conslist .)
    DIF             reduce using rule 116 (cons -> conslist .)
    RPAREN          reduce using rule 116 (cons -> conslist .)
    RBRACKET        reduce using rule 116 (cons -> conslist .)
    RES_INT         reduce using rule 116 (cons -> conslist .)
    RES_FLOAT       reduce using rule 116 (cons -> conslist .)
    RES_BOOLEAN     reduce using rule 116 (cons -> conslist .)
    RES_STRING      reduce using rule 116 (cons -> conslist .)
    RES_LIST        reduce using rule 116 (cons -> conslist .)
    RES_ARRAY       reduce using rule 116 (cons -> conslist .)


state 88

    (112) cons -> CTE_INT .

    NEW_LINE        reduce using rule 112 (cons -> CTE_INT .)
    COL             reduce using rule 112 (cons -> CTE_INT .)
    COMMA           reduce using rule 112 (cons -> CTE_INT .)
    RCURLY          reduce using rule 112 (cons -> CTE_INT .)
    TIMES           reduce using rule 112 (cons -> CTE_INT .)
    DIVIDE          reduce using rule 112 (cons -> CTE_INT .)
    PLUS            reduce using rule 112 (cons -> CTE_INT .)
    MINUS           reduce using rule 112 (cons -> CTE_INT .)
    MIN             reduce using rule 112 (cons -> CTE_INT .)
    MIN_EQ          reduce using rule 112 (cons -> CTE_INT .)
    MAY             reduce using rule 112 (cons -> CTE_INT .)
    MAY_EQ          reduce using rule 112 (cons -> CTE_INT .)
    DIF             reduce using rule 112 (cons -> CTE_INT .)
    RPAREN          reduce using rule 112 (cons -> CTE_INT .)
    RBRACKET        reduce using rule 112 (cons -> CTE_INT .)
    RES_INT         reduce using rule 112 (cons -> CTE_INT .)
    RES_FLOAT       reduce using rule 112 (cons -> CTE_INT .)
    RES_BOOLEAN     reduce using rule 112 (cons -> CTE_INT .)
    RES_STRING      reduce using rule 112 (cons -> CTE_INT .)
    RES_LIST        reduce using rule 112 (cons -> CTE_INT .)
    RES_ARRAY       reduce using rule 112 (cons -> CTE_INT .)


state 89

    (111) cons -> ID .
    (118) consarray -> ID . LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> ID . EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    NEW_LINE        reduce using rule 111 (cons -> ID .)
    COMMA           reduce using rule 111 (cons -> ID .)
    RCURLY          reduce using rule 111 (cons -> ID .)
    COL             reduce using rule 111 (cons -> ID .)
    TIMES           reduce using rule 111 (cons -> ID .)
    DIVIDE          reduce using rule 111 (cons -> ID .)
    PLUS            reduce using rule 111 (cons -> ID .)
    MINUS           reduce using rule 111 (cons -> ID .)
    MIN             reduce using rule 111 (cons -> ID .)
    MIN_EQ          reduce using rule 111 (cons -> ID .)
    MAY             reduce using rule 111 (cons -> ID .)
    MAY_EQ          reduce using rule 111 (cons -> ID .)
    DIF             reduce using rule 111 (cons -> ID .)
    RPAREN          reduce using rule 111 (cons -> ID .)
    RBRACKET        reduce using rule 111 (cons -> ID .)
    RES_INT         reduce using rule 111 (cons -> ID .)
    RES_FLOAT       reduce using rule 111 (cons -> ID .)
    RES_BOOLEAN     reduce using rule 111 (cons -> ID .)
    RES_STRING      reduce using rule 111 (cons -> ID .)
    RES_LIST        reduce using rule 111 (cons -> ID .)
    RES_ARRAY       reduce using rule 111 (cons -> ID .)
    LBRACKET        shift and go to state 111
    EQUALS          shift and go to state 110


state 90

    (24) vars1 -> dato VAR vars2 vars1_1 .

    NEW_LINE        reduce using rule 24 (vars1 -> dato VAR vars2 vars1_1 .)


state 91

    (25) vars1_1 -> vars1 .

    NEW_LINE        reduce using rule 25 (vars1_1 -> vars1 .)


state 92

    (26) vars1_1 -> empty .

    NEW_LINE        reduce using rule 26 (vars1_1 -> empty .)


state 93

    (29) vars3 -> COMMA VAR . vars3
    (29) vars3 -> . COMMA VAR vars3
    (30) vars3 -> . empty
    (125) empty -> .

    COMMA           shift and go to state 52
    RES_INT         reduce using rule 125 (empty -> .)
    RES_FLOAT       reduce using rule 125 (empty -> .)
    RES_BOOLEAN     reduce using rule 125 (empty -> .)
    RES_STRING      reduce using rule 125 (empty -> .)
    RES_LIST        reduce using rule 125 (empty -> .)
    RES_ARRAY       reduce using rule 125 (empty -> .)
    NEW_LINE        reduce using rule 125 (empty -> .)

    vars3                          shift and go to state 112
    empty                          shift and go to state 53

state 94

    (31) list -> RES_LIST dato ID list1 . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 113

state 95

    (32) list1 -> LCURLY . cons_loop RCURLY
    (34) cons_loop -> . cons cons_loop_1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 114
    cons_loop                      shift and go to state 115

state 96

    (33) list1 -> empty .

    NEW_LINE        reduce using rule 33 (list1 -> empty .)


state 97

    (37) array -> RES_ARRAY dato VAR LBRACKET . CTE_INT RBRACKET array1 empty_lines_almost_one

    CTE_INT         shift and go to state 116


state 98

    (9) prototipos -> RES_FUNC dato ID LPAREN prototipos_1 RPAREN .

    COL             reduce using rule 9 (prototipos -> RES_FUNC dato ID LPAREN prototipos_1 RPAREN .)
    NEW_LINE        reduce using rule 9 (prototipos -> RES_FUNC dato ID LPAREN prototipos_1 RPAREN .)


state 99

    (10) prototipos_1 -> tipo ID . prototipos_2
    (11) prototipos_2 -> . COMMA prototipos_1
    (12) prototipos_2 -> . empty
    (125) empty -> .

    COMMA           shift and go to state 118
    RPAREN          reduce using rule 125 (empty -> .)

    prototipos_2                   shift and go to state 117
    empty                          shift and go to state 119

state 100

    (80) for -> RES_FOR LPAREN . forexp RPAREN COL empty_lines_almost_one bloque
    (81) forexp -> . ID EQUALS cons COL ID comparacion ID COL ID EQUALS expresion
    (82) forexp -> . ID EQUALS cons COL ID comparacion cons COL ID EQUALS expresion

    ID              shift and go to state 120

    forexp                         shift and go to state 121

state 101

    (43) bloque -> bloque NEW_LINE .

    NEW_LINE        reduce using rule 43 (bloque -> bloque NEW_LINE .)
    RES_START       reduce using rule 43 (bloque -> bloque NEW_LINE .)
    RES_FUNC        reduce using rule 43 (bloque -> bloque NEW_LINE .)
    $end            reduce using rule 43 (bloque -> bloque NEW_LINE .)
    RES_END         reduce using rule 43 (bloque -> bloque NEW_LINE .)
    RES_ELSE        reduce using rule 43 (bloque -> bloque NEW_LINE .)


state 102

    (88) if -> RES_IF LPAREN . expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> RES_IF LPAREN . expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 122
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126

state 103

    (79) while -> RES_WHILE LPAREN . expresion RPAREN COL empty_lines_almost_one bloque
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 129
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126

state 104

    (67) asignacion -> VAR EQUALS . asignacion1 empty_lines_almost_one
    (68) asignacion1 -> . cons
    (69) asignacion1 -> . VAR
    (70) asignacion1 -> . expresion
    (71) asignacion1 -> . asignlist
    (72) asignacion1 -> . asignarray
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (73) asignlist -> . LCURLY asignlist1 RCURLY
    (76) asignarray -> . LBRACKET asignarray1 RBRACKET
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    VAR             shift and go to state 135
    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83
    LCURLY          shift and go to state 132
    LBRACKET        shift and go to state 131
    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 136
    cons                           shift and go to state 130
    factor                         shift and go to state 126
    asignarray                     shift and go to state 133
    conslist                       shift and go to state 87
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    asignlist                      shift and go to state 134
    asignacion1                    shift and go to state 137
    consarray                      shift and go to state 85

state 105

    (58) llamada -> VAR LPAREN . llamada1 RPAREN empty_lines_almost_one
    (59) llamada1 -> . expresion
    (60) llamada1 -> . expresion COMMA llamada1
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 138
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126
    llamada1                       shift and go to state 139

state 106

    (61) lectura -> RES_READ LPAREN . tipo RPAREN empty_lines_almost_one
    (17) tipo -> . dato
    (18) tipo -> . estructura
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING
    (19) estructura -> . list
    (20) estructura -> . array
    (31) list -> . RES_LIST dato ID list1 empty_lines_almost_one
    (37) array -> . RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16
    RES_LIST        shift and go to state 28
    RES_ARRAY       shift and go to state 30

    tipo                           shift and go to state 140
    list                           shift and go to state 29
    estructura                     shift and go to state 58
    dato                           shift and go to state 59
    array                          shift and go to state 24

state 107

    (90) switch -> RES_SWITCH COL . empty_lines_almost_one switch2
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 141

state 108

    (62) escritura -> RES_PRINT LPAREN . escritura1 RPAREN empty_lines_almost_one
    (63) escritura1 -> . expresion COMMA escritura1
    (64) escritura1 -> . CTE_STRING COMMA escritura1
    (65) escritura1 -> . expresion
    (66) escritura1 -> . CTE_STRING
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    CTE_STRING      shift and go to state 143
    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 142
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126
    escritura1                     shift and go to state 144

state 109

    (117) main -> RES_START COL NEW_LINE bloque RES_END . empty_lines
    (122) empty_lines -> . empty_lines NEW_LINE
    (123) empty_lines -> . empty
    (125) empty -> .

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)

    empty_lines                    shift and go to state 145
    empty                          shift and go to state 34

state 110

    (119) conslist -> ID EQUALS . LCURLY conslist1 RCURLY empty_lines_almost_one

    LCURLY          shift and go to state 146


state 111

    (118) consarray -> ID LBRACKET . CTE_INT RBRACKET EQUALS cons empty_lines_almost_one

    CTE_INT         shift and go to state 147


state 112

    (29) vars3 -> COMMA VAR vars3 .

    RES_INT         reduce using rule 29 (vars3 -> COMMA VAR vars3 .)
    RES_FLOAT       reduce using rule 29 (vars3 -> COMMA VAR vars3 .)
    RES_BOOLEAN     reduce using rule 29 (vars3 -> COMMA VAR vars3 .)
    RES_STRING      reduce using rule 29 (vars3 -> COMMA VAR vars3 .)
    RES_LIST        reduce using rule 29 (vars3 -> COMMA VAR vars3 .)
    RES_ARRAY       reduce using rule 29 (vars3 -> COMMA VAR vars3 .)
    NEW_LINE        reduce using rule 29 (vars3 -> COMMA VAR vars3 .)


state 113

    (31) list -> RES_LIST dato ID list1 empty_lines_almost_one .

    ID              reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RES_INT         reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RES_FLOAT       reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RES_BOOLEAN     reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RES_STRING      reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RES_LIST        reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RES_ARRAY       reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    NEW_LINE        reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)
    RPAREN          reduce using rule 31 (list -> RES_LIST dato ID list1 empty_lines_almost_one .)


state 114

    (34) cons_loop -> cons . cons_loop_1
    (35) cons_loop_1 -> . COMMA cons_loop
    (36) cons_loop_1 -> . empty
    (125) empty -> .

    COMMA           shift and go to state 148
    RCURLY          reduce using rule 125 (empty -> .)

    empty                          shift and go to state 149
    cons_loop_1                    shift and go to state 150

state 115

    (32) list1 -> LCURLY cons_loop . RCURLY

    RCURLY          shift and go to state 151


state 116

    (37) array -> RES_ARRAY dato VAR LBRACKET CTE_INT . RBRACKET array1 empty_lines_almost_one

    RBRACKET        shift and go to state 152


state 117

    (10) prototipos_1 -> tipo ID prototipos_2 .

    RPAREN          reduce using rule 10 (prototipos_1 -> tipo ID prototipos_2 .)


state 118

    (11) prototipos_2 -> COMMA . prototipos_1
    (10) prototipos_1 -> . tipo ID prototipos_2
    (17) tipo -> . dato
    (18) tipo -> . estructura
    (13) dato -> . RES_INT
    (14) dato -> . RES_FLOAT
    (15) dato -> . RES_BOOLEAN
    (16) dato -> . RES_STRING
    (19) estructura -> . list
    (20) estructura -> . array
    (31) list -> . RES_LIST dato ID list1 empty_lines_almost_one
    (37) array -> . RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one

    RES_INT         shift and go to state 15
    RES_FLOAT       shift and go to state 19
    RES_BOOLEAN     shift and go to state 17
    RES_STRING      shift and go to state 16
    RES_LIST        shift and go to state 28
    RES_ARRAY       shift and go to state 30

    tipo                           shift and go to state 57
    prototipos_1                   shift and go to state 153
    list                           shift and go to state 29
    estructura                     shift and go to state 58
    dato                           shift and go to state 59
    array                          shift and go to state 24

state 119

    (12) prototipos_2 -> empty .

    RPAREN          reduce using rule 12 (prototipos_2 -> empty .)


state 120

    (81) forexp -> ID . EQUALS cons COL ID comparacion ID COL ID EQUALS expresion
    (82) forexp -> ID . EQUALS cons COL ID comparacion cons COL ID EQUALS expresion

    EQUALS          shift and go to state 154


state 121

    (80) for -> RES_FOR LPAREN forexp . RPAREN COL empty_lines_almost_one bloque

    RPAREN          shift and go to state 155


state 122

    (88) if -> RES_IF LPAREN expresion . RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> RES_IF LPAREN expresion . RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque

    RPAREN          shift and go to state 156


state 123

    (109) factor -> PLUS . cons
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    cons                           shift and go to state 157
    consarray                      shift and go to state 85

state 124

    (100) exp -> termino . exp1
    (101) exp -> termino .
    (102) exp1 -> . PLUS exp
    (103) exp1 -> . MINUS exp

    MIN             reduce using rule 101 (exp -> termino .)
    MIN_EQ          reduce using rule 101 (exp -> termino .)
    MAY             reduce using rule 101 (exp -> termino .)
    MAY_EQ          reduce using rule 101 (exp -> termino .)
    DIF             reduce using rule 101 (exp -> termino .)
    RPAREN          reduce using rule 101 (exp -> termino .)
    COMMA           reduce using rule 101 (exp -> termino .)
    NEW_LINE        reduce using rule 101 (exp -> termino .)
    COL             reduce using rule 101 (exp -> termino .)
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160

    exp1                           shift and go to state 158

state 125

    (108) factor -> LPAREN . expresion RPAREN
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 161
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126

state 126

    (104) termino -> factor . termino1
    (105) termino -> factor .
    (106) termino1 -> . TIMES termino
    (107) termino1 -> . DIVIDE termino

    PLUS            reduce using rule 105 (termino -> factor .)
    MINUS           reduce using rule 105 (termino -> factor .)
    MIN             reduce using rule 105 (termino -> factor .)
    MIN_EQ          reduce using rule 105 (termino -> factor .)
    MAY             reduce using rule 105 (termino -> factor .)
    MAY_EQ          reduce using rule 105 (termino -> factor .)
    DIF             reduce using rule 105 (termino -> factor .)
    COL             reduce using rule 105 (termino -> factor .)
    RPAREN          reduce using rule 105 (termino -> factor .)
    NEW_LINE        reduce using rule 105 (termino -> factor .)
    COMMA           reduce using rule 105 (termino -> factor .)
    TIMES           shift and go to state 164
    DIVIDE          shift and go to state 162

    termino1                       shift and go to state 163

state 127

    (94) expresion -> exp .
    (95) expresion -> exp . MIN exp
    (96) expresion -> exp . MIN_EQ exp
    (97) expresion -> exp . MAY exp
    (98) expresion -> exp . MAY_EQ exp
    (99) expresion -> exp . DIF exp

    RPAREN          reduce using rule 94 (expresion -> exp .)
    COL             reduce using rule 94 (expresion -> exp .)
    NEW_LINE        reduce using rule 94 (expresion -> exp .)
    COMMA           reduce using rule 94 (expresion -> exp .)
    MIN             shift and go to state 166
    MIN_EQ          shift and go to state 165
    MAY             shift and go to state 167
    MAY_EQ          shift and go to state 168
    DIF             shift and go to state 169


state 128

    (110) factor -> MINUS . cons
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    cons                           shift and go to state 170
    consarray                      shift and go to state 85

state 129

    (79) while -> RES_WHILE LPAREN expresion . RPAREN COL empty_lines_almost_one bloque

    RPAREN          shift and go to state 171


state 130

    (68) asignacion1 -> cons .

    NEW_LINE        reduce using rule 68 (asignacion1 -> cons .)


state 131

    (76) asignarray -> LBRACKET . asignarray1 RBRACKET
    (77) asignarray1 -> . cons
    (78) asignarray1 -> . cons COMMA asignarray1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 172
    asignarray1                    shift and go to state 173

state 132

    (73) asignlist -> LCURLY . asignlist1 RCURLY
    (74) asignlist1 -> . cons
    (75) asignlist1 -> . cons COMMA asignlist1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    asignlist1                     shift and go to state 174
    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 175

state 133

    (72) asignacion1 -> asignarray .

    NEW_LINE        reduce using rule 72 (asignacion1 -> asignarray .)


state 134

    (71) asignacion1 -> asignlist .

    NEW_LINE        reduce using rule 71 (asignacion1 -> asignlist .)


state 135

    (69) asignacion1 -> VAR .

    NEW_LINE        reduce using rule 69 (asignacion1 -> VAR .)


state 136

    (70) asignacion1 -> expresion .

    NEW_LINE        reduce using rule 70 (asignacion1 -> expresion .)


state 137

    (67) asignacion -> VAR EQUALS asignacion1 . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 176

state 138

    (59) llamada1 -> expresion .
    (60) llamada1 -> expresion . COMMA llamada1

    RPAREN          reduce using rule 59 (llamada1 -> expresion .)
    COMMA           shift and go to state 177


state 139

    (58) llamada -> VAR LPAREN llamada1 . RPAREN empty_lines_almost_one

    RPAREN          shift and go to state 178


state 140

    (61) lectura -> RES_READ LPAREN tipo . RPAREN empty_lines_almost_one

    RPAREN          shift and go to state 179


state 141

    (90) switch -> RES_SWITCH COL empty_lines_almost_one . switch2
    (91) switch2 -> . RES_CASE expresion COL empty_lines_almost_one bloque
    (92) switch2 -> . switch2 NEW_LINE
    (93) switch2 -> . empty
    (125) empty -> .

    RES_CASE        shift and go to state 181
    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)

    switch2                        shift and go to state 180
    empty                          shift and go to state 182

state 142

    (63) escritura1 -> expresion . COMMA escritura1
    (65) escritura1 -> expresion .

    COMMA           shift and go to state 183
    RPAREN          reduce using rule 65 (escritura1 -> expresion .)


state 143

    (64) escritura1 -> CTE_STRING . COMMA escritura1
    (66) escritura1 -> CTE_STRING .

    COMMA           shift and go to state 184
    RPAREN          reduce using rule 66 (escritura1 -> CTE_STRING .)


state 144

    (62) escritura -> RES_PRINT LPAREN escritura1 . RPAREN empty_lines_almost_one

    RPAREN          shift and go to state 185


state 145

    (117) main -> RES_START COL NEW_LINE bloque RES_END empty_lines .
    (122) empty_lines -> empty_lines . NEW_LINE

    RES_FUNC        reduce using rule 117 (main -> RES_START COL NEW_LINE bloque RES_END empty_lines .)
    $end            reduce using rule 117 (main -> RES_START COL NEW_LINE bloque RES_END empty_lines .)
    NEW_LINE        shift and go to state 45


state 146

    (119) conslist -> ID EQUALS LCURLY . conslist1 RCURLY empty_lines_almost_one
    (120) conslist1 -> . cons
    (121) conslist1 -> . cons COMMA conslist1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist1                      shift and go to state 187
    conslist                       shift and go to state 87
    cons                           shift and go to state 186
    consarray                      shift and go to state 85

state 147

    (118) consarray -> ID LBRACKET CTE_INT . RBRACKET EQUALS cons empty_lines_almost_one

    RBRACKET        shift and go to state 188


state 148

    (35) cons_loop_1 -> COMMA . cons_loop
    (34) cons_loop -> . cons cons_loop_1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 114
    cons_loop                      shift and go to state 189

state 149

    (36) cons_loop_1 -> empty .

    RCURLY          reduce using rule 36 (cons_loop_1 -> empty .)


state 150

    (34) cons_loop -> cons cons_loop_1 .

    RCURLY          reduce using rule 34 (cons_loop -> cons cons_loop_1 .)


state 151

    (32) list1 -> LCURLY cons_loop RCURLY .

    NEW_LINE        reduce using rule 32 (list1 -> LCURLY cons_loop RCURLY .)


state 152

    (37) array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET . array1 empty_lines_almost_one
    (38) array1 -> . COL LBRACKET array2 RBRACKET
    (39) array1 -> . empty
    (125) empty -> .

    COL             shift and go to state 191
    NEW_LINE        reduce using rule 125 (empty -> .)

    array1                         shift and go to state 190
    empty                          shift and go to state 192

state 153

    (11) prototipos_2 -> COMMA prototipos_1 .

    RPAREN          reduce using rule 11 (prototipos_2 -> COMMA prototipos_1 .)


state 154

    (81) forexp -> ID EQUALS . cons COL ID comparacion ID COL ID EQUALS expresion
    (82) forexp -> ID EQUALS . cons COL ID comparacion cons COL ID EQUALS expresion
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 193

state 155

    (80) for -> RES_FOR LPAREN forexp RPAREN . COL empty_lines_almost_one bloque

    COL             shift and go to state 194


state 156

    (88) if -> RES_IF LPAREN expresion RPAREN . COL empty_lines_almost_one bloque
    (89) ifelse -> RES_IF LPAREN expresion RPAREN . COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque

    COL             shift and go to state 195


state 157

    (109) factor -> PLUS cons .

    TIMES           reduce using rule 109 (factor -> PLUS cons .)
    DIVIDE          reduce using rule 109 (factor -> PLUS cons .)
    PLUS            reduce using rule 109 (factor -> PLUS cons .)
    MINUS           reduce using rule 109 (factor -> PLUS cons .)
    RPAREN          reduce using rule 109 (factor -> PLUS cons .)
    NEW_LINE        reduce using rule 109 (factor -> PLUS cons .)
    COMMA           reduce using rule 109 (factor -> PLUS cons .)
    COL             reduce using rule 109 (factor -> PLUS cons .)
    MIN             reduce using rule 109 (factor -> PLUS cons .)
    MIN_EQ          reduce using rule 109 (factor -> PLUS cons .)
    MAY             reduce using rule 109 (factor -> PLUS cons .)
    MAY_EQ          reduce using rule 109 (factor -> PLUS cons .)
    DIF             reduce using rule 109 (factor -> PLUS cons .)


state 158

    (100) exp -> termino exp1 .

    MIN             reduce using rule 100 (exp -> termino exp1 .)
    MIN_EQ          reduce using rule 100 (exp -> termino exp1 .)
    MAY             reduce using rule 100 (exp -> termino exp1 .)
    MAY_EQ          reduce using rule 100 (exp -> termino exp1 .)
    DIF             reduce using rule 100 (exp -> termino exp1 .)
    RPAREN          reduce using rule 100 (exp -> termino exp1 .)
    COMMA           reduce using rule 100 (exp -> termino exp1 .)
    NEW_LINE        reduce using rule 100 (exp -> termino exp1 .)
    COL             reduce using rule 100 (exp -> termino exp1 .)


state 159

    (102) exp1 -> PLUS . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 196
    factor                         shift and go to state 126

state 160

    (103) exp1 -> MINUS . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 197
    factor                         shift and go to state 126

state 161

    (108) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 198


state 162

    (107) termino1 -> DIVIDE . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 199
    factor                         shift and go to state 126

state 163

    (104) termino -> factor termino1 .

    PLUS            reduce using rule 104 (termino -> factor termino1 .)
    MINUS           reduce using rule 104 (termino -> factor termino1 .)
    MIN             reduce using rule 104 (termino -> factor termino1 .)
    MIN_EQ          reduce using rule 104 (termino -> factor termino1 .)
    MAY             reduce using rule 104 (termino -> factor termino1 .)
    MAY_EQ          reduce using rule 104 (termino -> factor termino1 .)
    DIF             reduce using rule 104 (termino -> factor termino1 .)
    COL             reduce using rule 104 (termino -> factor termino1 .)
    RPAREN          reduce using rule 104 (termino -> factor termino1 .)
    NEW_LINE        reduce using rule 104 (termino -> factor termino1 .)
    COMMA           reduce using rule 104 (termino -> factor termino1 .)


state 164

    (106) termino1 -> TIMES . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 200
    factor                         shift and go to state 126

state 165

    (96) expresion -> exp MIN_EQ . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 201
    factor                         shift and go to state 126

state 166

    (95) expresion -> exp MIN . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 202
    factor                         shift and go to state 126

state 167

    (97) expresion -> exp MAY . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 203
    factor                         shift and go to state 126

state 168

    (98) expresion -> exp MAY_EQ . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 204
    factor                         shift and go to state 126

state 169

    (99) expresion -> exp DIF . exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    termino                        shift and go to state 124
    exp                            shift and go to state 205
    factor                         shift and go to state 126

state 170

    (110) factor -> MINUS cons .

    TIMES           reduce using rule 110 (factor -> MINUS cons .)
    DIVIDE          reduce using rule 110 (factor -> MINUS cons .)
    PLUS            reduce using rule 110 (factor -> MINUS cons .)
    MINUS           reduce using rule 110 (factor -> MINUS cons .)
    RPAREN          reduce using rule 110 (factor -> MINUS cons .)
    NEW_LINE        reduce using rule 110 (factor -> MINUS cons .)
    COMMA           reduce using rule 110 (factor -> MINUS cons .)
    COL             reduce using rule 110 (factor -> MINUS cons .)
    MIN             reduce using rule 110 (factor -> MINUS cons .)
    MIN_EQ          reduce using rule 110 (factor -> MINUS cons .)
    MAY             reduce using rule 110 (factor -> MINUS cons .)
    MAY_EQ          reduce using rule 110 (factor -> MINUS cons .)
    DIF             reduce using rule 110 (factor -> MINUS cons .)


state 171

    (79) while -> RES_WHILE LPAREN expresion RPAREN . COL empty_lines_almost_one bloque

    COL             shift and go to state 206


state 172

    (77) asignarray1 -> cons .
    (78) asignarray1 -> cons . COMMA asignarray1

    RBRACKET        reduce using rule 77 (asignarray1 -> cons .)
    COMMA           shift and go to state 207


state 173

    (76) asignarray -> LBRACKET asignarray1 . RBRACKET

    RBRACKET        shift and go to state 208


state 174

    (73) asignlist -> LCURLY asignlist1 . RCURLY

    RCURLY          shift and go to state 209


state 175

    (74) asignlist1 -> cons .
    (75) asignlist1 -> cons . COMMA asignlist1

    RCURLY          reduce using rule 74 (asignlist1 -> cons .)
    COMMA           shift and go to state 210


state 176

    (67) asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .

    RES_END         reduce using rule 67 (asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .)
    NEW_LINE        reduce using rule 67 (asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .)
    RES_START       reduce using rule 67 (asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .)
    RES_FUNC        reduce using rule 67 (asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .)
    $end            reduce using rule 67 (asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .)
    RES_ELSE        reduce using rule 67 (asignacion -> VAR EQUALS asignacion1 empty_lines_almost_one .)


state 177

    (60) llamada1 -> expresion COMMA . llamada1
    (59) llamada1 -> . expresion
    (60) llamada1 -> . expresion COMMA llamada1
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 138
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126
    llamada1                       shift and go to state 211

state 178

    (58) llamada -> VAR LPAREN llamada1 RPAREN . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 212

state 179

    (61) lectura -> RES_READ LPAREN tipo RPAREN . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 213

state 180

    (90) switch -> RES_SWITCH COL empty_lines_almost_one switch2 .
    (92) switch2 -> switch2 . NEW_LINE

  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_START       reduce using rule 90 (switch -> RES_SWITCH COL empty_lines_almost_one switch2 .)
    RES_FUNC        reduce using rule 90 (switch -> RES_SWITCH COL empty_lines_almost_one switch2 .)
    $end            reduce using rule 90 (switch -> RES_SWITCH COL empty_lines_almost_one switch2 .)
    RES_END         reduce using rule 90 (switch -> RES_SWITCH COL empty_lines_almost_one switch2 .)
    RES_ELSE        reduce using rule 90 (switch -> RES_SWITCH COL empty_lines_almost_one switch2 .)
    NEW_LINE        shift and go to state 214

  ! NEW_LINE        [ reduce using rule 90 (switch -> RES_SWITCH COL empty_lines_almost_one switch2 .) ]


state 181

    (91) switch2 -> RES_CASE . expresion COL empty_lines_almost_one bloque
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 215
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126

state 182

    (93) switch2 -> empty .

    NEW_LINE        reduce using rule 93 (switch2 -> empty .)
    RES_START       reduce using rule 93 (switch2 -> empty .)
    RES_FUNC        reduce using rule 93 (switch2 -> empty .)
    $end            reduce using rule 93 (switch2 -> empty .)
    RES_END         reduce using rule 93 (switch2 -> empty .)
    RES_ELSE        reduce using rule 93 (switch2 -> empty .)


state 183

    (63) escritura1 -> expresion COMMA . escritura1
    (63) escritura1 -> . expresion COMMA escritura1
    (64) escritura1 -> . CTE_STRING COMMA escritura1
    (65) escritura1 -> . expresion
    (66) escritura1 -> . CTE_STRING
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    CTE_STRING      shift and go to state 143
    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 142
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126
    escritura1                     shift and go to state 216

state 184

    (64) escritura1 -> CTE_STRING COMMA . escritura1
    (63) escritura1 -> . expresion COMMA escritura1
    (64) escritura1 -> . CTE_STRING COMMA escritura1
    (65) escritura1 -> . expresion
    (66) escritura1 -> . CTE_STRING
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    CTE_STRING      shift and go to state 143
    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 142
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126
    escritura1                     shift and go to state 217

state 185

    (62) escritura -> RES_PRINT LPAREN escritura1 RPAREN . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 218

state 186

    (120) conslist1 -> cons .
    (121) conslist1 -> cons . COMMA conslist1

    RCURLY          reduce using rule 120 (conslist1 -> cons .)
    COMMA           shift and go to state 219


state 187

    (119) conslist -> ID EQUALS LCURLY conslist1 . RCURLY empty_lines_almost_one

    RCURLY          shift and go to state 220


state 188

    (118) consarray -> ID LBRACKET CTE_INT RBRACKET . EQUALS cons empty_lines_almost_one

    EQUALS          shift and go to state 221


state 189

    (35) cons_loop_1 -> COMMA cons_loop .

    RCURLY          reduce using rule 35 (cons_loop_1 -> COMMA cons_loop .)


state 190

    (37) array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 222

state 191

    (38) array1 -> COL . LBRACKET array2 RBRACKET

    LBRACKET        shift and go to state 223


state 192

    (39) array1 -> empty .

    NEW_LINE        reduce using rule 39 (array1 -> empty .)


state 193

    (81) forexp -> ID EQUALS cons . COL ID comparacion ID COL ID EQUALS expresion
    (82) forexp -> ID EQUALS cons . COL ID comparacion cons COL ID EQUALS expresion

    COL             shift and go to state 224


state 194

    (80) for -> RES_FOR LPAREN forexp RPAREN COL . empty_lines_almost_one bloque
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 225

state 195

    (88) if -> RES_IF LPAREN expresion RPAREN COL . empty_lines_almost_one bloque
    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL . empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 226

state 196

    (102) exp1 -> PLUS exp .

    MIN             reduce using rule 102 (exp1 -> PLUS exp .)
    MIN_EQ          reduce using rule 102 (exp1 -> PLUS exp .)
    MAY             reduce using rule 102 (exp1 -> PLUS exp .)
    MAY_EQ          reduce using rule 102 (exp1 -> PLUS exp .)
    DIF             reduce using rule 102 (exp1 -> PLUS exp .)
    RPAREN          reduce using rule 102 (exp1 -> PLUS exp .)
    NEW_LINE        reduce using rule 102 (exp1 -> PLUS exp .)
    COMMA           reduce using rule 102 (exp1 -> PLUS exp .)
    COL             reduce using rule 102 (exp1 -> PLUS exp .)


state 197

    (103) exp1 -> MINUS exp .

    MIN             reduce using rule 103 (exp1 -> MINUS exp .)
    MIN_EQ          reduce using rule 103 (exp1 -> MINUS exp .)
    MAY             reduce using rule 103 (exp1 -> MINUS exp .)
    MAY_EQ          reduce using rule 103 (exp1 -> MINUS exp .)
    DIF             reduce using rule 103 (exp1 -> MINUS exp .)
    RPAREN          reduce using rule 103 (exp1 -> MINUS exp .)
    NEW_LINE        reduce using rule 103 (exp1 -> MINUS exp .)
    COMMA           reduce using rule 103 (exp1 -> MINUS exp .)
    COL             reduce using rule 103 (exp1 -> MINUS exp .)


state 198

    (108) factor -> LPAREN expresion RPAREN .

    TIMES           reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    NEW_LINE        reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    COMMA           reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    COL             reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    MIN             reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    MIN_EQ          reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    MAY             reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    MAY_EQ          reduce using rule 108 (factor -> LPAREN expresion RPAREN .)
    DIF             reduce using rule 108 (factor -> LPAREN expresion RPAREN .)


state 199

    (107) termino1 -> DIVIDE termino .

    PLUS            reduce using rule 107 (termino1 -> DIVIDE termino .)
    MINUS           reduce using rule 107 (termino1 -> DIVIDE termino .)
    MIN             reduce using rule 107 (termino1 -> DIVIDE termino .)
    MIN_EQ          reduce using rule 107 (termino1 -> DIVIDE termino .)
    MAY             reduce using rule 107 (termino1 -> DIVIDE termino .)
    MAY_EQ          reduce using rule 107 (termino1 -> DIVIDE termino .)
    DIF             reduce using rule 107 (termino1 -> DIVIDE termino .)
    RPAREN          reduce using rule 107 (termino1 -> DIVIDE termino .)
    NEW_LINE        reduce using rule 107 (termino1 -> DIVIDE termino .)
    COMMA           reduce using rule 107 (termino1 -> DIVIDE termino .)
    COL             reduce using rule 107 (termino1 -> DIVIDE termino .)


state 200

    (106) termino1 -> TIMES termino .

    PLUS            reduce using rule 106 (termino1 -> TIMES termino .)
    MINUS           reduce using rule 106 (termino1 -> TIMES termino .)
    MIN             reduce using rule 106 (termino1 -> TIMES termino .)
    MIN_EQ          reduce using rule 106 (termino1 -> TIMES termino .)
    MAY             reduce using rule 106 (termino1 -> TIMES termino .)
    MAY_EQ          reduce using rule 106 (termino1 -> TIMES termino .)
    DIF             reduce using rule 106 (termino1 -> TIMES termino .)
    RPAREN          reduce using rule 106 (termino1 -> TIMES termino .)
    NEW_LINE        reduce using rule 106 (termino1 -> TIMES termino .)
    COMMA           reduce using rule 106 (termino1 -> TIMES termino .)
    COL             reduce using rule 106 (termino1 -> TIMES termino .)


state 201

    (96) expresion -> exp MIN_EQ exp .

    RPAREN          reduce using rule 96 (expresion -> exp MIN_EQ exp .)
    COL             reduce using rule 96 (expresion -> exp MIN_EQ exp .)
    NEW_LINE        reduce using rule 96 (expresion -> exp MIN_EQ exp .)
    COMMA           reduce using rule 96 (expresion -> exp MIN_EQ exp .)


state 202

    (95) expresion -> exp MIN exp .

    RPAREN          reduce using rule 95 (expresion -> exp MIN exp .)
    COL             reduce using rule 95 (expresion -> exp MIN exp .)
    NEW_LINE        reduce using rule 95 (expresion -> exp MIN exp .)
    COMMA           reduce using rule 95 (expresion -> exp MIN exp .)


state 203

    (97) expresion -> exp MAY exp .

    RPAREN          reduce using rule 97 (expresion -> exp MAY exp .)
    COL             reduce using rule 97 (expresion -> exp MAY exp .)
    NEW_LINE        reduce using rule 97 (expresion -> exp MAY exp .)
    COMMA           reduce using rule 97 (expresion -> exp MAY exp .)


state 204

    (98) expresion -> exp MAY_EQ exp .

    RPAREN          reduce using rule 98 (expresion -> exp MAY_EQ exp .)
    COL             reduce using rule 98 (expresion -> exp MAY_EQ exp .)
    NEW_LINE        reduce using rule 98 (expresion -> exp MAY_EQ exp .)
    COMMA           reduce using rule 98 (expresion -> exp MAY_EQ exp .)


state 205

    (99) expresion -> exp DIF exp .

    RPAREN          reduce using rule 99 (expresion -> exp DIF exp .)
    COL             reduce using rule 99 (expresion -> exp DIF exp .)
    NEW_LINE        reduce using rule 99 (expresion -> exp DIF exp .)
    COMMA           reduce using rule 99 (expresion -> exp DIF exp .)


state 206

    (79) while -> RES_WHILE LPAREN expresion RPAREN COL . empty_lines_almost_one bloque
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 227

state 207

    (78) asignarray1 -> cons COMMA . asignarray1
    (77) asignarray1 -> . cons
    (78) asignarray1 -> . cons COMMA asignarray1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 172
    asignarray1                    shift and go to state 228

state 208

    (76) asignarray -> LBRACKET asignarray1 RBRACKET .

    NEW_LINE        reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)


state 209

    (73) asignlist -> LCURLY asignlist1 RCURLY .

    NEW_LINE        reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)


state 210

    (75) asignlist1 -> cons COMMA . asignlist1
    (74) asignlist1 -> . cons
    (75) asignlist1 -> . cons COMMA asignlist1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    asignlist1                     shift and go to state 229
    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 175

state 211

    (60) llamada1 -> expresion COMMA llamada1 .

    RPAREN          reduce using rule 60 (llamada1 -> expresion COMMA llamada1 .)


state 212

    (58) llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .

    RES_END         reduce using rule 58 (llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .)
    NEW_LINE        reduce using rule 58 (llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .)
    RES_START       reduce using rule 58 (llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .)
    RES_FUNC        reduce using rule 58 (llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .)
    $end            reduce using rule 58 (llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .)
    RES_ELSE        reduce using rule 58 (llamada -> VAR LPAREN llamada1 RPAREN empty_lines_almost_one .)


state 213

    (61) lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .

    NEW_LINE        reduce using rule 61 (lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .)
    RES_START       reduce using rule 61 (lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .)
    RES_FUNC        reduce using rule 61 (lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .)
    $end            reduce using rule 61 (lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .)
    RES_END         reduce using rule 61 (lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .)
    RES_ELSE        reduce using rule 61 (lectura -> RES_READ LPAREN tipo RPAREN empty_lines_almost_one .)


state 214

    (92) switch2 -> switch2 NEW_LINE .

    NEW_LINE        reduce using rule 92 (switch2 -> switch2 NEW_LINE .)
    RES_START       reduce using rule 92 (switch2 -> switch2 NEW_LINE .)
    RES_FUNC        reduce using rule 92 (switch2 -> switch2 NEW_LINE .)
    $end            reduce using rule 92 (switch2 -> switch2 NEW_LINE .)
    RES_END         reduce using rule 92 (switch2 -> switch2 NEW_LINE .)
    RES_ELSE        reduce using rule 92 (switch2 -> switch2 NEW_LINE .)


state 215

    (91) switch2 -> RES_CASE expresion . COL empty_lines_almost_one bloque

    COL             shift and go to state 230


state 216

    (63) escritura1 -> expresion COMMA escritura1 .

    RPAREN          reduce using rule 63 (escritura1 -> expresion COMMA escritura1 .)


state 217

    (64) escritura1 -> CTE_STRING COMMA escritura1 .

    RPAREN          reduce using rule 64 (escritura1 -> CTE_STRING COMMA escritura1 .)


state 218

    (62) escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .

    RES_END         reduce using rule 62 (escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .)
    NEW_LINE        reduce using rule 62 (escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .)
    RES_START       reduce using rule 62 (escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .)
    RES_FUNC        reduce using rule 62 (escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .)
    $end            reduce using rule 62 (escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .)
    RES_ELSE        reduce using rule 62 (escritura -> RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one .)


state 219

    (121) conslist1 -> cons COMMA . conslist1
    (120) conslist1 -> . cons
    (121) conslist1 -> . cons COMMA conslist1
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist1                      shift and go to state 231
    conslist                       shift and go to state 87
    cons                           shift and go to state 186
    consarray                      shift and go to state 85

state 220

    (119) conslist -> ID EQUALS LCURLY conslist1 RCURLY . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 232

state 221

    (118) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS . cons empty_lines_almost_one
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    cons                           shift and go to state 233
    consarray                      shift and go to state 85

state 222

    (37) array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .

    ID              reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RPAREN          reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RES_INT         reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RES_FLOAT       reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RES_BOOLEAN     reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RES_STRING      reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RES_LIST        reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    RES_ARRAY       reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)
    NEW_LINE        reduce using rule 37 (array -> RES_ARRAY dato VAR LBRACKET CTE_INT RBRACKET array1 empty_lines_almost_one .)


state 223

    (38) array1 -> COL LBRACKET . array2 RBRACKET
    (40) array2 -> . cons
    (41) array2 -> . cons COMMA array2
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    array2                         shift and go to state 235
    consarray                      shift and go to state 85
    cons                           shift and go to state 234

state 224

    (81) forexp -> ID EQUALS cons COL . ID comparacion ID COL ID EQUALS expresion
    (82) forexp -> ID EQUALS cons COL . ID comparacion cons COL ID EQUALS expresion

    ID              shift and go to state 236


state 225

    (80) for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one . bloque
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 237
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 226

    (88) if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one . bloque
    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one . bloque RES_ELSE COL empty_lines_almost_one bloque
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 238
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 227

    (79) while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one . bloque
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 239
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 228

    (78) asignarray1 -> cons COMMA asignarray1 .

    RBRACKET        reduce using rule 78 (asignarray1 -> cons COMMA asignarray1 .)


state 229

    (75) asignlist1 -> cons COMMA asignlist1 .

    RCURLY          reduce using rule 75 (asignlist1 -> cons COMMA asignlist1 .)


state 230

    (91) switch2 -> RES_CASE expresion COL . empty_lines_almost_one bloque
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 240

state 231

    (121) conslist1 -> cons COMMA conslist1 .

    RCURLY          reduce using rule 121 (conslist1 -> cons COMMA conslist1 .)


state 232

    (119) conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .

    COMMA           reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RCURLY          reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    TIMES           reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    DIVIDE          reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    PLUS            reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    MINUS           reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    MIN             reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    MIN_EQ          reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    MAY             reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    MAY_EQ          reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    DIF             reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RPAREN          reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    NEW_LINE        reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    COL             reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RBRACKET        reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RES_INT         reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RES_FLOAT       reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RES_BOOLEAN     reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RES_STRING      reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RES_LIST        reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)
    RES_ARRAY       reduce using rule 119 (conslist -> ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one .)


state 233

    (118) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons . empty_lines_almost_one
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 241

state 234

    (40) array2 -> cons .
    (41) array2 -> cons . COMMA array2

    RBRACKET        reduce using rule 40 (array2 -> cons .)
    COMMA           shift and go to state 242


state 235

    (38) array1 -> COL LBRACKET array2 . RBRACKET

    RBRACKET        shift and go to state 243


state 236

    (81) forexp -> ID EQUALS cons COL ID . comparacion ID COL ID EQUALS expresion
    (82) forexp -> ID EQUALS cons COL ID . comparacion cons COL ID EQUALS expresion
    (83) comparacion -> . MAY
    (84) comparacion -> . MAY_EQ
    (85) comparacion -> . MIN
    (86) comparacion -> . MIN_EQ
    (87) comparacion -> . DIF

    MAY             shift and go to state 245
    MAY_EQ          shift and go to state 246
    MIN             shift and go to state 244
    MIN_EQ          shift and go to state 247
    DIF             shift and go to state 249

    comparacion                    shift and go to state 248

state 237

    (80) for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .
    (43) bloque -> bloque . NEW_LINE

  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_START       reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .)
    RES_FUNC        reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .)
    $end            reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .)
    RES_END         reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .)
    RES_ELSE        reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .)
    NEW_LINE        shift and go to state 101

  ! NEW_LINE        [ reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque .) ]


state 238

    (88) if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .
    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque . RES_ELSE COL empty_lines_almost_one bloque
    (43) bloque -> bloque . NEW_LINE

  ! shift/reduce conflict for RES_ELSE resolved as shift
  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_START       reduce using rule 88 (if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    RES_FUNC        reduce using rule 88 (if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    $end            reduce using rule 88 (if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    RES_END         reduce using rule 88 (if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    RES_ELSE        shift and go to state 250
    NEW_LINE        shift and go to state 101

  ! NEW_LINE        [ reduce using rule 88 (if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .) ]
  ! RES_ELSE        [ reduce using rule 88 (if -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque .) ]


state 239

    (79) while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .
    (43) bloque -> bloque . NEW_LINE

  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_START       reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    RES_FUNC        reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    $end            reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    RES_END         reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    RES_ELSE        reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .)
    NEW_LINE        shift and go to state 101

  ! NEW_LINE        [ reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque .) ]


state 240

    (91) switch2 -> RES_CASE expresion COL empty_lines_almost_one . bloque
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 251
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 241

    (118) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .

    COMMA           reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RBRACKET        reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    TIMES           reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    DIVIDE          reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    PLUS            reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    MINUS           reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    MIN             reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    MIN_EQ          reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    MAY             reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    MAY_EQ          reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    DIF             reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RPAREN          reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    NEW_LINE        reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    COL             reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RCURLY          reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RES_INT         reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RES_FLOAT       reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RES_BOOLEAN     reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RES_STRING      reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RES_LIST        reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)
    RES_ARRAY       reduce using rule 118 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one .)


state 242

    (41) array2 -> cons COMMA . array2
    (40) array2 -> . cons
    (41) array2 -> . cons COMMA array2
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 89
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    array2                         shift and go to state 252
    consarray                      shift and go to state 85
    cons                           shift and go to state 234

state 243

    (38) array1 -> COL LBRACKET array2 RBRACKET .

    NEW_LINE        reduce using rule 38 (array1 -> COL LBRACKET array2 RBRACKET .)


state 244

    (85) comparacion -> MIN .

    ID              reduce using rule 85 (comparacion -> MIN .)
    CTE_INT         reduce using rule 85 (comparacion -> MIN .)
    CTE_FLOAT       reduce using rule 85 (comparacion -> MIN .)
    CTE_STRING      reduce using rule 85 (comparacion -> MIN .)


state 245

    (83) comparacion -> MAY .

    ID              reduce using rule 83 (comparacion -> MAY .)
    CTE_INT         reduce using rule 83 (comparacion -> MAY .)
    CTE_FLOAT       reduce using rule 83 (comparacion -> MAY .)
    CTE_STRING      reduce using rule 83 (comparacion -> MAY .)


state 246

    (84) comparacion -> MAY_EQ .

    ID              reduce using rule 84 (comparacion -> MAY_EQ .)
    CTE_INT         reduce using rule 84 (comparacion -> MAY_EQ .)
    CTE_FLOAT       reduce using rule 84 (comparacion -> MAY_EQ .)
    CTE_STRING      reduce using rule 84 (comparacion -> MAY_EQ .)


state 247

    (86) comparacion -> MIN_EQ .

    ID              reduce using rule 86 (comparacion -> MIN_EQ .)
    CTE_INT         reduce using rule 86 (comparacion -> MIN_EQ .)
    CTE_FLOAT       reduce using rule 86 (comparacion -> MIN_EQ .)
    CTE_STRING      reduce using rule 86 (comparacion -> MIN_EQ .)


state 248

    (81) forexp -> ID EQUALS cons COL ID comparacion . ID COL ID EQUALS expresion
    (82) forexp -> ID EQUALS cons COL ID comparacion . cons COL ID EQUALS expresion
    (111) cons -> . ID
    (112) cons -> . CTE_INT
    (113) cons -> . CTE_FLOAT
    (114) cons -> . CTE_STRING
    (115) cons -> . consarray
    (116) cons -> . conslist
    (118) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> . ID EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

    ID              shift and go to state 254
    CTE_INT         shift and go to state 88
    CTE_FLOAT       shift and go to state 86
    CTE_STRING      shift and go to state 83

    conslist                       shift and go to state 87
    consarray                      shift and go to state 85
    cons                           shift and go to state 253

state 249

    (87) comparacion -> DIF .

    ID              reduce using rule 87 (comparacion -> DIF .)
    CTE_INT         reduce using rule 87 (comparacion -> DIF .)
    CTE_FLOAT       reduce using rule 87 (comparacion -> DIF .)
    CTE_STRING      reduce using rule 87 (comparacion -> DIF .)


state 250

    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE . COL empty_lines_almost_one bloque

    COL             shift and go to state 255


state 251

    (91) switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .
    (43) bloque -> bloque . NEW_LINE

  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_START       reduce using rule 91 (switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .)
    RES_FUNC        reduce using rule 91 (switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .)
    $end            reduce using rule 91 (switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .)
    RES_END         reduce using rule 91 (switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .)
    RES_ELSE        reduce using rule 91 (switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .)
    NEW_LINE        shift and go to state 101

  ! NEW_LINE        [ reduce using rule 91 (switch2 -> RES_CASE expresion COL empty_lines_almost_one bloque .) ]


state 252

    (41) array2 -> cons COMMA array2 .

    RBRACKET        reduce using rule 41 (array2 -> cons COMMA array2 .)


state 253

    (82) forexp -> ID EQUALS cons COL ID comparacion cons . COL ID EQUALS expresion

    COL             shift and go to state 256


state 254

    (81) forexp -> ID EQUALS cons COL ID comparacion ID . COL ID EQUALS expresion
    (111) cons -> ID .
    (118) consarray -> ID . LBRACKET CTE_INT RBRACKET EQUALS cons empty_lines_almost_one
    (119) conslist -> ID . EQUALS LCURLY conslist1 RCURLY empty_lines_almost_one

  ! shift/reduce conflict for COL resolved as shift
    COL             shift and go to state 257
    LBRACKET        shift and go to state 111
    EQUALS          shift and go to state 110

  ! COL             [ reduce using rule 111 (cons -> ID .) ]


state 255

    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL . empty_lines_almost_one bloque
    (124) empty_lines_almost_one -> . NEW_LINE empty_lines

    NEW_LINE        shift and go to state 14

    empty_lines_almost_one         shift and go to state 258

state 256

    (82) forexp -> ID EQUALS cons COL ID comparacion cons COL . ID EQUALS expresion

    ID              shift and go to state 259


state 257

    (81) forexp -> ID EQUALS cons COL ID comparacion ID COL . ID EQUALS expresion

    ID              shift and go to state 260


state 258

    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one . bloque
    (43) bloque -> . bloque NEW_LINE
    (44) bloque -> . estatutos
    (45) bloque -> . empty
    (46) estatutos -> . condicion
    (47) estatutos -> . ciclo
    (48) estatutos -> . lectura
    (49) estatutos -> . escritura
    (50) estatutos -> . asignacion
    (51) estatutos -> . llamada
    (52) estatutos -> . vars
    (125) empty -> .
    (55) condicion -> . if
    (56) condicion -> . ifelse
    (57) condicion -> . switch
    (53) ciclo -> . while
    (54) ciclo -> . for
    (61) lectura -> . RES_READ LPAREN tipo RPAREN empty_lines_almost_one
    (62) escritura -> . RES_PRINT LPAREN escritura1 RPAREN empty_lines_almost_one
    (67) asignacion -> . VAR EQUALS asignacion1 empty_lines_almost_one
    (58) llamada -> . VAR LPAREN llamada1 RPAREN empty_lines_almost_one
    (21) vars -> . RES_DEF vars1 empty_lines_almost_one
    (88) if -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (89) ifelse -> . RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque
    (90) switch -> . RES_SWITCH COL empty_lines_almost_one switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL empty_lines_almost_one bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL empty_lines_almost_one bloque

    NEW_LINE        reduce using rule 125 (empty -> .)
    RES_START       reduce using rule 125 (empty -> .)
    RES_FUNC        reduce using rule 125 (empty -> .)
    $end            reduce using rule 125 (empty -> .)
    RES_END         reduce using rule 125 (empty -> .)
    RES_ELSE        reduce using rule 125 (empty -> .)
    RES_READ        shift and go to state 76
    RES_PRINT       shift and go to state 79
    VAR             shift and go to state 75
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 63
    RES_SWITCH      shift and go to state 78
    RES_WHILE       shift and go to state 74
    RES_FOR         shift and go to state 61

    vars                           shift and go to state 60
    bloque                         shift and go to state 261
    if                             shift and go to state 64
    ciclo                          shift and go to state 65
    switch                         shift and go to state 66
    llamada                        shift and go to state 68
    condicion                      shift and go to state 69
    ifelse                         shift and go to state 70
    lectura                        shift and go to state 71
    empty                          shift and go to state 72
    estatutos                      shift and go to state 73
    for                            shift and go to state 67
    asignacion                     shift and go to state 77
    while                          shift and go to state 80
    escritura                      shift and go to state 81

state 259

    (82) forexp -> ID EQUALS cons COL ID comparacion cons COL ID . EQUALS expresion

    EQUALS          shift and go to state 262


state 260

    (81) forexp -> ID EQUALS cons COL ID comparacion ID COL ID . EQUALS expresion

    EQUALS          shift and go to state 263


state 261

    (89) ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .
    (43) bloque -> bloque . NEW_LINE

  ! shift/reduce conflict for NEW_LINE resolved as shift
    RES_START       reduce using rule 89 (ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .)
    RES_FUNC        reduce using rule 89 (ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .)
    $end            reduce using rule 89 (ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .)
    RES_END         reduce using rule 89 (ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .)
    RES_ELSE        reduce using rule 89 (ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .)
    NEW_LINE        shift and go to state 101

  ! NEW_LINE        [ reduce using rule 89 (ifelse -> RES_IF LPAREN expresion RPAREN COL empty_lines_almost_one bloque RES_ELSE COL empty_lines_almost_one bloque .) ]


state 262

    (82) forexp -> ID EQUALS cons COL ID comparacion cons COL ID EQUALS . expresion
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 264
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126

state 263

    (81) forexp -> ID EQUALS cons COL ID comparacion ID COL ID EQUALS . expresion
    (94) expresion -> . exp
    (95) expresion -> . exp MIN exp
    (96) expresion -> . exp MIN_EQ exp
    (97) expresion -> . exp MAY exp
    (98) expresion -> . exp MAY_EQ exp
    (99) expresion -> . exp DIF exp
    (100) exp -> . termino exp1
    (101) exp -> . termino
    (104) termino -> . factor termino1
    (105) termino -> . factor
    (108) factor -> . LPAREN expresion RPAREN
    (109) factor -> . PLUS cons
    (110) factor -> . MINUS cons

    LPAREN          shift and go to state 125
    PLUS            shift and go to state 123
    MINUS           shift and go to state 128

    expresion                      shift and go to state 265
    termino                        shift and go to state 124
    exp                            shift and go to state 127
    factor                         shift and go to state 126

state 264

    (82) forexp -> ID EQUALS cons COL ID comparacion cons COL ID EQUALS expresion .

    RPAREN          reduce using rule 82 (forexp -> ID EQUALS cons COL ID comparacion cons COL ID EQUALS expresion .)


state 265

    (81) forexp -> ID EQUALS cons COL ID comparacion ID COL ID EQUALS expresion .

    RPAREN          reduce using rule 81 (forexp -> ID EQUALS cons COL ID comparacion ID COL ID EQUALS expresion .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEW_LINE in state 33 resolved as shift
WARNING: shift/reduce conflict for NEW_LINE in state 180 resolved as shift
WARNING: shift/reduce conflict for NEW_LINE in state 237 resolved as shift
WARNING: shift/reduce conflict for RES_ELSE in state 238 resolved as shift
WARNING: shift/reduce conflict for NEW_LINE in state 238 resolved as shift
WARNING: shift/reduce conflict for NEW_LINE in state 239 resolved as shift
WARNING: shift/reduce conflict for NEW_LINE in state 251 resolved as shift
WARNING: shift/reduce conflict for COL in state 254 resolved as shift
WARNING: shift/reduce conflict for NEW_LINE in state 261 resolved as shift
