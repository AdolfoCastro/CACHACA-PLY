Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    RES_TRUE
    EQ_EQ
    RES_SET
    TAB
    RES_ELIF
    NEW_LINE
    CTE_DOUBLE
    VAR
    AND
    RES_DOUBLE
    RES_FALSE
    OR

Grammar

Rule 0     S' -> programa
Rule 1     programa -> programa1 programa2 programa3 main programa3
Rule 2     programa -> empty
Rule 3     programa1 -> RES_PROTO prototipos seen_prototipo programa1_1
Rule 4     seen_prototipo -> <empty>
Rule 5     programa1_1 -> programa1
Rule 6     programa1_1 -> empty
Rule 7     programa2 -> programa2 vars
Rule 8     programa2 -> empty
Rule 9     programa3 -> programa3 modulos
Rule 10    programa3 -> empty
Rule 11    prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN
Rule 12    seen_dato -> <empty>
Rule 13    prototipos_1 -> tipo ID prototipos_2
Rule 14    prototipos_2 -> COMMA prototipos_1
Rule 15    prototipos_2 -> empty
Rule 16    dato -> RES_INT
Rule 17    dato -> RES_FLOAT
Rule 18    dato -> RES_BOOLEAN
Rule 19    dato -> RES_STRING
Rule 20    tipo -> dato
Rule 21    tipo -> estructura
Rule 22    estructura -> list
Rule 23    estructura -> array
Rule 24    vars -> RES_DEF vars1
Rule 25    vars1 -> estructura
Rule 26    vars1 -> estructura vars1
Rule 27    vars1 -> dato ID vars2 vars1_1
Rule 28    vars1_1 -> vars1
Rule 29    vars1_1 -> empty
Rule 30    vars2 -> EQUALS cons
Rule 31    vars2 -> vars3
Rule 32    vars3 -> COMMA ID vars3
Rule 33    vars3 -> empty
Rule 34    list -> RES_LIST dato ID list1
Rule 35    list1 -> LCURLY cons_loop RCURLY
Rule 36    list1 -> empty
Rule 37    cons_loop -> cons cons_loop_1
Rule 38    cons_loop_1 -> COMMA cons_loop
Rule 39    cons_loop_1 -> empty
Rule 40    array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1
Rule 41    array1 -> COL LBRACKET array2 RBRACKET
Rule 42    array1 -> empty
Rule 43    array2 -> cons
Rule 44    array2 -> cons COMMA array2
Rule 45    modulos -> prototipos COL bloque
Rule 46    bloque -> estatutos bloque
Rule 47    bloque -> empty
Rule 48    estatutos -> condicion E_END
Rule 49    estatutos -> ciclo E_END
Rule 50    estatutos -> lectura
Rule 51    estatutos -> escritura
Rule 52    estatutos -> asignacion
Rule 53    estatutos -> llamada
Rule 54    estatutos -> vars
Rule 55    ciclo -> while
Rule 56    ciclo -> for
Rule 57    condicion -> if
Rule 58    condicion -> switch
Rule 59    llamada -> ID LPAREN llamada1 RPAREN
Rule 60    llamada1 -> expresion
Rule 61    llamada1 -> empty
Rule 62    lectura -> RES_READ LPAREN tipo RPAREN
Rule 63    escritura -> RES_PRINT LPAREN escritura1 RPAREN
Rule 64    escritura1 -> expresion
Rule 65    escritura1 -> CTE_STRING
Rule 66    asignacion -> ID EQUALS asignacion1
Rule 67    asignacion1 -> expresion
Rule 68    asignacion1 -> asignlist
Rule 69    asignacion1 -> asignarray
Rule 70    asignlist -> LCURLY asignlist1 RCURLY
Rule 71    asignlist1 -> cons
Rule 72    asignlist1 -> cons COMMA asignlist1
Rule 73    asignarray -> LBRACKET asignarray1 RBRACKET
Rule 74    asignarray1 -> cons
Rule 75    asignarray1 -> cons COMMA asignarray1
Rule 76    while -> RES_WHILE LPAREN expresion RPAREN COL bloque
Rule 77    for -> RES_FOR LPAREN forexp RPAREN COL bloque
Rule 78    forexp -> ID EQUALS cons COL expresion COL ID EQUALS expresion
Rule 79    if -> RES_IF LPAREN expresion RPAREN COL bloque ifelse
Rule 80    ifelse -> RES_ELSE COL bloque
Rule 81    ifelse -> empty
Rule 82    switch -> RES_SWITCH COL switch2
Rule 83    switch2 -> RES_CASE expresion COL bloque switch2
Rule 84    switch2 -> empty
Rule 85    expresion -> exp expresion_1
Rule 86    expresion_1 -> MIN exp
Rule 87    expresion_1 -> MIN_EQ exp
Rule 88    expresion_1 -> MAY exp
Rule 89    expresion_1 -> MAY_EQ exp
Rule 90    expresion_1 -> DIF exp
Rule 91    expresion_1 -> empty
Rule 92    exp -> termino exp1
Rule 93    exp1 -> PLUS exp
Rule 94    exp1 -> MINUS exp
Rule 95    exp1 -> empty
Rule 96    termino -> factor termino1
Rule 97    termino1 -> TIMES termino
Rule 98    termino1 -> DIVIDE termino
Rule 99    termino1 -> empty
Rule 100   factor -> LPAREN expresion RPAREN
Rule 101   factor -> cons
Rule 102   factor -> PLUS cons
Rule 103   factor -> MINUS cons
Rule 104   cons -> ID
Rule 105   cons -> CTE_INT
Rule 106   cons -> CTE_FLOAT
Rule 107   cons -> consarray
Rule 108   cons -> conslist
Rule 109   main -> RES_START COL bloque RES_END
Rule 110   consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons
Rule 111   conslist -> ID EQUALS LCURLY conslist1 RCURLY
Rule 112   conslist1 -> cons
Rule 113   conslist1 -> cons COMMA conslist1
Rule 114   empty -> <empty>

Terminals, with rules where they appear

AND                  : 
COL                  : 41 45 76 77 78 78 79 80 82 83 109
COMMA                : 14 32 38 44 72 75 113
CTE_DOUBLE           : 
CTE_FLOAT            : 106
CTE_INT              : 40 105 110
CTE_STRING           : 65
DIF                  : 90
DIVIDE               : 98
EQUALS               : 30 66 78 78 110 111
EQ_EQ                : 
E_END                : 48 49
ID                   : 11 13 27 32 34 40 59 66 78 78 104 110 111
LBRACKET             : 40 41 73 110
LCURLY               : 35 70 111
LPAREN               : 11 59 62 63 76 77 79 100
MAY                  : 88
MAY_EQ               : 89
MIN                  : 86
MINUS                : 94 103
MIN_EQ               : 87
NEW_LINE             : 
OR                   : 
PLUS                 : 93 102
RBRACKET             : 40 41 73 110
RCURLY               : 35 70 111
RES_ARRAY            : 40
RES_BOOLEAN          : 18
RES_CASE             : 83
RES_DEF              : 24
RES_DOUBLE           : 
RES_ELIF             : 
RES_ELSE             : 80
RES_END              : 109
RES_FALSE            : 
RES_FLOAT            : 17
RES_FOR              : 77
RES_FUNC             : 11
RES_IF               : 79
RES_INT              : 16
RES_LIST             : 34
RES_PRINT            : 63
RES_PROTO            : 3
RES_READ             : 62
RES_SET              : 
RES_START            : 109
RES_STRING           : 19
RES_SWITCH           : 82
RES_TRUE             : 
RES_WHILE            : 76
RPAREN               : 11 59 62 63 76 77 79 100
TAB                  : 
TIMES                : 97
VAR                  : 
error                : 

Nonterminals, with rules where they appear

array                : 23
array1               : 40
array2               : 41 44
asignacion           : 52
asignacion1          : 66
asignarray           : 69
asignarray1          : 73 75
asignlist            : 68
asignlist1           : 70 72
bloque               : 45 46 76 77 79 80 83 109
ciclo                : 49
condicion            : 48
cons                 : 30 37 43 44 71 72 74 75 78 101 102 103 110 112 113
cons_loop            : 35 38
cons_loop_1          : 37
consarray            : 107
conslist             : 108
conslist1            : 111 113
dato                 : 11 20 27 34 40
empty                : 2 6 8 10 15 29 33 36 39 42 47 61 81 84 91 95 99
escritura            : 51
escritura1           : 63
estatutos            : 46
estructura           : 21 25 26
exp                  : 85 86 87 88 89 90 93 94
exp1                 : 92
expresion            : 60 64 67 76 78 78 79 83 100
expresion_1          : 85
factor               : 96
for                  : 56
forexp               : 77
if                   : 57
ifelse               : 79
lectura              : 50
list                 : 22
list1                : 34
llamada              : 53
llamada1             : 59
main                 : 1
modulos              : 9
programa             : 0
programa1            : 1 5
programa1_1          : 3
programa2            : 1 7
programa3            : 1 1 9
prototipos           : 3 45
prototipos_1         : 11 14
prototipos_2         : 13
seen_dato            : 11
seen_prototipo       : 3
switch               : 58
switch2              : 82 83
termino              : 92 97 98
termino1             : 96
tipo                 : 13 62
vars                 : 7 54
vars1                : 24 26 28
vars1_1              : 27
vars2                : 27
vars3                : 31 32
while                : 55

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . programa1 programa2 programa3 main programa3
    (2) programa -> . empty
    (3) programa1 -> . RES_PROTO prototipos seen_prototipo programa1_1
    (114) empty -> .

    RES_PROTO       shift and go to state 3
    $end            reduce using rule 114 (empty -> .)

    programa1                      shift and go to state 1
    programa                       shift and go to state 2
    empty                          shift and go to state 4

state 1

    (1) programa -> programa1 . programa2 programa3 main programa3
    (7) programa2 -> . programa2 vars
    (8) programa2 -> . empty
    (114) empty -> .

    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)

    programa2                      shift and go to state 5
    empty                          shift and go to state 6

state 2

    (0) S' -> programa .



state 3

    (3) programa1 -> RES_PROTO . prototipos seen_prototipo programa1_1
    (11) prototipos -> . RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN

    RES_FUNC        shift and go to state 8

    prototipos                     shift and go to state 7

state 4

    (2) programa -> empty .

    $end            reduce using rule 2 (programa -> empty .)


state 5

    (1) programa -> programa1 programa2 . programa3 main programa3
    (7) programa2 -> programa2 . vars
    (9) programa3 -> . programa3 modulos
    (10) programa3 -> . empty
    (24) vars -> . RES_DEF vars1
    (114) empty -> .

    RES_DEF         shift and go to state 11
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)

    vars                           shift and go to state 9
    programa3                      shift and go to state 10
    empty                          shift and go to state 12

state 6

    (8) programa2 -> empty .

    RES_DEF         reduce using rule 8 (programa2 -> empty .)
    RES_START       reduce using rule 8 (programa2 -> empty .)
    RES_FUNC        reduce using rule 8 (programa2 -> empty .)


state 7

    (3) programa1 -> RES_PROTO prototipos . seen_prototipo programa1_1
    (4) seen_prototipo -> .

    RES_PROTO       reduce using rule 4 (seen_prototipo -> .)
    RES_DEF         reduce using rule 4 (seen_prototipo -> .)
    RES_START       reduce using rule 4 (seen_prototipo -> .)
    RES_FUNC        reduce using rule 4 (seen_prototipo -> .)

    seen_prototipo                 shift and go to state 13

state 8

    (11) prototipos -> RES_FUNC . dato seen_dato ID LPAREN prototipos_1 RPAREN
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15

    dato                           shift and go to state 17

state 9

    (7) programa2 -> programa2 vars .

    RES_DEF         reduce using rule 7 (programa2 -> programa2 vars .)
    RES_START       reduce using rule 7 (programa2 -> programa2 vars .)
    RES_FUNC        reduce using rule 7 (programa2 -> programa2 vars .)


state 10

    (1) programa -> programa1 programa2 programa3 . main programa3
    (9) programa3 -> programa3 . modulos
    (109) main -> . RES_START COL bloque RES_END
    (45) modulos -> . prototipos COL bloque
    (11) prototipos -> . RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN

    RES_START       shift and go to state 20
    RES_FUNC        shift and go to state 8

    prototipos                     shift and go to state 19
    modulos                        shift and go to state 21
    main                           shift and go to state 22

state 11

    (24) vars -> RES_DEF . vars1
    (25) vars1 -> . estructura
    (26) vars1 -> . estructura vars1
    (27) vars1 -> . dato ID vars2 vars1_1
    (22) estructura -> . list
    (23) estructura -> . array
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING
    (34) list -> . RES_LIST dato ID list1
    (40) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15
    RES_LIST        shift and go to state 23
    RES_ARRAY       shift and go to state 29

    estructura                     shift and go to state 24
    list                           shift and go to state 25
    vars1                          shift and go to state 26
    dato                           shift and go to state 27
    array                          shift and go to state 28

state 12

    (10) programa3 -> empty .

    RES_FUNC        reduce using rule 10 (programa3 -> empty .)
    $end            reduce using rule 10 (programa3 -> empty .)
    RES_START       reduce using rule 10 (programa3 -> empty .)


state 13

    (3) programa1 -> RES_PROTO prototipos seen_prototipo . programa1_1
    (5) programa1_1 -> . programa1
    (6) programa1_1 -> . empty
    (3) programa1 -> . RES_PROTO prototipos seen_prototipo programa1_1
    (114) empty -> .

    RES_PROTO       shift and go to state 3
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)

    empty                          shift and go to state 32
    programa1_1                    shift and go to state 31
    programa1                      shift and go to state 30

state 14

    (16) dato -> RES_INT .

    ID              reduce using rule 16 (dato -> RES_INT .)
    RPAREN          reduce using rule 16 (dato -> RES_INT .)


state 15

    (19) dato -> RES_STRING .

    ID              reduce using rule 19 (dato -> RES_STRING .)
    RPAREN          reduce using rule 19 (dato -> RES_STRING .)


state 16

    (18) dato -> RES_BOOLEAN .

    ID              reduce using rule 18 (dato -> RES_BOOLEAN .)
    RPAREN          reduce using rule 18 (dato -> RES_BOOLEAN .)


state 17

    (11) prototipos -> RES_FUNC dato . seen_dato ID LPAREN prototipos_1 RPAREN
    (12) seen_dato -> .

    ID              reduce using rule 12 (seen_dato -> .)

    seen_dato                      shift and go to state 33

state 18

    (17) dato -> RES_FLOAT .

    ID              reduce using rule 17 (dato -> RES_FLOAT .)
    RPAREN          reduce using rule 17 (dato -> RES_FLOAT .)


state 19

    (45) modulos -> prototipos . COL bloque

    COL             shift and go to state 34


state 20

    (109) main -> RES_START . COL bloque RES_END

    COL             shift and go to state 35


state 21

    (9) programa3 -> programa3 modulos .

    RES_FUNC        reduce using rule 9 (programa3 -> programa3 modulos .)
    $end            reduce using rule 9 (programa3 -> programa3 modulos .)
    RES_START       reduce using rule 9 (programa3 -> programa3 modulos .)


state 22

    (1) programa -> programa1 programa2 programa3 main . programa3
    (9) programa3 -> . programa3 modulos
    (10) programa3 -> . empty
    (114) empty -> .

    RES_FUNC        reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)

    programa3                      shift and go to state 36
    empty                          shift and go to state 12

state 23

    (34) list -> RES_LIST . dato ID list1
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15

    dato                           shift and go to state 37

state 24

    (25) vars1 -> estructura .
    (26) vars1 -> estructura . vars1
    (25) vars1 -> . estructura
    (26) vars1 -> . estructura vars1
    (27) vars1 -> . dato ID vars2 vars1_1
    (22) estructura -> . list
    (23) estructura -> . array
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING
    (34) list -> . RES_LIST dato ID list1
    (40) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_DEF         reduce using rule 25 (vars1 -> estructura .)
    RES_START       reduce using rule 25 (vars1 -> estructura .)
    RES_FUNC        reduce using rule 25 (vars1 -> estructura .)
    RES_READ        reduce using rule 25 (vars1 -> estructura .)
    RES_PRINT       reduce using rule 25 (vars1 -> estructura .)
    ID              reduce using rule 25 (vars1 -> estructura .)
    RES_IF          reduce using rule 25 (vars1 -> estructura .)
    RES_SWITCH      reduce using rule 25 (vars1 -> estructura .)
    RES_WHILE       reduce using rule 25 (vars1 -> estructura .)
    RES_FOR         reduce using rule 25 (vars1 -> estructura .)
    $end            reduce using rule 25 (vars1 -> estructura .)
    RES_END         reduce using rule 25 (vars1 -> estructura .)
    E_END           reduce using rule 25 (vars1 -> estructura .)
    RES_ELSE        reduce using rule 25 (vars1 -> estructura .)
    RES_CASE        reduce using rule 25 (vars1 -> estructura .)
    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15
    RES_LIST        shift and go to state 23
    RES_ARRAY       shift and go to state 29

    list                           shift and go to state 25
    estructura                     shift and go to state 24
    dato                           shift and go to state 27
    vars1                          shift and go to state 38
    array                          shift and go to state 28

state 25

    (22) estructura -> list .

    ID              reduce using rule 22 (estructura -> list .)
    RES_INT         reduce using rule 22 (estructura -> list .)
    RES_FLOAT       reduce using rule 22 (estructura -> list .)
    RES_BOOLEAN     reduce using rule 22 (estructura -> list .)
    RES_STRING      reduce using rule 22 (estructura -> list .)
    RES_LIST        reduce using rule 22 (estructura -> list .)
    RES_ARRAY       reduce using rule 22 (estructura -> list .)
    RES_DEF         reduce using rule 22 (estructura -> list .)
    RES_START       reduce using rule 22 (estructura -> list .)
    RES_FUNC        reduce using rule 22 (estructura -> list .)
    RES_READ        reduce using rule 22 (estructura -> list .)
    RES_PRINT       reduce using rule 22 (estructura -> list .)
    RES_IF          reduce using rule 22 (estructura -> list .)
    RES_SWITCH      reduce using rule 22 (estructura -> list .)
    RES_WHILE       reduce using rule 22 (estructura -> list .)
    RES_FOR         reduce using rule 22 (estructura -> list .)
    $end            reduce using rule 22 (estructura -> list .)
    RES_END         reduce using rule 22 (estructura -> list .)
    E_END           reduce using rule 22 (estructura -> list .)
    RES_ELSE        reduce using rule 22 (estructura -> list .)
    RES_CASE        reduce using rule 22 (estructura -> list .)
    RPAREN          reduce using rule 22 (estructura -> list .)


state 26

    (24) vars -> RES_DEF vars1 .

    RES_READ        reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_PRINT       reduce using rule 24 (vars -> RES_DEF vars1 .)
    ID              reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_DEF         reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_IF          reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_SWITCH      reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_WHILE       reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_FOR         reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_START       reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_FUNC        reduce using rule 24 (vars -> RES_DEF vars1 .)
    $end            reduce using rule 24 (vars -> RES_DEF vars1 .)
    E_END           reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_CASE        reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_END         reduce using rule 24 (vars -> RES_DEF vars1 .)
    RES_ELSE        reduce using rule 24 (vars -> RES_DEF vars1 .)


state 27

    (27) vars1 -> dato . ID vars2 vars1_1

    ID              shift and go to state 39


state 28

    (23) estructura -> array .

    ID              reduce using rule 23 (estructura -> array .)
    RES_INT         reduce using rule 23 (estructura -> array .)
    RES_FLOAT       reduce using rule 23 (estructura -> array .)
    RES_BOOLEAN     reduce using rule 23 (estructura -> array .)
    RES_STRING      reduce using rule 23 (estructura -> array .)
    RES_LIST        reduce using rule 23 (estructura -> array .)
    RES_ARRAY       reduce using rule 23 (estructura -> array .)
    RES_DEF         reduce using rule 23 (estructura -> array .)
    RES_START       reduce using rule 23 (estructura -> array .)
    RES_FUNC        reduce using rule 23 (estructura -> array .)
    RES_READ        reduce using rule 23 (estructura -> array .)
    RES_PRINT       reduce using rule 23 (estructura -> array .)
    RES_IF          reduce using rule 23 (estructura -> array .)
    RES_SWITCH      reduce using rule 23 (estructura -> array .)
    RES_WHILE       reduce using rule 23 (estructura -> array .)
    RES_FOR         reduce using rule 23 (estructura -> array .)
    $end            reduce using rule 23 (estructura -> array .)
    RES_END         reduce using rule 23 (estructura -> array .)
    E_END           reduce using rule 23 (estructura -> array .)
    RES_ELSE        reduce using rule 23 (estructura -> array .)
    RES_CASE        reduce using rule 23 (estructura -> array .)
    RPAREN          reduce using rule 23 (estructura -> array .)


state 29

    (40) array -> RES_ARRAY . dato ID LBRACKET CTE_INT RBRACKET array1
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15

    dato                           shift and go to state 40

state 30

    (5) programa1_1 -> programa1 .

    RES_DEF         reduce using rule 5 (programa1_1 -> programa1 .)
    RES_START       reduce using rule 5 (programa1_1 -> programa1 .)
    RES_FUNC        reduce using rule 5 (programa1_1 -> programa1 .)


state 31

    (3) programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .

    RES_DEF         reduce using rule 3 (programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .)
    RES_START       reduce using rule 3 (programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .)
    RES_FUNC        reduce using rule 3 (programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .)


state 32

    (6) programa1_1 -> empty .

    RES_DEF         reduce using rule 6 (programa1_1 -> empty .)
    RES_START       reduce using rule 6 (programa1_1 -> empty .)
    RES_FUNC        reduce using rule 6 (programa1_1 -> empty .)


state 33

    (11) prototipos -> RES_FUNC dato seen_dato . ID LPAREN prototipos_1 RPAREN

    ID              shift and go to state 41


state 34

    (45) modulos -> prototipos COL . bloque
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 44
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 35

    (109) main -> RES_START COL . bloque RES_END
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_END         reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 63
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 36

    (1) programa -> programa1 programa2 programa3 main programa3 .
    (9) programa3 -> programa3 . modulos
    (45) modulos -> . prototipos COL bloque
    (11) prototipos -> . RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN

    $end            reduce using rule 1 (programa -> programa1 programa2 programa3 main programa3 .)
    RES_FUNC        shift and go to state 8

    prototipos                     shift and go to state 19
    modulos                        shift and go to state 21

state 37

    (34) list -> RES_LIST dato . ID list1

    ID              shift and go to state 64


state 38

    (26) vars1 -> estructura vars1 .

    RES_DEF         reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_START       reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_FUNC        reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_READ        reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_PRINT       reduce using rule 26 (vars1 -> estructura vars1 .)
    ID              reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_IF          reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_SWITCH      reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_WHILE       reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_FOR         reduce using rule 26 (vars1 -> estructura vars1 .)
    $end            reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_END         reduce using rule 26 (vars1 -> estructura vars1 .)
    E_END           reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_ELSE        reduce using rule 26 (vars1 -> estructura vars1 .)
    RES_CASE        reduce using rule 26 (vars1 -> estructura vars1 .)


state 39

    (27) vars1 -> dato ID . vars2 vars1_1
    (30) vars2 -> . EQUALS cons
    (31) vars2 -> . vars3
    (32) vars3 -> . COMMA ID vars3
    (33) vars3 -> . empty
    (114) empty -> .

    EQUALS          shift and go to state 65
    COMMA           shift and go to state 68
    RES_INT         reduce using rule 114 (empty -> .)
    RES_FLOAT       reduce using rule 114 (empty -> .)
    RES_BOOLEAN     reduce using rule 114 (empty -> .)
    RES_STRING      reduce using rule 114 (empty -> .)
    RES_LIST        reduce using rule 114 (empty -> .)
    RES_ARRAY       reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)

    vars3                          shift and go to state 66
    vars2                          shift and go to state 67
    empty                          shift and go to state 69

state 40

    (40) array -> RES_ARRAY dato . ID LBRACKET CTE_INT RBRACKET array1

    ID              shift and go to state 70


state 41

    (11) prototipos -> RES_FUNC dato seen_dato ID . LPAREN prototipos_1 RPAREN

    LPAREN          shift and go to state 71


state 42

    (54) estatutos -> vars .

    RES_READ        reduce using rule 54 (estatutos -> vars .)
    RES_PRINT       reduce using rule 54 (estatutos -> vars .)
    ID              reduce using rule 54 (estatutos -> vars .)
    RES_DEF         reduce using rule 54 (estatutos -> vars .)
    RES_IF          reduce using rule 54 (estatutos -> vars .)
    RES_SWITCH      reduce using rule 54 (estatutos -> vars .)
    RES_WHILE       reduce using rule 54 (estatutos -> vars .)
    RES_FOR         reduce using rule 54 (estatutos -> vars .)
    RES_CASE        reduce using rule 54 (estatutos -> vars .)
    E_END           reduce using rule 54 (estatutos -> vars .)
    RES_ELSE        reduce using rule 54 (estatutos -> vars .)
    RES_START       reduce using rule 54 (estatutos -> vars .)
    RES_FUNC        reduce using rule 54 (estatutos -> vars .)
    $end            reduce using rule 54 (estatutos -> vars .)
    RES_END         reduce using rule 54 (estatutos -> vars .)


state 43

    (77) for -> RES_FOR . LPAREN forexp RPAREN COL bloque

    LPAREN          shift and go to state 72


state 44

    (45) modulos -> prototipos COL bloque .

    RES_FUNC        reduce using rule 45 (modulos -> prototipos COL bloque .)
    $end            reduce using rule 45 (modulos -> prototipos COL bloque .)
    RES_START       reduce using rule 45 (modulos -> prototipos COL bloque .)


state 45

    (79) if -> RES_IF . LPAREN expresion RPAREN COL bloque ifelse

    LPAREN          shift and go to state 73


state 46

    (63) escritura -> RES_PRINT . LPAREN escritura1 RPAREN

    LPAREN          shift and go to state 74


state 47

    (49) estatutos -> ciclo . E_END

    E_END           shift and go to state 75


state 48

    (58) condicion -> switch .

    E_END           reduce using rule 58 (condicion -> switch .)


state 49

    (56) ciclo -> for .

    E_END           reduce using rule 56 (ciclo -> for .)


state 50

    (53) estatutos -> llamada .

    RES_READ        reduce using rule 53 (estatutos -> llamada .)
    RES_PRINT       reduce using rule 53 (estatutos -> llamada .)
    ID              reduce using rule 53 (estatutos -> llamada .)
    RES_DEF         reduce using rule 53 (estatutos -> llamada .)
    RES_IF          reduce using rule 53 (estatutos -> llamada .)
    RES_SWITCH      reduce using rule 53 (estatutos -> llamada .)
    RES_WHILE       reduce using rule 53 (estatutos -> llamada .)
    RES_FOR         reduce using rule 53 (estatutos -> llamada .)
    RES_CASE        reduce using rule 53 (estatutos -> llamada .)
    E_END           reduce using rule 53 (estatutos -> llamada .)
    RES_ELSE        reduce using rule 53 (estatutos -> llamada .)
    RES_START       reduce using rule 53 (estatutos -> llamada .)
    RES_FUNC        reduce using rule 53 (estatutos -> llamada .)
    $end            reduce using rule 53 (estatutos -> llamada .)
    RES_END         reduce using rule 53 (estatutos -> llamada .)


state 51

    (48) estatutos -> condicion . E_END

    E_END           shift and go to state 76


state 52

    (57) condicion -> if .

    E_END           reduce using rule 57 (condicion -> if .)


state 53

    (50) estatutos -> lectura .

    RES_READ        reduce using rule 50 (estatutos -> lectura .)
    RES_PRINT       reduce using rule 50 (estatutos -> lectura .)
    ID              reduce using rule 50 (estatutos -> lectura .)
    RES_DEF         reduce using rule 50 (estatutos -> lectura .)
    RES_IF          reduce using rule 50 (estatutos -> lectura .)
    RES_SWITCH      reduce using rule 50 (estatutos -> lectura .)
    RES_WHILE       reduce using rule 50 (estatutos -> lectura .)
    RES_FOR         reduce using rule 50 (estatutos -> lectura .)
    RES_CASE        reduce using rule 50 (estatutos -> lectura .)
    E_END           reduce using rule 50 (estatutos -> lectura .)
    RES_ELSE        reduce using rule 50 (estatutos -> lectura .)
    RES_START       reduce using rule 50 (estatutos -> lectura .)
    RES_FUNC        reduce using rule 50 (estatutos -> lectura .)
    $end            reduce using rule 50 (estatutos -> lectura .)
    RES_END         reduce using rule 50 (estatutos -> lectura .)


state 54

    (47) bloque -> empty .

    RES_END         reduce using rule 47 (bloque -> empty .)
    E_END           reduce using rule 47 (bloque -> empty .)
    RES_START       reduce using rule 47 (bloque -> empty .)
    RES_FUNC        reduce using rule 47 (bloque -> empty .)
    $end            reduce using rule 47 (bloque -> empty .)
    RES_ELSE        reduce using rule 47 (bloque -> empty .)
    RES_CASE        reduce using rule 47 (bloque -> empty .)


state 55

    (46) bloque -> estatutos . bloque
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 77
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 56

    (76) while -> RES_WHILE . LPAREN expresion RPAREN COL bloque

    LPAREN          shift and go to state 78


state 57

    (66) asignacion -> ID . EQUALS asignacion1
    (59) llamada -> ID . LPAREN llamada1 RPAREN

    EQUALS          shift and go to state 79
    LPAREN          shift and go to state 80


state 58

    (62) lectura -> RES_READ . LPAREN tipo RPAREN

    LPAREN          shift and go to state 81


state 59

    (52) estatutos -> asignacion .

    RES_READ        reduce using rule 52 (estatutos -> asignacion .)
    RES_PRINT       reduce using rule 52 (estatutos -> asignacion .)
    ID              reduce using rule 52 (estatutos -> asignacion .)
    RES_DEF         reduce using rule 52 (estatutos -> asignacion .)
    RES_IF          reduce using rule 52 (estatutos -> asignacion .)
    RES_SWITCH      reduce using rule 52 (estatutos -> asignacion .)
    RES_WHILE       reduce using rule 52 (estatutos -> asignacion .)
    RES_FOR         reduce using rule 52 (estatutos -> asignacion .)
    RES_CASE        reduce using rule 52 (estatutos -> asignacion .)
    E_END           reduce using rule 52 (estatutos -> asignacion .)
    RES_ELSE        reduce using rule 52 (estatutos -> asignacion .)
    RES_START       reduce using rule 52 (estatutos -> asignacion .)
    RES_FUNC        reduce using rule 52 (estatutos -> asignacion .)
    $end            reduce using rule 52 (estatutos -> asignacion .)
    RES_END         reduce using rule 52 (estatutos -> asignacion .)


state 60

    (82) switch -> RES_SWITCH . COL switch2

    COL             shift and go to state 82


state 61

    (55) ciclo -> while .

    E_END           reduce using rule 55 (ciclo -> while .)


state 62

    (51) estatutos -> escritura .

    RES_READ        reduce using rule 51 (estatutos -> escritura .)
    RES_PRINT       reduce using rule 51 (estatutos -> escritura .)
    ID              reduce using rule 51 (estatutos -> escritura .)
    RES_DEF         reduce using rule 51 (estatutos -> escritura .)
    RES_IF          reduce using rule 51 (estatutos -> escritura .)
    RES_SWITCH      reduce using rule 51 (estatutos -> escritura .)
    RES_WHILE       reduce using rule 51 (estatutos -> escritura .)
    RES_FOR         reduce using rule 51 (estatutos -> escritura .)
    RES_CASE        reduce using rule 51 (estatutos -> escritura .)
    E_END           reduce using rule 51 (estatutos -> escritura .)
    RES_ELSE        reduce using rule 51 (estatutos -> escritura .)
    RES_START       reduce using rule 51 (estatutos -> escritura .)
    RES_FUNC        reduce using rule 51 (estatutos -> escritura .)
    $end            reduce using rule 51 (estatutos -> escritura .)
    RES_END         reduce using rule 51 (estatutos -> escritura .)


state 63

    (109) main -> RES_START COL bloque . RES_END

    RES_END         shift and go to state 83


state 64

    (34) list -> RES_LIST dato ID . list1
    (35) list1 -> . LCURLY cons_loop RCURLY
    (36) list1 -> . empty
    (114) empty -> .

    LCURLY          shift and go to state 85
    RES_INT         reduce using rule 114 (empty -> .)
    RES_FLOAT       reduce using rule 114 (empty -> .)
    RES_BOOLEAN     reduce using rule 114 (empty -> .)
    RES_STRING      reduce using rule 114 (empty -> .)
    RES_LIST        reduce using rule 114 (empty -> .)
    RES_ARRAY       reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    RPAREN          reduce using rule 114 (empty -> .)

    list1                          shift and go to state 84
    empty                          shift and go to state 86

state 65

    (30) vars2 -> EQUALS . cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 87
    consarray                      shift and go to state 88

state 66

    (31) vars2 -> vars3 .

    RES_INT         reduce using rule 31 (vars2 -> vars3 .)
    RES_FLOAT       reduce using rule 31 (vars2 -> vars3 .)
    RES_BOOLEAN     reduce using rule 31 (vars2 -> vars3 .)
    RES_STRING      reduce using rule 31 (vars2 -> vars3 .)
    RES_LIST        reduce using rule 31 (vars2 -> vars3 .)
    RES_ARRAY       reduce using rule 31 (vars2 -> vars3 .)
    RES_DEF         reduce using rule 31 (vars2 -> vars3 .)
    RES_START       reduce using rule 31 (vars2 -> vars3 .)
    RES_FUNC        reduce using rule 31 (vars2 -> vars3 .)
    RES_READ        reduce using rule 31 (vars2 -> vars3 .)
    RES_PRINT       reduce using rule 31 (vars2 -> vars3 .)
    ID              reduce using rule 31 (vars2 -> vars3 .)
    RES_IF          reduce using rule 31 (vars2 -> vars3 .)
    RES_SWITCH      reduce using rule 31 (vars2 -> vars3 .)
    RES_WHILE       reduce using rule 31 (vars2 -> vars3 .)
    RES_FOR         reduce using rule 31 (vars2 -> vars3 .)
    $end            reduce using rule 31 (vars2 -> vars3 .)
    RES_END         reduce using rule 31 (vars2 -> vars3 .)
    E_END           reduce using rule 31 (vars2 -> vars3 .)
    RES_ELSE        reduce using rule 31 (vars2 -> vars3 .)
    RES_CASE        reduce using rule 31 (vars2 -> vars3 .)


state 67

    (27) vars1 -> dato ID vars2 . vars1_1
    (28) vars1_1 -> . vars1
    (29) vars1_1 -> . empty
    (25) vars1 -> . estructura
    (26) vars1 -> . estructura vars1
    (27) vars1 -> . dato ID vars2 vars1_1
    (114) empty -> .
    (22) estructura -> . list
    (23) estructura -> . array
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING
    (34) list -> . RES_LIST dato ID list1
    (40) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15
    RES_LIST        shift and go to state 23
    RES_ARRAY       shift and go to state 29

    list                           shift and go to state 25
    estructura                     shift and go to state 24
    dato                           shift and go to state 27
    vars1                          shift and go to state 93
    vars1_1                        shift and go to state 94
    array                          shift and go to state 28
    empty                          shift and go to state 95

state 68

    (32) vars3 -> COMMA . ID vars3

    ID              shift and go to state 96


state 69

    (33) vars3 -> empty .

    RES_INT         reduce using rule 33 (vars3 -> empty .)
    RES_FLOAT       reduce using rule 33 (vars3 -> empty .)
    RES_BOOLEAN     reduce using rule 33 (vars3 -> empty .)
    RES_STRING      reduce using rule 33 (vars3 -> empty .)
    RES_LIST        reduce using rule 33 (vars3 -> empty .)
    RES_ARRAY       reduce using rule 33 (vars3 -> empty .)
    RES_DEF         reduce using rule 33 (vars3 -> empty .)
    RES_START       reduce using rule 33 (vars3 -> empty .)
    RES_FUNC        reduce using rule 33 (vars3 -> empty .)
    RES_READ        reduce using rule 33 (vars3 -> empty .)
    RES_PRINT       reduce using rule 33 (vars3 -> empty .)
    ID              reduce using rule 33 (vars3 -> empty .)
    RES_IF          reduce using rule 33 (vars3 -> empty .)
    RES_SWITCH      reduce using rule 33 (vars3 -> empty .)
    RES_WHILE       reduce using rule 33 (vars3 -> empty .)
    RES_FOR         reduce using rule 33 (vars3 -> empty .)
    $end            reduce using rule 33 (vars3 -> empty .)
    RES_END         reduce using rule 33 (vars3 -> empty .)
    E_END           reduce using rule 33 (vars3 -> empty .)
    RES_ELSE        reduce using rule 33 (vars3 -> empty .)
    RES_CASE        reduce using rule 33 (vars3 -> empty .)


state 70

    (40) array -> RES_ARRAY dato ID . LBRACKET CTE_INT RBRACKET array1

    LBRACKET        shift and go to state 97


state 71

    (11) prototipos -> RES_FUNC dato seen_dato ID LPAREN . prototipos_1 RPAREN
    (13) prototipos_1 -> . tipo ID prototipos_2
    (20) tipo -> . dato
    (21) tipo -> . estructura
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING
    (22) estructura -> . list
    (23) estructura -> . array
    (34) list -> . RES_LIST dato ID list1
    (40) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15
    RES_LIST        shift and go to state 23
    RES_ARRAY       shift and go to state 29

    tipo                           shift and go to state 99
    prototipos_1                   shift and go to state 98
    list                           shift and go to state 25
    estructura                     shift and go to state 100
    dato                           shift and go to state 101
    array                          shift and go to state 28

state 72

    (77) for -> RES_FOR LPAREN . forexp RPAREN COL bloque
    (78) forexp -> . ID EQUALS cons COL expresion COL ID EQUALS expresion

    ID              shift and go to state 102

    forexp                         shift and go to state 103

state 73

    (79) if -> RES_IF LPAREN . expresion RPAREN COL bloque ifelse
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 110
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108

state 74

    (63) escritura -> RES_PRINT LPAREN . escritura1 RPAREN
    (64) escritura1 -> . expresion
    (65) escritura1 -> . CTE_STRING
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    CTE_STRING      shift and go to state 112
    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 114
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108
    escritura1                     shift and go to state 113

state 75

    (49) estatutos -> ciclo E_END .

    RES_READ        reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_PRINT       reduce using rule 49 (estatutos -> ciclo E_END .)
    ID              reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_DEF         reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_IF          reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_SWITCH      reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_WHILE       reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_FOR         reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_CASE        reduce using rule 49 (estatutos -> ciclo E_END .)
    E_END           reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_ELSE        reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_START       reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_FUNC        reduce using rule 49 (estatutos -> ciclo E_END .)
    $end            reduce using rule 49 (estatutos -> ciclo E_END .)
    RES_END         reduce using rule 49 (estatutos -> ciclo E_END .)


state 76

    (48) estatutos -> condicion E_END .

    RES_READ        reduce using rule 48 (estatutos -> condicion E_END .)
    RES_PRINT       reduce using rule 48 (estatutos -> condicion E_END .)
    ID              reduce using rule 48 (estatutos -> condicion E_END .)
    RES_DEF         reduce using rule 48 (estatutos -> condicion E_END .)
    RES_IF          reduce using rule 48 (estatutos -> condicion E_END .)
    RES_SWITCH      reduce using rule 48 (estatutos -> condicion E_END .)
    RES_WHILE       reduce using rule 48 (estatutos -> condicion E_END .)
    RES_FOR         reduce using rule 48 (estatutos -> condicion E_END .)
    RES_CASE        reduce using rule 48 (estatutos -> condicion E_END .)
    E_END           reduce using rule 48 (estatutos -> condicion E_END .)
    RES_ELSE        reduce using rule 48 (estatutos -> condicion E_END .)
    RES_START       reduce using rule 48 (estatutos -> condicion E_END .)
    RES_FUNC        reduce using rule 48 (estatutos -> condicion E_END .)
    $end            reduce using rule 48 (estatutos -> condicion E_END .)
    RES_END         reduce using rule 48 (estatutos -> condicion E_END .)


state 77

    (46) bloque -> estatutos bloque .

    RES_END         reduce using rule 46 (bloque -> estatutos bloque .)
    E_END           reduce using rule 46 (bloque -> estatutos bloque .)
    RES_START       reduce using rule 46 (bloque -> estatutos bloque .)
    RES_FUNC        reduce using rule 46 (bloque -> estatutos bloque .)
    $end            reduce using rule 46 (bloque -> estatutos bloque .)
    RES_ELSE        reduce using rule 46 (bloque -> estatutos bloque .)
    RES_CASE        reduce using rule 46 (bloque -> estatutos bloque .)


state 78

    (76) while -> RES_WHILE LPAREN . expresion RPAREN COL bloque
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 115
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108

state 79

    (66) asignacion -> ID EQUALS . asignacion1
    (67) asignacion1 -> . expresion
    (68) asignacion1 -> . asignlist
    (69) asignacion1 -> . asignarray
    (85) expresion -> . exp expresion_1
    (70) asignlist -> . LCURLY asignlist1 RCURLY
    (73) asignarray -> . LBRACKET asignarray1 RBRACKET
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LCURLY          shift and go to state 117
    LBRACKET        shift and go to state 116
    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 120
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    asignarray                     shift and go to state 118
    factor                         shift and go to state 108
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    asignlist                      shift and go to state 119
    asignacion1                    shift and go to state 121
    consarray                      shift and go to state 88

state 80

    (59) llamada -> ID LPAREN . llamada1 RPAREN
    (60) llamada1 -> . expresion
    (61) llamada1 -> . empty
    (85) expresion -> . exp expresion_1
    (114) empty -> .
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    RPAREN          reduce using rule 114 (empty -> .)
    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 124
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108
    llamada1                       shift and go to state 122
    empty                          shift and go to state 123

state 81

    (62) lectura -> RES_READ LPAREN . tipo RPAREN
    (20) tipo -> . dato
    (21) tipo -> . estructura
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING
    (22) estructura -> . list
    (23) estructura -> . array
    (34) list -> . RES_LIST dato ID list1
    (40) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15
    RES_LIST        shift and go to state 23
    RES_ARRAY       shift and go to state 29

    tipo                           shift and go to state 125
    list                           shift and go to state 25
    estructura                     shift and go to state 100
    dato                           shift and go to state 101
    array                          shift and go to state 28

state 82

    (82) switch -> RES_SWITCH COL . switch2
    (83) switch2 -> . RES_CASE expresion COL bloque switch2
    (84) switch2 -> . empty
    (114) empty -> .

    RES_CASE        shift and go to state 127
    E_END           reduce using rule 114 (empty -> .)

    switch2                        shift and go to state 126
    empty                          shift and go to state 128

state 83

    (109) main -> RES_START COL bloque RES_END .

    RES_FUNC        reduce using rule 109 (main -> RES_START COL bloque RES_END .)
    $end            reduce using rule 109 (main -> RES_START COL bloque RES_END .)


state 84

    (34) list -> RES_LIST dato ID list1 .

    ID              reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_INT         reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_FLOAT       reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_BOOLEAN     reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_STRING      reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_LIST        reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_ARRAY       reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_DEF         reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_START       reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_FUNC        reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_READ        reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_PRINT       reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_IF          reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_SWITCH      reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_WHILE       reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_FOR         reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    $end            reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_END         reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    E_END           reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_ELSE        reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RES_CASE        reduce using rule 34 (list -> RES_LIST dato ID list1 .)
    RPAREN          reduce using rule 34 (list -> RES_LIST dato ID list1 .)


state 85

    (35) list1 -> LCURLY . cons_loop RCURLY
    (37) cons_loop -> . cons cons_loop_1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    consarray                      shift and go to state 88
    cons                           shift and go to state 129
    cons_loop                      shift and go to state 130

state 86

    (36) list1 -> empty .

    RES_INT         reduce using rule 36 (list1 -> empty .)
    RES_FLOAT       reduce using rule 36 (list1 -> empty .)
    RES_BOOLEAN     reduce using rule 36 (list1 -> empty .)
    RES_STRING      reduce using rule 36 (list1 -> empty .)
    RES_LIST        reduce using rule 36 (list1 -> empty .)
    RES_ARRAY       reduce using rule 36 (list1 -> empty .)
    RES_DEF         reduce using rule 36 (list1 -> empty .)
    RES_START       reduce using rule 36 (list1 -> empty .)
    RES_FUNC        reduce using rule 36 (list1 -> empty .)
    RES_READ        reduce using rule 36 (list1 -> empty .)
    RES_PRINT       reduce using rule 36 (list1 -> empty .)
    ID              reduce using rule 36 (list1 -> empty .)
    RES_IF          reduce using rule 36 (list1 -> empty .)
    RES_SWITCH      reduce using rule 36 (list1 -> empty .)
    RES_WHILE       reduce using rule 36 (list1 -> empty .)
    RES_FOR         reduce using rule 36 (list1 -> empty .)
    $end            reduce using rule 36 (list1 -> empty .)
    RES_END         reduce using rule 36 (list1 -> empty .)
    E_END           reduce using rule 36 (list1 -> empty .)
    RES_ELSE        reduce using rule 36 (list1 -> empty .)
    RES_CASE        reduce using rule 36 (list1 -> empty .)
    RPAREN          reduce using rule 36 (list1 -> empty .)


state 87

    (30) vars2 -> EQUALS cons .

    RES_INT         reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_FLOAT       reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_BOOLEAN     reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_STRING      reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_LIST        reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_ARRAY       reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_DEF         reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_START       reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_FUNC        reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_READ        reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_PRINT       reduce using rule 30 (vars2 -> EQUALS cons .)
    ID              reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_IF          reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_SWITCH      reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_WHILE       reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_FOR         reduce using rule 30 (vars2 -> EQUALS cons .)
    $end            reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_END         reduce using rule 30 (vars2 -> EQUALS cons .)
    E_END           reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_ELSE        reduce using rule 30 (vars2 -> EQUALS cons .)
    RES_CASE        reduce using rule 30 (vars2 -> EQUALS cons .)


state 88

    (107) cons -> consarray .

    COMMA           reduce using rule 107 (cons -> consarray .)
    RCURLY          reduce using rule 107 (cons -> consarray .)
    TIMES           reduce using rule 107 (cons -> consarray .)
    DIVIDE          reduce using rule 107 (cons -> consarray .)
    PLUS            reduce using rule 107 (cons -> consarray .)
    MINUS           reduce using rule 107 (cons -> consarray .)
    MIN             reduce using rule 107 (cons -> consarray .)
    MIN_EQ          reduce using rule 107 (cons -> consarray .)
    MAY             reduce using rule 107 (cons -> consarray .)
    MAY_EQ          reduce using rule 107 (cons -> consarray .)
    DIF             reduce using rule 107 (cons -> consarray .)
    RPAREN          reduce using rule 107 (cons -> consarray .)
    RES_READ        reduce using rule 107 (cons -> consarray .)
    RES_PRINT       reduce using rule 107 (cons -> consarray .)
    ID              reduce using rule 107 (cons -> consarray .)
    RES_DEF         reduce using rule 107 (cons -> consarray .)
    RES_IF          reduce using rule 107 (cons -> consarray .)
    RES_SWITCH      reduce using rule 107 (cons -> consarray .)
    RES_WHILE       reduce using rule 107 (cons -> consarray .)
    RES_FOR         reduce using rule 107 (cons -> consarray .)
    RES_START       reduce using rule 107 (cons -> consarray .)
    RES_FUNC        reduce using rule 107 (cons -> consarray .)
    $end            reduce using rule 107 (cons -> consarray .)
    RES_END         reduce using rule 107 (cons -> consarray .)
    E_END           reduce using rule 107 (cons -> consarray .)
    RES_ELSE        reduce using rule 107 (cons -> consarray .)
    RES_CASE        reduce using rule 107 (cons -> consarray .)
    COL             reduce using rule 107 (cons -> consarray .)
    RES_INT         reduce using rule 107 (cons -> consarray .)
    RES_FLOAT       reduce using rule 107 (cons -> consarray .)
    RES_BOOLEAN     reduce using rule 107 (cons -> consarray .)
    RES_STRING      reduce using rule 107 (cons -> consarray .)
    RES_LIST        reduce using rule 107 (cons -> consarray .)
    RES_ARRAY       reduce using rule 107 (cons -> consarray .)
    RBRACKET        reduce using rule 107 (cons -> consarray .)


state 89

    (106) cons -> CTE_FLOAT .

    COMMA           reduce using rule 106 (cons -> CTE_FLOAT .)
    RCURLY          reduce using rule 106 (cons -> CTE_FLOAT .)
    TIMES           reduce using rule 106 (cons -> CTE_FLOAT .)
    DIVIDE          reduce using rule 106 (cons -> CTE_FLOAT .)
    PLUS            reduce using rule 106 (cons -> CTE_FLOAT .)
    MINUS           reduce using rule 106 (cons -> CTE_FLOAT .)
    MIN             reduce using rule 106 (cons -> CTE_FLOAT .)
    MIN_EQ          reduce using rule 106 (cons -> CTE_FLOAT .)
    MAY             reduce using rule 106 (cons -> CTE_FLOAT .)
    MAY_EQ          reduce using rule 106 (cons -> CTE_FLOAT .)
    DIF             reduce using rule 106 (cons -> CTE_FLOAT .)
    RPAREN          reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_READ        reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_PRINT       reduce using rule 106 (cons -> CTE_FLOAT .)
    ID              reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_DEF         reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_IF          reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_SWITCH      reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_WHILE       reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_FOR         reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_START       reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_FUNC        reduce using rule 106 (cons -> CTE_FLOAT .)
    $end            reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_END         reduce using rule 106 (cons -> CTE_FLOAT .)
    E_END           reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_ELSE        reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_CASE        reduce using rule 106 (cons -> CTE_FLOAT .)
    COL             reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_INT         reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_FLOAT       reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_BOOLEAN     reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_STRING      reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_LIST        reduce using rule 106 (cons -> CTE_FLOAT .)
    RES_ARRAY       reduce using rule 106 (cons -> CTE_FLOAT .)
    RBRACKET        reduce using rule 106 (cons -> CTE_FLOAT .)


state 90

    (108) cons -> conslist .

    COMMA           reduce using rule 108 (cons -> conslist .)
    RCURLY          reduce using rule 108 (cons -> conslist .)
    TIMES           reduce using rule 108 (cons -> conslist .)
    DIVIDE          reduce using rule 108 (cons -> conslist .)
    PLUS            reduce using rule 108 (cons -> conslist .)
    MINUS           reduce using rule 108 (cons -> conslist .)
    MIN             reduce using rule 108 (cons -> conslist .)
    MIN_EQ          reduce using rule 108 (cons -> conslist .)
    MAY             reduce using rule 108 (cons -> conslist .)
    MAY_EQ          reduce using rule 108 (cons -> conslist .)
    DIF             reduce using rule 108 (cons -> conslist .)
    RPAREN          reduce using rule 108 (cons -> conslist .)
    RES_READ        reduce using rule 108 (cons -> conslist .)
    RES_PRINT       reduce using rule 108 (cons -> conslist .)
    ID              reduce using rule 108 (cons -> conslist .)
    RES_DEF         reduce using rule 108 (cons -> conslist .)
    RES_IF          reduce using rule 108 (cons -> conslist .)
    RES_SWITCH      reduce using rule 108 (cons -> conslist .)
    RES_WHILE       reduce using rule 108 (cons -> conslist .)
    RES_FOR         reduce using rule 108 (cons -> conslist .)
    RES_START       reduce using rule 108 (cons -> conslist .)
    RES_FUNC        reduce using rule 108 (cons -> conslist .)
    $end            reduce using rule 108 (cons -> conslist .)
    RES_END         reduce using rule 108 (cons -> conslist .)
    E_END           reduce using rule 108 (cons -> conslist .)
    RES_ELSE        reduce using rule 108 (cons -> conslist .)
    RES_CASE        reduce using rule 108 (cons -> conslist .)
    COL             reduce using rule 108 (cons -> conslist .)
    RES_INT         reduce using rule 108 (cons -> conslist .)
    RES_FLOAT       reduce using rule 108 (cons -> conslist .)
    RES_BOOLEAN     reduce using rule 108 (cons -> conslist .)
    RES_STRING      reduce using rule 108 (cons -> conslist .)
    RES_LIST        reduce using rule 108 (cons -> conslist .)
    RES_ARRAY       reduce using rule 108 (cons -> conslist .)
    RBRACKET        reduce using rule 108 (cons -> conslist .)


state 91

    (105) cons -> CTE_INT .

    COMMA           reduce using rule 105 (cons -> CTE_INT .)
    RCURLY          reduce using rule 105 (cons -> CTE_INT .)
    TIMES           reduce using rule 105 (cons -> CTE_INT .)
    DIVIDE          reduce using rule 105 (cons -> CTE_INT .)
    PLUS            reduce using rule 105 (cons -> CTE_INT .)
    MINUS           reduce using rule 105 (cons -> CTE_INT .)
    MIN             reduce using rule 105 (cons -> CTE_INT .)
    MIN_EQ          reduce using rule 105 (cons -> CTE_INT .)
    MAY             reduce using rule 105 (cons -> CTE_INT .)
    MAY_EQ          reduce using rule 105 (cons -> CTE_INT .)
    DIF             reduce using rule 105 (cons -> CTE_INT .)
    RPAREN          reduce using rule 105 (cons -> CTE_INT .)
    RES_READ        reduce using rule 105 (cons -> CTE_INT .)
    RES_PRINT       reduce using rule 105 (cons -> CTE_INT .)
    ID              reduce using rule 105 (cons -> CTE_INT .)
    RES_DEF         reduce using rule 105 (cons -> CTE_INT .)
    RES_IF          reduce using rule 105 (cons -> CTE_INT .)
    RES_SWITCH      reduce using rule 105 (cons -> CTE_INT .)
    RES_WHILE       reduce using rule 105 (cons -> CTE_INT .)
    RES_FOR         reduce using rule 105 (cons -> CTE_INT .)
    RES_START       reduce using rule 105 (cons -> CTE_INT .)
    RES_FUNC        reduce using rule 105 (cons -> CTE_INT .)
    $end            reduce using rule 105 (cons -> CTE_INT .)
    RES_END         reduce using rule 105 (cons -> CTE_INT .)
    E_END           reduce using rule 105 (cons -> CTE_INT .)
    RES_ELSE        reduce using rule 105 (cons -> CTE_INT .)
    RES_CASE        reduce using rule 105 (cons -> CTE_INT .)
    COL             reduce using rule 105 (cons -> CTE_INT .)
    RES_INT         reduce using rule 105 (cons -> CTE_INT .)
    RES_FLOAT       reduce using rule 105 (cons -> CTE_INT .)
    RES_BOOLEAN     reduce using rule 105 (cons -> CTE_INT .)
    RES_STRING      reduce using rule 105 (cons -> CTE_INT .)
    RES_LIST        reduce using rule 105 (cons -> CTE_INT .)
    RES_ARRAY       reduce using rule 105 (cons -> CTE_INT .)
    RBRACKET        reduce using rule 105 (cons -> CTE_INT .)


state 92

    (104) cons -> ID .
    (110) consarray -> ID . LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> ID . EQUALS LCURLY conslist1 RCURLY

    COMMA           reduce using rule 104 (cons -> ID .)
    RCURLY          reduce using rule 104 (cons -> ID .)
    TIMES           reduce using rule 104 (cons -> ID .)
    DIVIDE          reduce using rule 104 (cons -> ID .)
    PLUS            reduce using rule 104 (cons -> ID .)
    MINUS           reduce using rule 104 (cons -> ID .)
    MIN             reduce using rule 104 (cons -> ID .)
    MIN_EQ          reduce using rule 104 (cons -> ID .)
    MAY             reduce using rule 104 (cons -> ID .)
    MAY_EQ          reduce using rule 104 (cons -> ID .)
    DIF             reduce using rule 104 (cons -> ID .)
    RPAREN          reduce using rule 104 (cons -> ID .)
    RES_READ        reduce using rule 104 (cons -> ID .)
    RES_PRINT       reduce using rule 104 (cons -> ID .)
    ID              reduce using rule 104 (cons -> ID .)
    RES_DEF         reduce using rule 104 (cons -> ID .)
    RES_IF          reduce using rule 104 (cons -> ID .)
    RES_SWITCH      reduce using rule 104 (cons -> ID .)
    RES_WHILE       reduce using rule 104 (cons -> ID .)
    RES_FOR         reduce using rule 104 (cons -> ID .)
    RES_START       reduce using rule 104 (cons -> ID .)
    RES_FUNC        reduce using rule 104 (cons -> ID .)
    $end            reduce using rule 104 (cons -> ID .)
    RES_END         reduce using rule 104 (cons -> ID .)
    E_END           reduce using rule 104 (cons -> ID .)
    RES_ELSE        reduce using rule 104 (cons -> ID .)
    RES_CASE        reduce using rule 104 (cons -> ID .)
    COL             reduce using rule 104 (cons -> ID .)
    RES_INT         reduce using rule 104 (cons -> ID .)
    RES_FLOAT       reduce using rule 104 (cons -> ID .)
    RES_BOOLEAN     reduce using rule 104 (cons -> ID .)
    RES_STRING      reduce using rule 104 (cons -> ID .)
    RES_LIST        reduce using rule 104 (cons -> ID .)
    RES_ARRAY       reduce using rule 104 (cons -> ID .)
    RBRACKET        reduce using rule 104 (cons -> ID .)
    LBRACKET        shift and go to state 132
    EQUALS          shift and go to state 131


state 93

    (28) vars1_1 -> vars1 .

    RES_DEF         reduce using rule 28 (vars1_1 -> vars1 .)
    RES_START       reduce using rule 28 (vars1_1 -> vars1 .)
    RES_FUNC        reduce using rule 28 (vars1_1 -> vars1 .)
    RES_READ        reduce using rule 28 (vars1_1 -> vars1 .)
    RES_PRINT       reduce using rule 28 (vars1_1 -> vars1 .)
    ID              reduce using rule 28 (vars1_1 -> vars1 .)
    RES_IF          reduce using rule 28 (vars1_1 -> vars1 .)
    RES_SWITCH      reduce using rule 28 (vars1_1 -> vars1 .)
    RES_WHILE       reduce using rule 28 (vars1_1 -> vars1 .)
    RES_FOR         reduce using rule 28 (vars1_1 -> vars1 .)
    $end            reduce using rule 28 (vars1_1 -> vars1 .)
    RES_END         reduce using rule 28 (vars1_1 -> vars1 .)
    E_END           reduce using rule 28 (vars1_1 -> vars1 .)
    RES_ELSE        reduce using rule 28 (vars1_1 -> vars1 .)
    RES_CASE        reduce using rule 28 (vars1_1 -> vars1 .)


state 94

    (27) vars1 -> dato ID vars2 vars1_1 .

    RES_DEF         reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_START       reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_FUNC        reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_READ        reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_PRINT       reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    ID              reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_IF          reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_SWITCH      reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_WHILE       reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_FOR         reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    $end            reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_END         reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    E_END           reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_ELSE        reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)
    RES_CASE        reduce using rule 27 (vars1 -> dato ID vars2 vars1_1 .)


state 95

    (29) vars1_1 -> empty .

    RES_DEF         reduce using rule 29 (vars1_1 -> empty .)
    RES_START       reduce using rule 29 (vars1_1 -> empty .)
    RES_FUNC        reduce using rule 29 (vars1_1 -> empty .)
    RES_READ        reduce using rule 29 (vars1_1 -> empty .)
    RES_PRINT       reduce using rule 29 (vars1_1 -> empty .)
    ID              reduce using rule 29 (vars1_1 -> empty .)
    RES_IF          reduce using rule 29 (vars1_1 -> empty .)
    RES_SWITCH      reduce using rule 29 (vars1_1 -> empty .)
    RES_WHILE       reduce using rule 29 (vars1_1 -> empty .)
    RES_FOR         reduce using rule 29 (vars1_1 -> empty .)
    $end            reduce using rule 29 (vars1_1 -> empty .)
    RES_END         reduce using rule 29 (vars1_1 -> empty .)
    E_END           reduce using rule 29 (vars1_1 -> empty .)
    RES_ELSE        reduce using rule 29 (vars1_1 -> empty .)
    RES_CASE        reduce using rule 29 (vars1_1 -> empty .)


state 96

    (32) vars3 -> COMMA ID . vars3
    (32) vars3 -> . COMMA ID vars3
    (33) vars3 -> . empty
    (114) empty -> .

    COMMA           shift and go to state 68
    RES_INT         reduce using rule 114 (empty -> .)
    RES_FLOAT       reduce using rule 114 (empty -> .)
    RES_BOOLEAN     reduce using rule 114 (empty -> .)
    RES_STRING      reduce using rule 114 (empty -> .)
    RES_LIST        reduce using rule 114 (empty -> .)
    RES_ARRAY       reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)

    vars3                          shift and go to state 133
    empty                          shift and go to state 69

state 97

    (40) array -> RES_ARRAY dato ID LBRACKET . CTE_INT RBRACKET array1

    CTE_INT         shift and go to state 134


state 98

    (11) prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 . RPAREN

    RPAREN          shift and go to state 135


state 99

    (13) prototipos_1 -> tipo . ID prototipos_2

    ID              shift and go to state 136


state 100

    (21) tipo -> estructura .

    RPAREN          reduce using rule 21 (tipo -> estructura .)
    ID              reduce using rule 21 (tipo -> estructura .)


state 101

    (20) tipo -> dato .

    RPAREN          reduce using rule 20 (tipo -> dato .)
    ID              reduce using rule 20 (tipo -> dato .)


state 102

    (78) forexp -> ID . EQUALS cons COL expresion COL ID EQUALS expresion

    EQUALS          shift and go to state 137


state 103

    (77) for -> RES_FOR LPAREN forexp . RPAREN COL bloque

    RPAREN          shift and go to state 138


state 104

    (101) factor -> cons .

    TIMES           reduce using rule 101 (factor -> cons .)
    DIVIDE          reduce using rule 101 (factor -> cons .)
    PLUS            reduce using rule 101 (factor -> cons .)
    MINUS           reduce using rule 101 (factor -> cons .)
    MIN             reduce using rule 101 (factor -> cons .)
    MIN_EQ          reduce using rule 101 (factor -> cons .)
    MAY             reduce using rule 101 (factor -> cons .)
    MAY_EQ          reduce using rule 101 (factor -> cons .)
    DIF             reduce using rule 101 (factor -> cons .)
    RPAREN          reduce using rule 101 (factor -> cons .)
    COL             reduce using rule 101 (factor -> cons .)
    RES_READ        reduce using rule 101 (factor -> cons .)
    RES_PRINT       reduce using rule 101 (factor -> cons .)
    ID              reduce using rule 101 (factor -> cons .)
    RES_DEF         reduce using rule 101 (factor -> cons .)
    RES_IF          reduce using rule 101 (factor -> cons .)
    RES_SWITCH      reduce using rule 101 (factor -> cons .)
    RES_WHILE       reduce using rule 101 (factor -> cons .)
    RES_FOR         reduce using rule 101 (factor -> cons .)
    RES_START       reduce using rule 101 (factor -> cons .)
    RES_FUNC        reduce using rule 101 (factor -> cons .)
    $end            reduce using rule 101 (factor -> cons .)
    RES_END         reduce using rule 101 (factor -> cons .)
    E_END           reduce using rule 101 (factor -> cons .)
    RES_ELSE        reduce using rule 101 (factor -> cons .)
    RES_CASE        reduce using rule 101 (factor -> cons .)


state 105

    (100) factor -> LPAREN . expresion RPAREN
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 139
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108

state 106

    (92) exp -> termino . exp1
    (93) exp1 -> . PLUS exp
    (94) exp1 -> . MINUS exp
    (95) exp1 -> . empty
    (114) empty -> .

    PLUS            shift and go to state 141
    MINUS           shift and go to state 142
    MIN             reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MAY             reduce using rule 114 (empty -> .)
    MAY_EQ          reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    RPAREN          reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    COL             reduce using rule 114 (empty -> .)

    exp1                           shift and go to state 140
    empty                          shift and go to state 143

state 107

    (103) factor -> MINUS . cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 144
    consarray                      shift and go to state 88

state 108

    (96) termino -> factor . termino1
    (97) termino1 -> . TIMES termino
    (98) termino1 -> . DIVIDE termino
    (99) termino1 -> . empty
    (114) empty -> .

    TIMES           shift and go to state 147
    DIVIDE          shift and go to state 145
    PLUS            reduce using rule 114 (empty -> .)
    MINUS           reduce using rule 114 (empty -> .)
    MIN             reduce using rule 114 (empty -> .)
    MIN_EQ          reduce using rule 114 (empty -> .)
    MAY             reduce using rule 114 (empty -> .)
    MAY_EQ          reduce using rule 114 (empty -> .)
    DIF             reduce using rule 114 (empty -> .)
    RPAREN          reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    COL             reduce using rule 114 (empty -> .)

    termino1                       shift and go to state 146
    empty                          shift and go to state 148

state 109

    (102) factor -> PLUS . cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 149
    consarray                      shift and go to state 88

state 110

    (79) if -> RES_IF LPAREN expresion . RPAREN COL bloque ifelse

    RPAREN          shift and go to state 150


state 111

    (85) expresion -> exp . expresion_1
    (86) expresion_1 -> . MIN exp
    (87) expresion_1 -> . MIN_EQ exp
    (88) expresion_1 -> . MAY exp
    (89) expresion_1 -> . MAY_EQ exp
    (90) expresion_1 -> . DIF exp
    (91) expresion_1 -> . empty
    (114) empty -> .

    MIN             shift and go to state 152
    MIN_EQ          shift and go to state 151
    MAY             shift and go to state 153
    MAY_EQ          shift and go to state 154
    DIF             shift and go to state 156
    RPAREN          reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    COL             reduce using rule 114 (empty -> .)

    empty                          shift and go to state 157
    expresion_1                    shift and go to state 155

state 112

    (65) escritura1 -> CTE_STRING .

    RPAREN          reduce using rule 65 (escritura1 -> CTE_STRING .)


state 113

    (63) escritura -> RES_PRINT LPAREN escritura1 . RPAREN

    RPAREN          shift and go to state 158


state 114

    (64) escritura1 -> expresion .

    RPAREN          reduce using rule 64 (escritura1 -> expresion .)


state 115

    (76) while -> RES_WHILE LPAREN expresion . RPAREN COL bloque

    RPAREN          shift and go to state 159


state 116

    (73) asignarray -> LBRACKET . asignarray1 RBRACKET
    (74) asignarray1 -> . cons
    (75) asignarray1 -> . cons COMMA asignarray1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 160
    asignarray1                    shift and go to state 161
    consarray                      shift and go to state 88

state 117

    (70) asignlist -> LCURLY . asignlist1 RCURLY
    (71) asignlist1 -> . cons
    (72) asignlist1 -> . cons COMMA asignlist1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    asignlist1                     shift and go to state 162
    conslist                       shift and go to state 90
    cons                           shift and go to state 163
    consarray                      shift and go to state 88

state 118

    (69) asignacion1 -> asignarray .

    RES_READ        reduce using rule 69 (asignacion1 -> asignarray .)
    RES_PRINT       reduce using rule 69 (asignacion1 -> asignarray .)
    ID              reduce using rule 69 (asignacion1 -> asignarray .)
    RES_DEF         reduce using rule 69 (asignacion1 -> asignarray .)
    RES_IF          reduce using rule 69 (asignacion1 -> asignarray .)
    RES_SWITCH      reduce using rule 69 (asignacion1 -> asignarray .)
    RES_WHILE       reduce using rule 69 (asignacion1 -> asignarray .)
    RES_FOR         reduce using rule 69 (asignacion1 -> asignarray .)
    RES_START       reduce using rule 69 (asignacion1 -> asignarray .)
    RES_FUNC        reduce using rule 69 (asignacion1 -> asignarray .)
    $end            reduce using rule 69 (asignacion1 -> asignarray .)
    RES_END         reduce using rule 69 (asignacion1 -> asignarray .)
    E_END           reduce using rule 69 (asignacion1 -> asignarray .)
    RES_ELSE        reduce using rule 69 (asignacion1 -> asignarray .)
    RES_CASE        reduce using rule 69 (asignacion1 -> asignarray .)


state 119

    (68) asignacion1 -> asignlist .

    RES_READ        reduce using rule 68 (asignacion1 -> asignlist .)
    RES_PRINT       reduce using rule 68 (asignacion1 -> asignlist .)
    ID              reduce using rule 68 (asignacion1 -> asignlist .)
    RES_DEF         reduce using rule 68 (asignacion1 -> asignlist .)
    RES_IF          reduce using rule 68 (asignacion1 -> asignlist .)
    RES_SWITCH      reduce using rule 68 (asignacion1 -> asignlist .)
    RES_WHILE       reduce using rule 68 (asignacion1 -> asignlist .)
    RES_FOR         reduce using rule 68 (asignacion1 -> asignlist .)
    RES_START       reduce using rule 68 (asignacion1 -> asignlist .)
    RES_FUNC        reduce using rule 68 (asignacion1 -> asignlist .)
    $end            reduce using rule 68 (asignacion1 -> asignlist .)
    RES_END         reduce using rule 68 (asignacion1 -> asignlist .)
    E_END           reduce using rule 68 (asignacion1 -> asignlist .)
    RES_ELSE        reduce using rule 68 (asignacion1 -> asignlist .)
    RES_CASE        reduce using rule 68 (asignacion1 -> asignlist .)


state 120

    (67) asignacion1 -> expresion .

    RES_READ        reduce using rule 67 (asignacion1 -> expresion .)
    RES_PRINT       reduce using rule 67 (asignacion1 -> expresion .)
    ID              reduce using rule 67 (asignacion1 -> expresion .)
    RES_DEF         reduce using rule 67 (asignacion1 -> expresion .)
    RES_IF          reduce using rule 67 (asignacion1 -> expresion .)
    RES_SWITCH      reduce using rule 67 (asignacion1 -> expresion .)
    RES_WHILE       reduce using rule 67 (asignacion1 -> expresion .)
    RES_FOR         reduce using rule 67 (asignacion1 -> expresion .)
    RES_START       reduce using rule 67 (asignacion1 -> expresion .)
    RES_FUNC        reduce using rule 67 (asignacion1 -> expresion .)
    $end            reduce using rule 67 (asignacion1 -> expresion .)
    RES_END         reduce using rule 67 (asignacion1 -> expresion .)
    E_END           reduce using rule 67 (asignacion1 -> expresion .)
    RES_ELSE        reduce using rule 67 (asignacion1 -> expresion .)
    RES_CASE        reduce using rule 67 (asignacion1 -> expresion .)


state 121

    (66) asignacion -> ID EQUALS asignacion1 .

    RES_READ        reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_PRINT       reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    ID              reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_DEF         reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_IF          reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_SWITCH      reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_WHILE       reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_FOR         reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_CASE        reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    E_END           reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_END         reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_ELSE        reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_START       reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    RES_FUNC        reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)
    $end            reduce using rule 66 (asignacion -> ID EQUALS asignacion1 .)


state 122

    (59) llamada -> ID LPAREN llamada1 . RPAREN

    RPAREN          shift and go to state 164


state 123

    (61) llamada1 -> empty .

    RPAREN          reduce using rule 61 (llamada1 -> empty .)


state 124

    (60) llamada1 -> expresion .

    RPAREN          reduce using rule 60 (llamada1 -> expresion .)


state 125

    (62) lectura -> RES_READ LPAREN tipo . RPAREN

    RPAREN          shift and go to state 165


state 126

    (82) switch -> RES_SWITCH COL switch2 .

    E_END           reduce using rule 82 (switch -> RES_SWITCH COL switch2 .)


state 127

    (83) switch2 -> RES_CASE . expresion COL bloque switch2
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 166
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108

state 128

    (84) switch2 -> empty .

    E_END           reduce using rule 84 (switch2 -> empty .)


state 129

    (37) cons_loop -> cons . cons_loop_1
    (38) cons_loop_1 -> . COMMA cons_loop
    (39) cons_loop_1 -> . empty
    (114) empty -> .

    COMMA           shift and go to state 167
    RCURLY          reduce using rule 114 (empty -> .)

    empty                          shift and go to state 168
    cons_loop_1                    shift and go to state 169

state 130

    (35) list1 -> LCURLY cons_loop . RCURLY

    RCURLY          shift and go to state 170


state 131

    (111) conslist -> ID EQUALS . LCURLY conslist1 RCURLY

    LCURLY          shift and go to state 171


state 132

    (110) consarray -> ID LBRACKET . CTE_INT RBRACKET EQUALS cons

    CTE_INT         shift and go to state 172


state 133

    (32) vars3 -> COMMA ID vars3 .

    RES_INT         reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_FLOAT       reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_BOOLEAN     reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_STRING      reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_LIST        reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_ARRAY       reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_DEF         reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_START       reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_FUNC        reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_READ        reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_PRINT       reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    ID              reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_IF          reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_SWITCH      reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_WHILE       reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_FOR         reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    $end            reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_END         reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    E_END           reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_ELSE        reduce using rule 32 (vars3 -> COMMA ID vars3 .)
    RES_CASE        reduce using rule 32 (vars3 -> COMMA ID vars3 .)


state 134

    (40) array -> RES_ARRAY dato ID LBRACKET CTE_INT . RBRACKET array1

    RBRACKET        shift and go to state 173


state 135

    (11) prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .

    COL             reduce using rule 11 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_PROTO       reduce using rule 11 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_DEF         reduce using rule 11 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_START       reduce using rule 11 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_FUNC        reduce using rule 11 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)


state 136

    (13) prototipos_1 -> tipo ID . prototipos_2
    (14) prototipos_2 -> . COMMA prototipos_1
    (15) prototipos_2 -> . empty
    (114) empty -> .

    COMMA           shift and go to state 175
    RPAREN          reduce using rule 114 (empty -> .)

    prototipos_2                   shift and go to state 174
    empty                          shift and go to state 176

state 137

    (78) forexp -> ID EQUALS . cons COL expresion COL ID EQUALS expresion
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 177
    consarray                      shift and go to state 88

state 138

    (77) for -> RES_FOR LPAREN forexp RPAREN . COL bloque

    COL             shift and go to state 178


state 139

    (100) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 179


state 140

    (92) exp -> termino exp1 .

    MIN             reduce using rule 92 (exp -> termino exp1 .)
    MIN_EQ          reduce using rule 92 (exp -> termino exp1 .)
    MAY             reduce using rule 92 (exp -> termino exp1 .)
    MAY_EQ          reduce using rule 92 (exp -> termino exp1 .)
    DIF             reduce using rule 92 (exp -> termino exp1 .)
    COL             reduce using rule 92 (exp -> termino exp1 .)
    RPAREN          reduce using rule 92 (exp -> termino exp1 .)
    RES_READ        reduce using rule 92 (exp -> termino exp1 .)
    RES_PRINT       reduce using rule 92 (exp -> termino exp1 .)
    ID              reduce using rule 92 (exp -> termino exp1 .)
    RES_DEF         reduce using rule 92 (exp -> termino exp1 .)
    RES_IF          reduce using rule 92 (exp -> termino exp1 .)
    RES_SWITCH      reduce using rule 92 (exp -> termino exp1 .)
    RES_WHILE       reduce using rule 92 (exp -> termino exp1 .)
    RES_FOR         reduce using rule 92 (exp -> termino exp1 .)
    RES_START       reduce using rule 92 (exp -> termino exp1 .)
    RES_FUNC        reduce using rule 92 (exp -> termino exp1 .)
    $end            reduce using rule 92 (exp -> termino exp1 .)
    RES_END         reduce using rule 92 (exp -> termino exp1 .)
    E_END           reduce using rule 92 (exp -> termino exp1 .)
    RES_ELSE        reduce using rule 92 (exp -> termino exp1 .)
    RES_CASE        reduce using rule 92 (exp -> termino exp1 .)


state 141

    (93) exp1 -> PLUS . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 180
    factor                         shift and go to state 108

state 142

    (94) exp1 -> MINUS . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 181
    factor                         shift and go to state 108

state 143

    (95) exp1 -> empty .

    MIN             reduce using rule 95 (exp1 -> empty .)
    MIN_EQ          reduce using rule 95 (exp1 -> empty .)
    MAY             reduce using rule 95 (exp1 -> empty .)
    MAY_EQ          reduce using rule 95 (exp1 -> empty .)
    DIF             reduce using rule 95 (exp1 -> empty .)
    RPAREN          reduce using rule 95 (exp1 -> empty .)
    RES_READ        reduce using rule 95 (exp1 -> empty .)
    RES_PRINT       reduce using rule 95 (exp1 -> empty .)
    ID              reduce using rule 95 (exp1 -> empty .)
    RES_DEF         reduce using rule 95 (exp1 -> empty .)
    RES_IF          reduce using rule 95 (exp1 -> empty .)
    RES_SWITCH      reduce using rule 95 (exp1 -> empty .)
    RES_WHILE       reduce using rule 95 (exp1 -> empty .)
    RES_FOR         reduce using rule 95 (exp1 -> empty .)
    RES_START       reduce using rule 95 (exp1 -> empty .)
    RES_FUNC        reduce using rule 95 (exp1 -> empty .)
    $end            reduce using rule 95 (exp1 -> empty .)
    RES_END         reduce using rule 95 (exp1 -> empty .)
    E_END           reduce using rule 95 (exp1 -> empty .)
    RES_ELSE        reduce using rule 95 (exp1 -> empty .)
    RES_CASE        reduce using rule 95 (exp1 -> empty .)
    COL             reduce using rule 95 (exp1 -> empty .)


state 144

    (103) factor -> MINUS cons .

    TIMES           reduce using rule 103 (factor -> MINUS cons .)
    DIVIDE          reduce using rule 103 (factor -> MINUS cons .)
    PLUS            reduce using rule 103 (factor -> MINUS cons .)
    MINUS           reduce using rule 103 (factor -> MINUS cons .)
    MIN             reduce using rule 103 (factor -> MINUS cons .)
    MIN_EQ          reduce using rule 103 (factor -> MINUS cons .)
    MAY             reduce using rule 103 (factor -> MINUS cons .)
    MAY_EQ          reduce using rule 103 (factor -> MINUS cons .)
    DIF             reduce using rule 103 (factor -> MINUS cons .)
    RPAREN          reduce using rule 103 (factor -> MINUS cons .)
    COL             reduce using rule 103 (factor -> MINUS cons .)
    RES_READ        reduce using rule 103 (factor -> MINUS cons .)
    RES_PRINT       reduce using rule 103 (factor -> MINUS cons .)
    ID              reduce using rule 103 (factor -> MINUS cons .)
    RES_DEF         reduce using rule 103 (factor -> MINUS cons .)
    RES_IF          reduce using rule 103 (factor -> MINUS cons .)
    RES_SWITCH      reduce using rule 103 (factor -> MINUS cons .)
    RES_WHILE       reduce using rule 103 (factor -> MINUS cons .)
    RES_FOR         reduce using rule 103 (factor -> MINUS cons .)
    RES_START       reduce using rule 103 (factor -> MINUS cons .)
    RES_FUNC        reduce using rule 103 (factor -> MINUS cons .)
    $end            reduce using rule 103 (factor -> MINUS cons .)
    RES_END         reduce using rule 103 (factor -> MINUS cons .)
    E_END           reduce using rule 103 (factor -> MINUS cons .)
    RES_ELSE        reduce using rule 103 (factor -> MINUS cons .)
    RES_CASE        reduce using rule 103 (factor -> MINUS cons .)


state 145

    (98) termino1 -> DIVIDE . termino
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 182
    factor                         shift and go to state 108

state 146

    (96) termino -> factor termino1 .

    PLUS            reduce using rule 96 (termino -> factor termino1 .)
    MINUS           reduce using rule 96 (termino -> factor termino1 .)
    RPAREN          reduce using rule 96 (termino -> factor termino1 .)
    RES_READ        reduce using rule 96 (termino -> factor termino1 .)
    RES_PRINT       reduce using rule 96 (termino -> factor termino1 .)
    ID              reduce using rule 96 (termino -> factor termino1 .)
    RES_DEF         reduce using rule 96 (termino -> factor termino1 .)
    RES_IF          reduce using rule 96 (termino -> factor termino1 .)
    RES_SWITCH      reduce using rule 96 (termino -> factor termino1 .)
    RES_WHILE       reduce using rule 96 (termino -> factor termino1 .)
    RES_FOR         reduce using rule 96 (termino -> factor termino1 .)
    RES_START       reduce using rule 96 (termino -> factor termino1 .)
    RES_FUNC        reduce using rule 96 (termino -> factor termino1 .)
    $end            reduce using rule 96 (termino -> factor termino1 .)
    RES_END         reduce using rule 96 (termino -> factor termino1 .)
    E_END           reduce using rule 96 (termino -> factor termino1 .)
    RES_ELSE        reduce using rule 96 (termino -> factor termino1 .)
    RES_CASE        reduce using rule 96 (termino -> factor termino1 .)
    COL             reduce using rule 96 (termino -> factor termino1 .)
    MIN             reduce using rule 96 (termino -> factor termino1 .)
    MIN_EQ          reduce using rule 96 (termino -> factor termino1 .)
    MAY             reduce using rule 96 (termino -> factor termino1 .)
    MAY_EQ          reduce using rule 96 (termino -> factor termino1 .)
    DIF             reduce using rule 96 (termino -> factor termino1 .)


state 147

    (97) termino1 -> TIMES . termino
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 183
    factor                         shift and go to state 108

state 148

    (99) termino1 -> empty .

    PLUS            reduce using rule 99 (termino1 -> empty .)
    MINUS           reduce using rule 99 (termino1 -> empty .)
    MIN             reduce using rule 99 (termino1 -> empty .)
    MIN_EQ          reduce using rule 99 (termino1 -> empty .)
    MAY             reduce using rule 99 (termino1 -> empty .)
    MAY_EQ          reduce using rule 99 (termino1 -> empty .)
    DIF             reduce using rule 99 (termino1 -> empty .)
    RPAREN          reduce using rule 99 (termino1 -> empty .)
    RES_READ        reduce using rule 99 (termino1 -> empty .)
    RES_PRINT       reduce using rule 99 (termino1 -> empty .)
    ID              reduce using rule 99 (termino1 -> empty .)
    RES_DEF         reduce using rule 99 (termino1 -> empty .)
    RES_IF          reduce using rule 99 (termino1 -> empty .)
    RES_SWITCH      reduce using rule 99 (termino1 -> empty .)
    RES_WHILE       reduce using rule 99 (termino1 -> empty .)
    RES_FOR         reduce using rule 99 (termino1 -> empty .)
    RES_START       reduce using rule 99 (termino1 -> empty .)
    RES_FUNC        reduce using rule 99 (termino1 -> empty .)
    $end            reduce using rule 99 (termino1 -> empty .)
    RES_END         reduce using rule 99 (termino1 -> empty .)
    E_END           reduce using rule 99 (termino1 -> empty .)
    RES_ELSE        reduce using rule 99 (termino1 -> empty .)
    RES_CASE        reduce using rule 99 (termino1 -> empty .)
    COL             reduce using rule 99 (termino1 -> empty .)


state 149

    (102) factor -> PLUS cons .

    TIMES           reduce using rule 102 (factor -> PLUS cons .)
    DIVIDE          reduce using rule 102 (factor -> PLUS cons .)
    PLUS            reduce using rule 102 (factor -> PLUS cons .)
    MINUS           reduce using rule 102 (factor -> PLUS cons .)
    MIN             reduce using rule 102 (factor -> PLUS cons .)
    MIN_EQ          reduce using rule 102 (factor -> PLUS cons .)
    MAY             reduce using rule 102 (factor -> PLUS cons .)
    MAY_EQ          reduce using rule 102 (factor -> PLUS cons .)
    DIF             reduce using rule 102 (factor -> PLUS cons .)
    RPAREN          reduce using rule 102 (factor -> PLUS cons .)
    COL             reduce using rule 102 (factor -> PLUS cons .)
    RES_READ        reduce using rule 102 (factor -> PLUS cons .)
    RES_PRINT       reduce using rule 102 (factor -> PLUS cons .)
    ID              reduce using rule 102 (factor -> PLUS cons .)
    RES_DEF         reduce using rule 102 (factor -> PLUS cons .)
    RES_IF          reduce using rule 102 (factor -> PLUS cons .)
    RES_SWITCH      reduce using rule 102 (factor -> PLUS cons .)
    RES_WHILE       reduce using rule 102 (factor -> PLUS cons .)
    RES_FOR         reduce using rule 102 (factor -> PLUS cons .)
    RES_START       reduce using rule 102 (factor -> PLUS cons .)
    RES_FUNC        reduce using rule 102 (factor -> PLUS cons .)
    $end            reduce using rule 102 (factor -> PLUS cons .)
    RES_END         reduce using rule 102 (factor -> PLUS cons .)
    E_END           reduce using rule 102 (factor -> PLUS cons .)
    RES_ELSE        reduce using rule 102 (factor -> PLUS cons .)
    RES_CASE        reduce using rule 102 (factor -> PLUS cons .)


state 150

    (79) if -> RES_IF LPAREN expresion RPAREN . COL bloque ifelse

    COL             shift and go to state 184


state 151

    (87) expresion_1 -> MIN_EQ . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 185
    factor                         shift and go to state 108

state 152

    (86) expresion_1 -> MIN . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 186
    factor                         shift and go to state 108

state 153

    (88) expresion_1 -> MAY . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 187
    factor                         shift and go to state 108

state 154

    (89) expresion_1 -> MAY_EQ . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 188
    factor                         shift and go to state 108

state 155

    (85) expresion -> exp expresion_1 .

    COL             reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_READ        reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_PRINT       reduce using rule 85 (expresion -> exp expresion_1 .)
    ID              reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_DEF         reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_IF          reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_SWITCH      reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_WHILE       reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_FOR         reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_START       reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_FUNC        reduce using rule 85 (expresion -> exp expresion_1 .)
    $end            reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_END         reduce using rule 85 (expresion -> exp expresion_1 .)
    E_END           reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_ELSE        reduce using rule 85 (expresion -> exp expresion_1 .)
    RES_CASE        reduce using rule 85 (expresion -> exp expresion_1 .)
    RPAREN          reduce using rule 85 (expresion -> exp expresion_1 .)


state 156

    (90) expresion_1 -> DIF . exp
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    cons                           shift and go to state 104
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    exp                            shift and go to state 189
    factor                         shift and go to state 108

state 157

    (91) expresion_1 -> empty .

    RPAREN          reduce using rule 91 (expresion_1 -> empty .)
    RES_READ        reduce using rule 91 (expresion_1 -> empty .)
    RES_PRINT       reduce using rule 91 (expresion_1 -> empty .)
    ID              reduce using rule 91 (expresion_1 -> empty .)
    RES_DEF         reduce using rule 91 (expresion_1 -> empty .)
    RES_IF          reduce using rule 91 (expresion_1 -> empty .)
    RES_SWITCH      reduce using rule 91 (expresion_1 -> empty .)
    RES_WHILE       reduce using rule 91 (expresion_1 -> empty .)
    RES_FOR         reduce using rule 91 (expresion_1 -> empty .)
    RES_START       reduce using rule 91 (expresion_1 -> empty .)
    RES_FUNC        reduce using rule 91 (expresion_1 -> empty .)
    $end            reduce using rule 91 (expresion_1 -> empty .)
    RES_END         reduce using rule 91 (expresion_1 -> empty .)
    E_END           reduce using rule 91 (expresion_1 -> empty .)
    RES_ELSE        reduce using rule 91 (expresion_1 -> empty .)
    RES_CASE        reduce using rule 91 (expresion_1 -> empty .)
    COL             reduce using rule 91 (expresion_1 -> empty .)


state 158

    (63) escritura -> RES_PRINT LPAREN escritura1 RPAREN .

    RES_READ        reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_PRINT       reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    ID              reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_DEF         reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_IF          reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_SWITCH      reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_WHILE       reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_FOR         reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_END         reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_CASE        reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    E_END           reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_START       reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_FUNC        reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    $end            reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_ELSE        reduce using rule 63 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)


state 159

    (76) while -> RES_WHILE LPAREN expresion RPAREN . COL bloque

    COL             shift and go to state 190


state 160

    (74) asignarray1 -> cons .
    (75) asignarray1 -> cons . COMMA asignarray1

    RBRACKET        reduce using rule 74 (asignarray1 -> cons .)
    COMMA           shift and go to state 191


state 161

    (73) asignarray -> LBRACKET asignarray1 . RBRACKET

    RBRACKET        shift and go to state 192


state 162

    (70) asignlist -> LCURLY asignlist1 . RCURLY

    RCURLY          shift and go to state 193


state 163

    (71) asignlist1 -> cons .
    (72) asignlist1 -> cons . COMMA asignlist1

    RCURLY          reduce using rule 71 (asignlist1 -> cons .)
    COMMA           shift and go to state 194


state 164

    (59) llamada -> ID LPAREN llamada1 RPAREN .

    RES_READ        reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_PRINT       reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    ID              reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_DEF         reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_IF          reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_SWITCH      reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_WHILE       reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_FOR         reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_CASE        reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    E_END           reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_START       reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_FUNC        reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    $end            reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_ELSE        reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_END         reduce using rule 59 (llamada -> ID LPAREN llamada1 RPAREN .)


state 165

    (62) lectura -> RES_READ LPAREN tipo RPAREN .

    RES_READ        reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_PRINT       reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    ID              reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_DEF         reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_IF          reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_SWITCH      reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_WHILE       reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_FOR         reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_END         reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_ELSE        reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    E_END           reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_START       reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_FUNC        reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    $end            reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_CASE        reduce using rule 62 (lectura -> RES_READ LPAREN tipo RPAREN .)


state 166

    (83) switch2 -> RES_CASE expresion . COL bloque switch2

    COL             shift and go to state 195


state 167

    (38) cons_loop_1 -> COMMA . cons_loop
    (37) cons_loop -> . cons cons_loop_1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    consarray                      shift and go to state 88
    cons                           shift and go to state 129
    cons_loop                      shift and go to state 196

state 168

    (39) cons_loop_1 -> empty .

    RCURLY          reduce using rule 39 (cons_loop_1 -> empty .)


state 169

    (37) cons_loop -> cons cons_loop_1 .

    RCURLY          reduce using rule 37 (cons_loop -> cons cons_loop_1 .)


state 170

    (35) list1 -> LCURLY cons_loop RCURLY .

    RES_INT         reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_FLOAT       reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_BOOLEAN     reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_STRING      reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_LIST        reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_ARRAY       reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_DEF         reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_START       reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_FUNC        reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_READ        reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_PRINT       reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    ID              reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_IF          reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_SWITCH      reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_WHILE       reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_FOR         reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    $end            reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_END         reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    E_END           reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_ELSE        reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RES_CASE        reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)
    RPAREN          reduce using rule 35 (list1 -> LCURLY cons_loop RCURLY .)


state 171

    (111) conslist -> ID EQUALS LCURLY . conslist1 RCURLY
    (112) conslist1 -> . cons
    (113) conslist1 -> . cons COMMA conslist1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist1                      shift and go to state 198
    conslist                       shift and go to state 90
    cons                           shift and go to state 197
    consarray                      shift and go to state 88

state 172

    (110) consarray -> ID LBRACKET CTE_INT . RBRACKET EQUALS cons

    RBRACKET        shift and go to state 199


state 173

    (40) array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET . array1
    (41) array1 -> . COL LBRACKET array2 RBRACKET
    (42) array1 -> . empty
    (114) empty -> .

    COL             shift and go to state 201
    RES_INT         reduce using rule 114 (empty -> .)
    RES_FLOAT       reduce using rule 114 (empty -> .)
    RES_BOOLEAN     reduce using rule 114 (empty -> .)
    RES_STRING      reduce using rule 114 (empty -> .)
    RES_LIST        reduce using rule 114 (empty -> .)
    RES_ARRAY       reduce using rule 114 (empty -> .)
    RES_DEF         reduce using rule 114 (empty -> .)
    RES_START       reduce using rule 114 (empty -> .)
    RES_FUNC        reduce using rule 114 (empty -> .)
    RES_READ        reduce using rule 114 (empty -> .)
    RES_PRINT       reduce using rule 114 (empty -> .)
    ID              reduce using rule 114 (empty -> .)
    RES_IF          reduce using rule 114 (empty -> .)
    RES_SWITCH      reduce using rule 114 (empty -> .)
    RES_WHILE       reduce using rule 114 (empty -> .)
    RES_FOR         reduce using rule 114 (empty -> .)
    $end            reduce using rule 114 (empty -> .)
    RES_END         reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_ELSE        reduce using rule 114 (empty -> .)
    RES_CASE        reduce using rule 114 (empty -> .)
    RPAREN          reduce using rule 114 (empty -> .)

    array1                         shift and go to state 200
    empty                          shift and go to state 202

state 174

    (13) prototipos_1 -> tipo ID prototipos_2 .

    RPAREN          reduce using rule 13 (prototipos_1 -> tipo ID prototipos_2 .)


state 175

    (14) prototipos_2 -> COMMA . prototipos_1
    (13) prototipos_1 -> . tipo ID prototipos_2
    (20) tipo -> . dato
    (21) tipo -> . estructura
    (16) dato -> . RES_INT
    (17) dato -> . RES_FLOAT
    (18) dato -> . RES_BOOLEAN
    (19) dato -> . RES_STRING
    (22) estructura -> . list
    (23) estructura -> . array
    (34) list -> . RES_LIST dato ID list1
    (40) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 14
    RES_FLOAT       shift and go to state 18
    RES_BOOLEAN     shift and go to state 16
    RES_STRING      shift and go to state 15
    RES_LIST        shift and go to state 23
    RES_ARRAY       shift and go to state 29

    tipo                           shift and go to state 99
    prototipos_1                   shift and go to state 203
    list                           shift and go to state 25
    estructura                     shift and go to state 100
    dato                           shift and go to state 101
    array                          shift and go to state 28

state 176

    (15) prototipos_2 -> empty .

    RPAREN          reduce using rule 15 (prototipos_2 -> empty .)


state 177

    (78) forexp -> ID EQUALS cons . COL expresion COL ID EQUALS expresion

    COL             shift and go to state 204


state 178

    (77) for -> RES_FOR LPAREN forexp RPAREN COL . bloque
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    E_END           reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 205
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 179

    (100) factor -> LPAREN expresion RPAREN .

    TIMES           reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    MIN             reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    MIN_EQ          reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    MAY             reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    MAY_EQ          reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    DIF             reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    COL             reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_READ        reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_PRINT       reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    ID              reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_DEF         reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_IF          reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_SWITCH      reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_WHILE       reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_FOR         reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_START       reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_FUNC        reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    $end            reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_END         reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    E_END           reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_ELSE        reduce using rule 100 (factor -> LPAREN expresion RPAREN .)
    RES_CASE        reduce using rule 100 (factor -> LPAREN expresion RPAREN .)


state 180

    (93) exp1 -> PLUS exp .

    MIN             reduce using rule 93 (exp1 -> PLUS exp .)
    MIN_EQ          reduce using rule 93 (exp1 -> PLUS exp .)
    MAY             reduce using rule 93 (exp1 -> PLUS exp .)
    MAY_EQ          reduce using rule 93 (exp1 -> PLUS exp .)
    DIF             reduce using rule 93 (exp1 -> PLUS exp .)
    RPAREN          reduce using rule 93 (exp1 -> PLUS exp .)
    RES_READ        reduce using rule 93 (exp1 -> PLUS exp .)
    RES_PRINT       reduce using rule 93 (exp1 -> PLUS exp .)
    ID              reduce using rule 93 (exp1 -> PLUS exp .)
    RES_DEF         reduce using rule 93 (exp1 -> PLUS exp .)
    RES_IF          reduce using rule 93 (exp1 -> PLUS exp .)
    RES_SWITCH      reduce using rule 93 (exp1 -> PLUS exp .)
    RES_WHILE       reduce using rule 93 (exp1 -> PLUS exp .)
    RES_FOR         reduce using rule 93 (exp1 -> PLUS exp .)
    RES_START       reduce using rule 93 (exp1 -> PLUS exp .)
    RES_FUNC        reduce using rule 93 (exp1 -> PLUS exp .)
    $end            reduce using rule 93 (exp1 -> PLUS exp .)
    RES_END         reduce using rule 93 (exp1 -> PLUS exp .)
    E_END           reduce using rule 93 (exp1 -> PLUS exp .)
    RES_ELSE        reduce using rule 93 (exp1 -> PLUS exp .)
    RES_CASE        reduce using rule 93 (exp1 -> PLUS exp .)
    COL             reduce using rule 93 (exp1 -> PLUS exp .)


state 181

    (94) exp1 -> MINUS exp .

    MIN             reduce using rule 94 (exp1 -> MINUS exp .)
    MIN_EQ          reduce using rule 94 (exp1 -> MINUS exp .)
    MAY             reduce using rule 94 (exp1 -> MINUS exp .)
    MAY_EQ          reduce using rule 94 (exp1 -> MINUS exp .)
    DIF             reduce using rule 94 (exp1 -> MINUS exp .)
    RPAREN          reduce using rule 94 (exp1 -> MINUS exp .)
    RES_READ        reduce using rule 94 (exp1 -> MINUS exp .)
    RES_PRINT       reduce using rule 94 (exp1 -> MINUS exp .)
    ID              reduce using rule 94 (exp1 -> MINUS exp .)
    RES_DEF         reduce using rule 94 (exp1 -> MINUS exp .)
    RES_IF          reduce using rule 94 (exp1 -> MINUS exp .)
    RES_SWITCH      reduce using rule 94 (exp1 -> MINUS exp .)
    RES_WHILE       reduce using rule 94 (exp1 -> MINUS exp .)
    RES_FOR         reduce using rule 94 (exp1 -> MINUS exp .)
    RES_START       reduce using rule 94 (exp1 -> MINUS exp .)
    RES_FUNC        reduce using rule 94 (exp1 -> MINUS exp .)
    $end            reduce using rule 94 (exp1 -> MINUS exp .)
    RES_END         reduce using rule 94 (exp1 -> MINUS exp .)
    E_END           reduce using rule 94 (exp1 -> MINUS exp .)
    RES_ELSE        reduce using rule 94 (exp1 -> MINUS exp .)
    RES_CASE        reduce using rule 94 (exp1 -> MINUS exp .)
    COL             reduce using rule 94 (exp1 -> MINUS exp .)


state 182

    (98) termino1 -> DIVIDE termino .

    PLUS            reduce using rule 98 (termino1 -> DIVIDE termino .)
    MINUS           reduce using rule 98 (termino1 -> DIVIDE termino .)
    MIN             reduce using rule 98 (termino1 -> DIVIDE termino .)
    MIN_EQ          reduce using rule 98 (termino1 -> DIVIDE termino .)
    MAY             reduce using rule 98 (termino1 -> DIVIDE termino .)
    MAY_EQ          reduce using rule 98 (termino1 -> DIVIDE termino .)
    DIF             reduce using rule 98 (termino1 -> DIVIDE termino .)
    RPAREN          reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_READ        reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_PRINT       reduce using rule 98 (termino1 -> DIVIDE termino .)
    ID              reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_DEF         reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_IF          reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_SWITCH      reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_WHILE       reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_FOR         reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_START       reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_FUNC        reduce using rule 98 (termino1 -> DIVIDE termino .)
    $end            reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_END         reduce using rule 98 (termino1 -> DIVIDE termino .)
    E_END           reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_ELSE        reduce using rule 98 (termino1 -> DIVIDE termino .)
    RES_CASE        reduce using rule 98 (termino1 -> DIVIDE termino .)
    COL             reduce using rule 98 (termino1 -> DIVIDE termino .)


state 183

    (97) termino1 -> TIMES termino .

    PLUS            reduce using rule 97 (termino1 -> TIMES termino .)
    MINUS           reduce using rule 97 (termino1 -> TIMES termino .)
    MIN             reduce using rule 97 (termino1 -> TIMES termino .)
    MIN_EQ          reduce using rule 97 (termino1 -> TIMES termino .)
    MAY             reduce using rule 97 (termino1 -> TIMES termino .)
    MAY_EQ          reduce using rule 97 (termino1 -> TIMES termino .)
    DIF             reduce using rule 97 (termino1 -> TIMES termino .)
    RPAREN          reduce using rule 97 (termino1 -> TIMES termino .)
    RES_READ        reduce using rule 97 (termino1 -> TIMES termino .)
    RES_PRINT       reduce using rule 97 (termino1 -> TIMES termino .)
    ID              reduce using rule 97 (termino1 -> TIMES termino .)
    RES_DEF         reduce using rule 97 (termino1 -> TIMES termino .)
    RES_IF          reduce using rule 97 (termino1 -> TIMES termino .)
    RES_SWITCH      reduce using rule 97 (termino1 -> TIMES termino .)
    RES_WHILE       reduce using rule 97 (termino1 -> TIMES termino .)
    RES_FOR         reduce using rule 97 (termino1 -> TIMES termino .)
    RES_START       reduce using rule 97 (termino1 -> TIMES termino .)
    RES_FUNC        reduce using rule 97 (termino1 -> TIMES termino .)
    $end            reduce using rule 97 (termino1 -> TIMES termino .)
    RES_END         reduce using rule 97 (termino1 -> TIMES termino .)
    E_END           reduce using rule 97 (termino1 -> TIMES termino .)
    RES_ELSE        reduce using rule 97 (termino1 -> TIMES termino .)
    RES_CASE        reduce using rule 97 (termino1 -> TIMES termino .)
    COL             reduce using rule 97 (termino1 -> TIMES termino .)


state 184

    (79) if -> RES_IF LPAREN expresion RPAREN COL . bloque ifelse
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_ELSE        reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 206
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 185

    (87) expresion_1 -> MIN_EQ exp .

    RPAREN          reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_READ        reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_PRINT       reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    ID              reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_DEF         reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_IF          reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_SWITCH      reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_WHILE       reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_FOR         reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_START       reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_FUNC        reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    $end            reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_END         reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    E_END           reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_ELSE        reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    RES_CASE        reduce using rule 87 (expresion_1 -> MIN_EQ exp .)
    COL             reduce using rule 87 (expresion_1 -> MIN_EQ exp .)


state 186

    (86) expresion_1 -> MIN exp .

    RPAREN          reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_READ        reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_PRINT       reduce using rule 86 (expresion_1 -> MIN exp .)
    ID              reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_DEF         reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_IF          reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_SWITCH      reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_WHILE       reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_FOR         reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_START       reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_FUNC        reduce using rule 86 (expresion_1 -> MIN exp .)
    $end            reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_END         reduce using rule 86 (expresion_1 -> MIN exp .)
    E_END           reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_ELSE        reduce using rule 86 (expresion_1 -> MIN exp .)
    RES_CASE        reduce using rule 86 (expresion_1 -> MIN exp .)
    COL             reduce using rule 86 (expresion_1 -> MIN exp .)


state 187

    (88) expresion_1 -> MAY exp .

    RPAREN          reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_READ        reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_PRINT       reduce using rule 88 (expresion_1 -> MAY exp .)
    ID              reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_DEF         reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_IF          reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_SWITCH      reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_WHILE       reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_FOR         reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_START       reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_FUNC        reduce using rule 88 (expresion_1 -> MAY exp .)
    $end            reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_END         reduce using rule 88 (expresion_1 -> MAY exp .)
    E_END           reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_ELSE        reduce using rule 88 (expresion_1 -> MAY exp .)
    RES_CASE        reduce using rule 88 (expresion_1 -> MAY exp .)
    COL             reduce using rule 88 (expresion_1 -> MAY exp .)


state 188

    (89) expresion_1 -> MAY_EQ exp .

    RPAREN          reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_READ        reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_PRINT       reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    ID              reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_DEF         reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_IF          reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_SWITCH      reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_WHILE       reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_FOR         reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_START       reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_FUNC        reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    $end            reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_END         reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    E_END           reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_ELSE        reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    RES_CASE        reduce using rule 89 (expresion_1 -> MAY_EQ exp .)
    COL             reduce using rule 89 (expresion_1 -> MAY_EQ exp .)


state 189

    (90) expresion_1 -> DIF exp .

    RPAREN          reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_READ        reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_PRINT       reduce using rule 90 (expresion_1 -> DIF exp .)
    ID              reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_DEF         reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_IF          reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_SWITCH      reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_WHILE       reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_FOR         reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_START       reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_FUNC        reduce using rule 90 (expresion_1 -> DIF exp .)
    $end            reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_END         reduce using rule 90 (expresion_1 -> DIF exp .)
    E_END           reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_ELSE        reduce using rule 90 (expresion_1 -> DIF exp .)
    RES_CASE        reduce using rule 90 (expresion_1 -> DIF exp .)
    COL             reduce using rule 90 (expresion_1 -> DIF exp .)


state 190

    (76) while -> RES_WHILE LPAREN expresion RPAREN COL . bloque
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    E_END           reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 207
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 191

    (75) asignarray1 -> cons COMMA . asignarray1
    (74) asignarray1 -> . cons
    (75) asignarray1 -> . cons COMMA asignarray1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 160
    asignarray1                    shift and go to state 208
    consarray                      shift and go to state 88

state 192

    (73) asignarray -> LBRACKET asignarray1 RBRACKET .

    RES_READ        reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_PRINT       reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    ID              reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_DEF         reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_IF          reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_SWITCH      reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_WHILE       reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_FOR         reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_START       reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_FUNC        reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    $end            reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_END         reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    E_END           reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_ELSE        reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_CASE        reduce using rule 73 (asignarray -> LBRACKET asignarray1 RBRACKET .)


state 193

    (70) asignlist -> LCURLY asignlist1 RCURLY .

    RES_READ        reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_PRINT       reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    ID              reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_DEF         reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_IF          reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_SWITCH      reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_WHILE       reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_FOR         reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_START       reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_FUNC        reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    $end            reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_END         reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    E_END           reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_ELSE        reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_CASE        reduce using rule 70 (asignlist -> LCURLY asignlist1 RCURLY .)


state 194

    (72) asignlist1 -> cons COMMA . asignlist1
    (71) asignlist1 -> . cons
    (72) asignlist1 -> . cons COMMA asignlist1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    asignlist1                     shift and go to state 209
    conslist                       shift and go to state 90
    cons                           shift and go to state 163
    consarray                      shift and go to state 88

state 195

    (83) switch2 -> RES_CASE expresion COL . bloque switch2
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_CASE        reduce using rule 114 (empty -> .)
    E_END           reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 210
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 196

    (38) cons_loop_1 -> COMMA cons_loop .

    RCURLY          reduce using rule 38 (cons_loop_1 -> COMMA cons_loop .)


state 197

    (112) conslist1 -> cons .
    (113) conslist1 -> cons . COMMA conslist1

    RCURLY          reduce using rule 112 (conslist1 -> cons .)
    COMMA           shift and go to state 211


state 198

    (111) conslist -> ID EQUALS LCURLY conslist1 . RCURLY

    RCURLY          shift and go to state 212


state 199

    (110) consarray -> ID LBRACKET CTE_INT RBRACKET . EQUALS cons

    EQUALS          shift and go to state 213


state 200

    (40) array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .

    RES_INT         reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_FLOAT       reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_BOOLEAN     reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_STRING      reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_LIST        reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_ARRAY       reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_DEF         reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_START       reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_FUNC        reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_READ        reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_PRINT       reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    ID              reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_IF          reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_SWITCH      reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_WHILE       reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_FOR         reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    $end            reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_END         reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    E_END           reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_ELSE        reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_CASE        reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RPAREN          reduce using rule 40 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)


state 201

    (41) array1 -> COL . LBRACKET array2 RBRACKET

    LBRACKET        shift and go to state 214


state 202

    (42) array1 -> empty .

    RES_INT         reduce using rule 42 (array1 -> empty .)
    RES_FLOAT       reduce using rule 42 (array1 -> empty .)
    RES_BOOLEAN     reduce using rule 42 (array1 -> empty .)
    RES_STRING      reduce using rule 42 (array1 -> empty .)
    RES_LIST        reduce using rule 42 (array1 -> empty .)
    RES_ARRAY       reduce using rule 42 (array1 -> empty .)
    RES_DEF         reduce using rule 42 (array1 -> empty .)
    RES_START       reduce using rule 42 (array1 -> empty .)
    RES_FUNC        reduce using rule 42 (array1 -> empty .)
    RES_READ        reduce using rule 42 (array1 -> empty .)
    RES_PRINT       reduce using rule 42 (array1 -> empty .)
    ID              reduce using rule 42 (array1 -> empty .)
    RES_IF          reduce using rule 42 (array1 -> empty .)
    RES_SWITCH      reduce using rule 42 (array1 -> empty .)
    RES_WHILE       reduce using rule 42 (array1 -> empty .)
    RES_FOR         reduce using rule 42 (array1 -> empty .)
    $end            reduce using rule 42 (array1 -> empty .)
    RES_END         reduce using rule 42 (array1 -> empty .)
    E_END           reduce using rule 42 (array1 -> empty .)
    RES_ELSE        reduce using rule 42 (array1 -> empty .)
    RES_CASE        reduce using rule 42 (array1 -> empty .)
    RPAREN          reduce using rule 42 (array1 -> empty .)


state 203

    (14) prototipos_2 -> COMMA prototipos_1 .

    RPAREN          reduce using rule 14 (prototipos_2 -> COMMA prototipos_1 .)


state 204

    (78) forexp -> ID EQUALS cons COL . expresion COL ID EQUALS expresion
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 215
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108

state 205

    (77) for -> RES_FOR LPAREN forexp RPAREN COL bloque .

    E_END           reduce using rule 77 (for -> RES_FOR LPAREN forexp RPAREN COL bloque .)


state 206

    (79) if -> RES_IF LPAREN expresion RPAREN COL bloque . ifelse
    (80) ifelse -> . RES_ELSE COL bloque
    (81) ifelse -> . empty
    (114) empty -> .

    RES_ELSE        shift and go to state 216
    E_END           reduce using rule 114 (empty -> .)

    ifelse                         shift and go to state 217
    empty                          shift and go to state 218

state 207

    (76) while -> RES_WHILE LPAREN expresion RPAREN COL bloque .

    E_END           reduce using rule 76 (while -> RES_WHILE LPAREN expresion RPAREN COL bloque .)


state 208

    (75) asignarray1 -> cons COMMA asignarray1 .

    RBRACKET        reduce using rule 75 (asignarray1 -> cons COMMA asignarray1 .)


state 209

    (72) asignlist1 -> cons COMMA asignlist1 .

    RCURLY          reduce using rule 72 (asignlist1 -> cons COMMA asignlist1 .)


state 210

    (83) switch2 -> RES_CASE expresion COL bloque . switch2
    (83) switch2 -> . RES_CASE expresion COL bloque switch2
    (84) switch2 -> . empty
    (114) empty -> .

    RES_CASE        shift and go to state 127
    E_END           reduce using rule 114 (empty -> .)

    switch2                        shift and go to state 219
    empty                          shift and go to state 128

state 211

    (113) conslist1 -> cons COMMA . conslist1
    (112) conslist1 -> . cons
    (113) conslist1 -> . cons COMMA conslist1
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist1                      shift and go to state 220
    conslist                       shift and go to state 90
    cons                           shift and go to state 197
    consarray                      shift and go to state 88

state 212

    (111) conslist -> ID EQUALS LCURLY conslist1 RCURLY .

    TIMES           reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    DIVIDE          reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    PLUS            reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MINUS           reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RPAREN          reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_READ        reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_PRINT       reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    ID              reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_DEF         reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_IF          reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_SWITCH      reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_WHILE       reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_FOR         reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_START       reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_FUNC        reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    $end            reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_END         reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    E_END           reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_ELSE        reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_CASE        reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    COL             reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MIN             reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MIN_EQ          reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MAY             reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MAY_EQ          reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    DIF             reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    COMMA           reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RCURLY          reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RBRACKET        reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_INT         reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_FLOAT       reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_BOOLEAN     reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_STRING      reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_LIST        reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_ARRAY       reduce using rule 111 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)


state 213

    (110) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS . cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    conslist                       shift and go to state 90
    cons                           shift and go to state 221
    consarray                      shift and go to state 88

state 214

    (41) array1 -> COL LBRACKET . array2 RBRACKET
    (43) array2 -> . cons
    (44) array2 -> . cons COMMA array2
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    array2                         shift and go to state 223
    conslist                       shift and go to state 90
    cons                           shift and go to state 222
    consarray                      shift and go to state 88

state 215

    (78) forexp -> ID EQUALS cons COL expresion . COL ID EQUALS expresion

    COL             shift and go to state 224


state 216

    (80) ifelse -> RES_ELSE . COL bloque

    COL             shift and go to state 225


state 217

    (79) if -> RES_IF LPAREN expresion RPAREN COL bloque ifelse .

    E_END           reduce using rule 79 (if -> RES_IF LPAREN expresion RPAREN COL bloque ifelse .)


state 218

    (81) ifelse -> empty .

    E_END           reduce using rule 81 (ifelse -> empty .)


state 219

    (83) switch2 -> RES_CASE expresion COL bloque switch2 .

    E_END           reduce using rule 83 (switch2 -> RES_CASE expresion COL bloque switch2 .)


state 220

    (113) conslist1 -> cons COMMA conslist1 .

    RCURLY          reduce using rule 113 (conslist1 -> cons COMMA conslist1 .)


state 221

    (110) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .

    TIMES           reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    DIVIDE          reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    PLUS            reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MINUS           reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MIN             reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MIN_EQ          reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MAY             reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MAY_EQ          reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    DIF             reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RPAREN          reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_READ        reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_PRINT       reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    ID              reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_DEF         reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_IF          reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_SWITCH      reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_WHILE       reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_FOR         reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_START       reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_FUNC        reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    $end            reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_END         reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    E_END           reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_ELSE        reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_CASE        reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    COL             reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    COMMA           reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RCURLY          reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RBRACKET        reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_INT         reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_FLOAT       reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_BOOLEAN     reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_STRING      reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_LIST        reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_ARRAY       reduce using rule 110 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)


state 222

    (43) array2 -> cons .
    (44) array2 -> cons . COMMA array2

    RBRACKET        reduce using rule 43 (array2 -> cons .)
    COMMA           shift and go to state 226


state 223

    (41) array1 -> COL LBRACKET array2 . RBRACKET

    RBRACKET        shift and go to state 227


state 224

    (78) forexp -> ID EQUALS cons COL expresion COL . ID EQUALS expresion

    ID              shift and go to state 228


state 225

    (80) ifelse -> RES_ELSE COL . bloque
    (46) bloque -> . estatutos bloque
    (47) bloque -> . empty
    (48) estatutos -> . condicion E_END
    (49) estatutos -> . ciclo E_END
    (50) estatutos -> . lectura
    (51) estatutos -> . escritura
    (52) estatutos -> . asignacion
    (53) estatutos -> . llamada
    (54) estatutos -> . vars
    (114) empty -> .
    (57) condicion -> . if
    (58) condicion -> . switch
    (55) ciclo -> . while
    (56) ciclo -> . for
    (62) lectura -> . RES_READ LPAREN tipo RPAREN
    (63) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (66) asignacion -> . ID EQUALS asignacion1
    (59) llamada -> . ID LPAREN llamada1 RPAREN
    (24) vars -> . RES_DEF vars1
    (79) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (82) switch -> . RES_SWITCH COL switch2
    (76) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (77) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    E_END           reduce using rule 114 (empty -> .)
    RES_READ        shift and go to state 58
    RES_PRINT       shift and go to state 46
    ID              shift and go to state 57
    RES_DEF         shift and go to state 11
    RES_IF          shift and go to state 45
    RES_SWITCH      shift and go to state 60
    RES_WHILE       shift and go to state 56
    RES_FOR         shift and go to state 43

    vars                           shift and go to state 42
    bloque                         shift and go to state 229
    if                             shift and go to state 52
    ciclo                          shift and go to state 47
    switch                         shift and go to state 48
    llamada                        shift and go to state 50
    condicion                      shift and go to state 51
    lectura                        shift and go to state 53
    empty                          shift and go to state 54
    estatutos                      shift and go to state 55
    for                            shift and go to state 49
    asignacion                     shift and go to state 59
    while                          shift and go to state 61
    escritura                      shift and go to state 62

state 226

    (44) array2 -> cons COMMA . array2
    (43) array2 -> . cons
    (44) array2 -> . cons COMMA array2
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    array2                         shift and go to state 230
    conslist                       shift and go to state 90
    cons                           shift and go to state 222
    consarray                      shift and go to state 88

state 227

    (41) array1 -> COL LBRACKET array2 RBRACKET .

    RES_INT         reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_FLOAT       reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_BOOLEAN     reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_STRING      reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_LIST        reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_ARRAY       reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_DEF         reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_START       reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_FUNC        reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_READ        reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_PRINT       reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    ID              reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_IF          reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_SWITCH      reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_WHILE       reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_FOR         reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    $end            reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_END         reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    E_END           reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_ELSE        reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_CASE        reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)
    RPAREN          reduce using rule 41 (array1 -> COL LBRACKET array2 RBRACKET .)


state 228

    (78) forexp -> ID EQUALS cons COL expresion COL ID . EQUALS expresion

    EQUALS          shift and go to state 231


state 229

    (80) ifelse -> RES_ELSE COL bloque .

    E_END           reduce using rule 80 (ifelse -> RES_ELSE COL bloque .)


state 230

    (44) array2 -> cons COMMA array2 .

    RBRACKET        reduce using rule 44 (array2 -> cons COMMA array2 .)


state 231

    (78) forexp -> ID EQUALS cons COL expresion COL ID EQUALS . expresion
    (85) expresion -> . exp expresion_1
    (92) exp -> . termino exp1
    (96) termino -> . factor termino1
    (100) factor -> . LPAREN expresion RPAREN
    (101) factor -> . cons
    (102) factor -> . PLUS cons
    (103) factor -> . MINUS cons
    (104) cons -> . ID
    (105) cons -> . CTE_INT
    (106) cons -> . CTE_FLOAT
    (107) cons -> . consarray
    (108) cons -> . conslist
    (110) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (111) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 105
    PLUS            shift and go to state 109
    MINUS           shift and go to state 107
    ID              shift and go to state 92
    CTE_INT         shift and go to state 91
    CTE_FLOAT       shift and go to state 89

    expresion                      shift and go to state 232
    cons                           shift and go to state 104
    exp                            shift and go to state 111
    consarray                      shift and go to state 88
    conslist                       shift and go to state 90
    termino                        shift and go to state 106
    factor                         shift and go to state 108

state 232

    (78) forexp -> ID EQUALS cons COL expresion COL ID EQUALS expresion .

    RPAREN          reduce using rule 78 (forexp -> ID EQUALS cons COL expresion COL ID EQUALS expresion .)

