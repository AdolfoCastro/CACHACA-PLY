Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    RES_SET
    TAB
    RES_ELIF
    NEW_LINE
    VAR
    AND
    OR

Grammar

Rule 0     S' -> programa
Rule 1     programa -> programa1 generaglo programa2 programa3 main programa3
Rule 2     programa -> empty
Rule 3     generaglo -> <empty>
Rule 4     programa1 -> RES_PROTO prototipos seen_prototipo programa1_1
Rule 5     seen_prototipo -> <empty>
Rule 6     programa1_1 -> programa1
Rule 7     programa1_1 -> empty
Rule 8     programa2 -> programa2 vars
Rule 9     programa2 -> empty
Rule 10    programa3 -> programa3 modulos
Rule 11    programa3 -> empty
Rule 12    prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN
Rule 13    seen_dato -> <empty>
Rule 14    prototipos_1 -> tipo ID prototipos_2
Rule 15    prototipos_2 -> COMMA prototipos_1
Rule 16    prototipos_2 -> empty
Rule 17    dato -> RES_INT
Rule 18    dato -> RES_FLOAT
Rule 19    dato -> RES_DOUBLE
Rule 20    dato -> RES_BOOLEAN
Rule 21    dato -> RES_STRING
Rule 22    tipo -> dato
Rule 23    tipo -> estructura
Rule 24    estructura -> list
Rule 25    estructura -> array
Rule 26    vars -> RES_DEF COL vars1
Rule 27    vars1 -> estructura vars1
Rule 28    vars1 -> dato ID vars2 vars1_1
Rule 29    vars1_1 -> vars1
Rule 30    vars1_1 -> empty
Rule 31    vars2 -> EQUALS cons
Rule 32    vars2 -> vars3
Rule 33    vars3 -> COMMA ID vars3
Rule 34    vars3 -> empty
Rule 35    list -> RES_LIST dato ID list1
Rule 36    list1 -> LCURLY cons_loop RCURLY
Rule 37    list1 -> empty
Rule 38    cons_loop -> cons cons_loop_1
Rule 39    cons_loop_1 -> COMMA cons_loop
Rule 40    cons_loop_1 -> empty
Rule 41    array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1
Rule 42    array1 -> COL LBRACKET array2 RBRACKET
Rule 43    array1 -> empty
Rule 44    array2 -> cons
Rule 45    array2 -> cons COMMA array2
Rule 46    modulos -> prototipos se_uso COL bloque
Rule 47    se_uso -> <empty>
Rule 48    bloque -> estatutos bloque
Rule 49    bloque -> empty
Rule 50    estatutos -> condicion E_END
Rule 51    estatutos -> ciclo E_END
Rule 52    estatutos -> lectura
Rule 53    estatutos -> escritura
Rule 54    estatutos -> asignacion
Rule 55    estatutos -> llamada
Rule 56    estatutos -> vars
Rule 57    ciclo -> while
Rule 58    ciclo -> for
Rule 59    condicion -> if
Rule 60    condicion -> switch
Rule 61    llamada -> ID LPAREN llamada1 RPAREN
Rule 62    llamada1 -> expresion
Rule 63    llamada1 -> empty
Rule 64    lectura -> RES_READ LPAREN tipo RPAREN
Rule 65    escritura -> RES_PRINT LPAREN escritura1 RPAREN
Rule 66    escritura1 -> expresion
Rule 67    escritura1 -> CTE_STRING
Rule 68    asignacion -> ID seen_id_asignacion
Rule 69    seen_id_asignacion -> EQUALS asignacion1
Rule 70    asignacion1 -> exp
Rule 71    asignacion1 -> asignlist
Rule 72    asignacion1 -> asignarray
Rule 73    asignlist -> LCURLY asignlist1 RCURLY
Rule 74    asignlist1 -> cons
Rule 75    asignlist1 -> cons COMMA asignlist1
Rule 76    asignarray -> LBRACKET asignarray1 RBRACKET
Rule 77    asignarray1 -> cons
Rule 78    asignarray1 -> cons COMMA asignarray1
Rule 79    while -> RES_WHILE LPAREN expresion RPAREN COL bloque
Rule 80    for -> RES_FOR LPAREN forexp RPAREN COL bloque
Rule 81    forexp -> ID EQUALS cons COL expresion COL ID EQUALS expresion
Rule 82    if -> RES_IF LPAREN expresion RPAREN COL bloque ifelse
Rule 83    ifelse -> RES_ELSE COL bloque
Rule 84    ifelse -> empty
Rule 85    switch -> RES_SWITCH COL switch2
Rule 86    switch2 -> RES_CASE expresion COL bloque switch2
Rule 87    switch2 -> empty
Rule 88    expresion -> exp expresion_1
Rule 89    expresion_1 -> MIN exp
Rule 90    expresion_1 -> MIN_EQ exp
Rule 91    expresion_1 -> MAY exp
Rule 92    expresion_1 -> MAY_EQ exp
Rule 93    expresion_1 -> DIF exp
Rule 94    expresion_1 -> EQ_EQ exp
Rule 95    expresion_1 -> empty
Rule 96    exp -> termino exp1
Rule 97    exp1 -> PLUS exp
Rule 98    exp1 -> MINUS exp
Rule 99    exp1 -> empty
Rule 100   termino -> factor termino1
Rule 101   termino1 -> TIMES termino
Rule 102   termino1 -> DIVIDE termino
Rule 103   termino1 -> empty
Rule 104   factor -> LPAREN expresion RPAREN
Rule 105   factor -> cons
Rule 106   factor -> PLUS cons
Rule 107   factor -> MINUS cons
Rule 108   cons -> ID exp_1
Rule 109   cons -> CTE_INT exp_2
Rule 110   cons -> CTE_FLOAT exp_3
Rule 111   cons -> CTE_DOUBLE
Rule 112   cons -> CTE_STRING
Rule 113   cons -> RES_TRUE
Rule 114   cons -> RES_FALSE
Rule 115   cons -> consarray
Rule 116   cons -> conslist
Rule 117   exp_1 -> <empty>
Rule 118   exp_2 -> <empty>
Rule 119   exp_3 -> <empty>
Rule 120   main -> RES_START comienza_main COL bloque RES_END
Rule 121   comienza_main -> <empty>
Rule 122   consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons
Rule 123   conslist -> ID EQUALS LCURLY conslist1 RCURLY
Rule 124   conslist1 -> cons
Rule 125   conslist1 -> cons COMMA conslist1
Rule 126   empty -> <empty>

Terminals, with rules where they appear

AND                  : 
COL                  : 26 42 46 79 80 81 81 82 83 85 86 120
COMMA                : 15 33 39 45 75 78 125
CTE_DOUBLE           : 111
CTE_FLOAT            : 110
CTE_INT              : 41 109 122
CTE_STRING           : 67 112
DIF                  : 93
DIVIDE               : 102
EQUALS               : 31 69 81 81 122 123
EQ_EQ                : 94
E_END                : 50 51
ID                   : 12 14 28 33 35 41 61 68 81 81 108 122 123
LBRACKET             : 41 42 76 122
LCURLY               : 36 73 123
LPAREN               : 12 61 64 65 79 80 82 104
MAY                  : 91
MAY_EQ               : 92
MIN                  : 89
MINUS                : 98 107
MIN_EQ               : 90
NEW_LINE             : 
OR                   : 
PLUS                 : 97 106
RBRACKET             : 41 42 76 122
RCURLY               : 36 73 123
RES_ARRAY            : 41
RES_BOOLEAN          : 20
RES_CASE             : 86
RES_DEF              : 26
RES_DOUBLE           : 19
RES_ELIF             : 
RES_ELSE             : 83
RES_END              : 120
RES_FALSE            : 114
RES_FLOAT            : 18
RES_FOR              : 80
RES_FUNC             : 12
RES_IF               : 82
RES_INT              : 17
RES_LIST             : 35
RES_PRINT            : 65
RES_PROTO            : 4
RES_READ             : 64
RES_SET              : 
RES_START            : 120
RES_STRING           : 21
RES_SWITCH           : 85
RES_TRUE             : 113
RES_WHILE            : 79
RPAREN               : 12 61 64 65 79 80 82 104
TAB                  : 
TIMES                : 101
VAR                  : 
error                : 

Nonterminals, with rules where they appear

array                : 25
array1               : 41
array2               : 42 45
asignacion           : 54
asignacion1          : 69
asignarray           : 72
asignarray1          : 76 78
asignlist            : 71
asignlist1           : 73 75
bloque               : 46 48 79 80 82 83 86 120
ciclo                : 51
comienza_main        : 120
condicion            : 50
cons                 : 31 38 44 45 74 75 77 78 81 105 106 107 122 124 125
cons_loop            : 36 39
cons_loop_1          : 38
consarray            : 115
conslist             : 116
conslist1            : 123 125
dato                 : 12 22 28 35 41
empty                : 2 7 9 11 16 30 34 37 40 43 49 63 84 87 95 99 103
escritura            : 53
escritura1           : 65
estatutos            : 48
estructura           : 23 27
exp                  : 70 88 89 90 91 92 93 94 97 98
exp1                 : 96
exp_1                : 108
exp_2                : 109
exp_3                : 110
expresion            : 62 66 79 81 81 82 86 104
expresion_1          : 88
factor               : 100
for                  : 58
forexp               : 80
generaglo            : 1
if                   : 59
ifelse               : 82
lectura              : 52
list                 : 24
list1                : 35
llamada              : 55
llamada1             : 61
main                 : 1
modulos              : 10
programa             : 0
programa1            : 1 6
programa1_1          : 4
programa2            : 1 8
programa3            : 1 1 10
prototipos           : 4 46
prototipos_1         : 12 15
prototipos_2         : 14
se_uso               : 46
seen_dato            : 12
seen_id_asignacion   : 68
seen_prototipo       : 4
switch               : 60
switch2              : 85 86
termino              : 96 101 102
termino1             : 100
tipo                 : 14 64
vars                 : 8 56
vars1                : 26 27 29
vars1_1              : 28
vars2                : 28
vars3                : 32 33
while                : 57

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . programa1 generaglo programa2 programa3 main programa3
    (2) programa -> . empty
    (4) programa1 -> . RES_PROTO prototipos seen_prototipo programa1_1
    (126) empty -> .

    RES_PROTO       shift and go to state 3
    $end            reduce using rule 126 (empty -> .)

    programa1                      shift and go to state 1
    programa                       shift and go to state 2
    empty                          shift and go to state 4

state 1

    (1) programa -> programa1 . generaglo programa2 programa3 main programa3
    (3) generaglo -> .

    RES_DEF         reduce using rule 3 (generaglo -> .)
    RES_START       reduce using rule 3 (generaglo -> .)
    RES_FUNC        reduce using rule 3 (generaglo -> .)

    generaglo                      shift and go to state 5

state 2

    (0) S' -> programa .



state 3

    (4) programa1 -> RES_PROTO . prototipos seen_prototipo programa1_1
    (12) prototipos -> . RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN

    RES_FUNC        shift and go to state 7

    prototipos                     shift and go to state 6

state 4

    (2) programa -> empty .

    $end            reduce using rule 2 (programa -> empty .)


state 5

    (1) programa -> programa1 generaglo . programa2 programa3 main programa3
    (8) programa2 -> . programa2 vars
    (9) programa2 -> . empty
    (126) empty -> .

    RES_DEF         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)

    programa2                      shift and go to state 8
    empty                          shift and go to state 9

state 6

    (4) programa1 -> RES_PROTO prototipos . seen_prototipo programa1_1
    (5) seen_prototipo -> .

    RES_PROTO       reduce using rule 5 (seen_prototipo -> .)
    RES_DEF         reduce using rule 5 (seen_prototipo -> .)
    RES_START       reduce using rule 5 (seen_prototipo -> .)
    RES_FUNC        reduce using rule 5 (seen_prototipo -> .)

    seen_prototipo                 shift and go to state 10

state 7

    (12) prototipos -> RES_FUNC . dato seen_dato ID LPAREN prototipos_1 RPAREN
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13

    dato                           shift and go to state 15

state 8

    (1) programa -> programa1 generaglo programa2 . programa3 main programa3
    (8) programa2 -> programa2 . vars
    (10) programa3 -> . programa3 modulos
    (11) programa3 -> . empty
    (26) vars -> . RES_DEF COL vars1
    (126) empty -> .

    RES_DEF         shift and go to state 19
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)

    vars                           shift and go to state 17
    programa3                      shift and go to state 18
    empty                          shift and go to state 20

state 9

    (9) programa2 -> empty .

    RES_DEF         reduce using rule 9 (programa2 -> empty .)
    RES_START       reduce using rule 9 (programa2 -> empty .)
    RES_FUNC        reduce using rule 9 (programa2 -> empty .)


state 10

    (4) programa1 -> RES_PROTO prototipos seen_prototipo . programa1_1
    (6) programa1_1 -> . programa1
    (7) programa1_1 -> . empty
    (4) programa1 -> . RES_PROTO prototipos seen_prototipo programa1_1
    (126) empty -> .

    RES_PROTO       shift and go to state 3
    RES_DEF         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)

    empty                          shift and go to state 23
    programa1_1                    shift and go to state 22
    programa1                      shift and go to state 21

state 11

    (20) dato -> RES_BOOLEAN .

    ID              reduce using rule 20 (dato -> RES_BOOLEAN .)
    RPAREN          reduce using rule 20 (dato -> RES_BOOLEAN .)


state 12

    (17) dato -> RES_INT .

    ID              reduce using rule 17 (dato -> RES_INT .)
    RPAREN          reduce using rule 17 (dato -> RES_INT .)


state 13

    (21) dato -> RES_STRING .

    ID              reduce using rule 21 (dato -> RES_STRING .)
    RPAREN          reduce using rule 21 (dato -> RES_STRING .)


state 14

    (19) dato -> RES_DOUBLE .

    ID              reduce using rule 19 (dato -> RES_DOUBLE .)
    RPAREN          reduce using rule 19 (dato -> RES_DOUBLE .)


state 15

    (12) prototipos -> RES_FUNC dato . seen_dato ID LPAREN prototipos_1 RPAREN
    (13) seen_dato -> .

    ID              reduce using rule 13 (seen_dato -> .)

    seen_dato                      shift and go to state 24

state 16

    (18) dato -> RES_FLOAT .

    ID              reduce using rule 18 (dato -> RES_FLOAT .)
    RPAREN          reduce using rule 18 (dato -> RES_FLOAT .)


state 17

    (8) programa2 -> programa2 vars .

    RES_DEF         reduce using rule 8 (programa2 -> programa2 vars .)
    RES_START       reduce using rule 8 (programa2 -> programa2 vars .)
    RES_FUNC        reduce using rule 8 (programa2 -> programa2 vars .)


state 18

    (1) programa -> programa1 generaglo programa2 programa3 . main programa3
    (10) programa3 -> programa3 . modulos
    (120) main -> . RES_START comienza_main COL bloque RES_END
    (46) modulos -> . prototipos se_uso COL bloque
    (12) prototipos -> . RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN

    RES_START       shift and go to state 26
    RES_FUNC        shift and go to state 7

    prototipos                     shift and go to state 25
    modulos                        shift and go to state 27
    main                           shift and go to state 28

state 19

    (26) vars -> RES_DEF . COL vars1

    COL             shift and go to state 29


state 20

    (11) programa3 -> empty .

    RES_FUNC        reduce using rule 11 (programa3 -> empty .)
    $end            reduce using rule 11 (programa3 -> empty .)
    RES_START       reduce using rule 11 (programa3 -> empty .)


state 21

    (6) programa1_1 -> programa1 .

    RES_DEF         reduce using rule 6 (programa1_1 -> programa1 .)
    RES_START       reduce using rule 6 (programa1_1 -> programa1 .)
    RES_FUNC        reduce using rule 6 (programa1_1 -> programa1 .)


state 22

    (4) programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .

    RES_DEF         reduce using rule 4 (programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .)
    RES_START       reduce using rule 4 (programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .)
    RES_FUNC        reduce using rule 4 (programa1 -> RES_PROTO prototipos seen_prototipo programa1_1 .)


state 23

    (7) programa1_1 -> empty .

    RES_DEF         reduce using rule 7 (programa1_1 -> empty .)
    RES_START       reduce using rule 7 (programa1_1 -> empty .)
    RES_FUNC        reduce using rule 7 (programa1_1 -> empty .)


state 24

    (12) prototipos -> RES_FUNC dato seen_dato . ID LPAREN prototipos_1 RPAREN

    ID              shift and go to state 30


state 25

    (46) modulos -> prototipos . se_uso COL bloque
    (47) se_uso -> .

    COL             reduce using rule 47 (se_uso -> .)

    se_uso                         shift and go to state 31

state 26

    (120) main -> RES_START . comienza_main COL bloque RES_END
    (121) comienza_main -> .

    COL             reduce using rule 121 (comienza_main -> .)

    comienza_main                  shift and go to state 32

state 27

    (10) programa3 -> programa3 modulos .

    RES_FUNC        reduce using rule 10 (programa3 -> programa3 modulos .)
    $end            reduce using rule 10 (programa3 -> programa3 modulos .)
    RES_START       reduce using rule 10 (programa3 -> programa3 modulos .)


state 28

    (1) programa -> programa1 generaglo programa2 programa3 main . programa3
    (10) programa3 -> . programa3 modulos
    (11) programa3 -> . empty
    (126) empty -> .

    RES_FUNC        reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)

    programa3                      shift and go to state 33
    empty                          shift and go to state 20

state 29

    (26) vars -> RES_DEF COL . vars1
    (27) vars1 -> . estructura vars1
    (28) vars1 -> . dato ID vars2 vars1_1
    (24) estructura -> . list
    (25) estructura -> . array
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING
    (35) list -> . RES_LIST dato ID list1
    (41) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13
    RES_LIST        shift and go to state 37
    RES_ARRAY       shift and go to state 40

    estructura                     shift and go to state 36
    list                           shift and go to state 39
    vars1                          shift and go to state 35
    dato                           shift and go to state 38
    array                          shift and go to state 34

state 30

    (12) prototipos -> RES_FUNC dato seen_dato ID . LPAREN prototipos_1 RPAREN

    LPAREN          shift and go to state 41


state 31

    (46) modulos -> prototipos se_uso . COL bloque

    COL             shift and go to state 42


state 32

    (120) main -> RES_START comienza_main . COL bloque RES_END

    COL             shift and go to state 43


state 33

    (1) programa -> programa1 generaglo programa2 programa3 main programa3 .
    (10) programa3 -> programa3 . modulos
    (46) modulos -> . prototipos se_uso COL bloque
    (12) prototipos -> . RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN

    $end            reduce using rule 1 (programa -> programa1 generaglo programa2 programa3 main programa3 .)
    RES_FUNC        shift and go to state 7

    prototipos                     shift and go to state 25
    modulos                        shift and go to state 27

state 34

    (25) estructura -> array .

    RES_INT         reduce using rule 25 (estructura -> array .)
    RES_FLOAT       reduce using rule 25 (estructura -> array .)
    RES_DOUBLE      reduce using rule 25 (estructura -> array .)
    RES_BOOLEAN     reduce using rule 25 (estructura -> array .)
    RES_STRING      reduce using rule 25 (estructura -> array .)
    RES_LIST        reduce using rule 25 (estructura -> array .)
    RES_ARRAY       reduce using rule 25 (estructura -> array .)
    RPAREN          reduce using rule 25 (estructura -> array .)
    ID              reduce using rule 25 (estructura -> array .)


state 35

    (26) vars -> RES_DEF COL vars1 .

    RES_READ        reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_PRINT       reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    ID              reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_DEF         reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_IF          reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_SWITCH      reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_WHILE       reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_FOR         reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    E_END           reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_CASE        reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_END         reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_ELSE        reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_START       reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    RES_FUNC        reduce using rule 26 (vars -> RES_DEF COL vars1 .)
    $end            reduce using rule 26 (vars -> RES_DEF COL vars1 .)


state 36

    (27) vars1 -> estructura . vars1
    (27) vars1 -> . estructura vars1
    (28) vars1 -> . dato ID vars2 vars1_1
    (24) estructura -> . list
    (25) estructura -> . array
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING
    (35) list -> . RES_LIST dato ID list1
    (41) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13
    RES_LIST        shift and go to state 37
    RES_ARRAY       shift and go to state 40

    list                           shift and go to state 39
    estructura                     shift and go to state 36
    dato                           shift and go to state 38
    vars1                          shift and go to state 44
    array                          shift and go to state 34

state 37

    (35) list -> RES_LIST . dato ID list1
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13

    dato                           shift and go to state 45

state 38

    (28) vars1 -> dato . ID vars2 vars1_1

    ID              shift and go to state 46


state 39

    (24) estructura -> list .

    RES_INT         reduce using rule 24 (estructura -> list .)
    RES_FLOAT       reduce using rule 24 (estructura -> list .)
    RES_DOUBLE      reduce using rule 24 (estructura -> list .)
    RES_BOOLEAN     reduce using rule 24 (estructura -> list .)
    RES_STRING      reduce using rule 24 (estructura -> list .)
    RES_LIST        reduce using rule 24 (estructura -> list .)
    RES_ARRAY       reduce using rule 24 (estructura -> list .)
    RPAREN          reduce using rule 24 (estructura -> list .)
    ID              reduce using rule 24 (estructura -> list .)


state 40

    (41) array -> RES_ARRAY . dato ID LBRACKET CTE_INT RBRACKET array1
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13

    dato                           shift and go to state 47

state 41

    (12) prototipos -> RES_FUNC dato seen_dato ID LPAREN . prototipos_1 RPAREN
    (14) prototipos_1 -> . tipo ID prototipos_2
    (22) tipo -> . dato
    (23) tipo -> . estructura
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING
    (24) estructura -> . list
    (25) estructura -> . array
    (35) list -> . RES_LIST dato ID list1
    (41) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13
    RES_LIST        shift and go to state 37
    RES_ARRAY       shift and go to state 40

    tipo                           shift and go to state 49
    prototipos_1                   shift and go to state 48
    list                           shift and go to state 39
    estructura                     shift and go to state 50
    dato                           shift and go to state 51
    array                          shift and go to state 34

state 42

    (46) modulos -> prototipos se_uso COL . bloque
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 54
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 43

    (120) main -> RES_START comienza_main COL . bloque RES_END
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_END         reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 73
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 44

    (27) vars1 -> estructura vars1 .

    RES_DEF         reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_START       reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_FUNC        reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_READ        reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_PRINT       reduce using rule 27 (vars1 -> estructura vars1 .)
    ID              reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_IF          reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_SWITCH      reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_WHILE       reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_FOR         reduce using rule 27 (vars1 -> estructura vars1 .)
    $end            reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_END         reduce using rule 27 (vars1 -> estructura vars1 .)
    E_END           reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_ELSE        reduce using rule 27 (vars1 -> estructura vars1 .)
    RES_CASE        reduce using rule 27 (vars1 -> estructura vars1 .)


state 45

    (35) list -> RES_LIST dato . ID list1

    ID              shift and go to state 74


state 46

    (28) vars1 -> dato ID . vars2 vars1_1
    (31) vars2 -> . EQUALS cons
    (32) vars2 -> . vars3
    (33) vars3 -> . COMMA ID vars3
    (34) vars3 -> . empty
    (126) empty -> .

    EQUALS          shift and go to state 75
    COMMA           shift and go to state 78
    RES_INT         reduce using rule 126 (empty -> .)
    RES_FLOAT       reduce using rule 126 (empty -> .)
    RES_DOUBLE      reduce using rule 126 (empty -> .)
    RES_BOOLEAN     reduce using rule 126 (empty -> .)
    RES_STRING      reduce using rule 126 (empty -> .)
    RES_LIST        reduce using rule 126 (empty -> .)
    RES_ARRAY       reduce using rule 126 (empty -> .)
    RES_DEF         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    RES_READ        reduce using rule 126 (empty -> .)
    RES_PRINT       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RES_IF          reduce using rule 126 (empty -> .)
    RES_SWITCH      reduce using rule 126 (empty -> .)
    RES_WHILE       reduce using rule 126 (empty -> .)
    RES_FOR         reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_END         reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_ELSE        reduce using rule 126 (empty -> .)
    RES_CASE        reduce using rule 126 (empty -> .)

    vars3                          shift and go to state 76
    vars2                          shift and go to state 77
    empty                          shift and go to state 79

state 47

    (41) array -> RES_ARRAY dato . ID LBRACKET CTE_INT RBRACKET array1

    ID              shift and go to state 80


state 48

    (12) prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 . RPAREN

    RPAREN          shift and go to state 81


state 49

    (14) prototipos_1 -> tipo . ID prototipos_2

    ID              shift and go to state 82


state 50

    (23) tipo -> estructura .

    ID              reduce using rule 23 (tipo -> estructura .)
    RPAREN          reduce using rule 23 (tipo -> estructura .)


state 51

    (22) tipo -> dato .

    ID              reduce using rule 22 (tipo -> dato .)
    RPAREN          reduce using rule 22 (tipo -> dato .)


state 52

    (56) estatutos -> vars .

    RES_READ        reduce using rule 56 (estatutos -> vars .)
    RES_PRINT       reduce using rule 56 (estatutos -> vars .)
    ID              reduce using rule 56 (estatutos -> vars .)
    RES_DEF         reduce using rule 56 (estatutos -> vars .)
    RES_IF          reduce using rule 56 (estatutos -> vars .)
    RES_SWITCH      reduce using rule 56 (estatutos -> vars .)
    RES_WHILE       reduce using rule 56 (estatutos -> vars .)
    RES_FOR         reduce using rule 56 (estatutos -> vars .)
    RES_CASE        reduce using rule 56 (estatutos -> vars .)
    E_END           reduce using rule 56 (estatutos -> vars .)
    RES_ELSE        reduce using rule 56 (estatutos -> vars .)
    RES_END         reduce using rule 56 (estatutos -> vars .)
    RES_START       reduce using rule 56 (estatutos -> vars .)
    RES_FUNC        reduce using rule 56 (estatutos -> vars .)
    $end            reduce using rule 56 (estatutos -> vars .)


state 53

    (80) for -> RES_FOR . LPAREN forexp RPAREN COL bloque

    LPAREN          shift and go to state 83


state 54

    (46) modulos -> prototipos se_uso COL bloque .

    RES_FUNC        reduce using rule 46 (modulos -> prototipos se_uso COL bloque .)
    $end            reduce using rule 46 (modulos -> prototipos se_uso COL bloque .)
    RES_START       reduce using rule 46 (modulos -> prototipos se_uso COL bloque .)


state 55

    (82) if -> RES_IF . LPAREN expresion RPAREN COL bloque ifelse

    LPAREN          shift and go to state 84


state 56

    (59) condicion -> if .

    E_END           reduce using rule 59 (condicion -> if .)


state 57

    (51) estatutos -> ciclo . E_END

    E_END           shift and go to state 85


state 58

    (60) condicion -> switch .

    E_END           reduce using rule 60 (condicion -> switch .)


state 59

    (58) ciclo -> for .

    E_END           reduce using rule 58 (ciclo -> for .)


state 60

    (55) estatutos -> llamada .

    RES_READ        reduce using rule 55 (estatutos -> llamada .)
    RES_PRINT       reduce using rule 55 (estatutos -> llamada .)
    ID              reduce using rule 55 (estatutos -> llamada .)
    RES_DEF         reduce using rule 55 (estatutos -> llamada .)
    RES_IF          reduce using rule 55 (estatutos -> llamada .)
    RES_SWITCH      reduce using rule 55 (estatutos -> llamada .)
    RES_WHILE       reduce using rule 55 (estatutos -> llamada .)
    RES_FOR         reduce using rule 55 (estatutos -> llamada .)
    RES_CASE        reduce using rule 55 (estatutos -> llamada .)
    E_END           reduce using rule 55 (estatutos -> llamada .)
    RES_ELSE        reduce using rule 55 (estatutos -> llamada .)
    RES_END         reduce using rule 55 (estatutos -> llamada .)
    RES_START       reduce using rule 55 (estatutos -> llamada .)
    RES_FUNC        reduce using rule 55 (estatutos -> llamada .)
    $end            reduce using rule 55 (estatutos -> llamada .)


state 61

    (50) estatutos -> condicion . E_END

    E_END           shift and go to state 86


state 62

    (65) escritura -> RES_PRINT . LPAREN escritura1 RPAREN

    LPAREN          shift and go to state 87


state 63

    (52) estatutos -> lectura .

    RES_READ        reduce using rule 52 (estatutos -> lectura .)
    RES_PRINT       reduce using rule 52 (estatutos -> lectura .)
    ID              reduce using rule 52 (estatutos -> lectura .)
    RES_DEF         reduce using rule 52 (estatutos -> lectura .)
    RES_IF          reduce using rule 52 (estatutos -> lectura .)
    RES_SWITCH      reduce using rule 52 (estatutos -> lectura .)
    RES_WHILE       reduce using rule 52 (estatutos -> lectura .)
    RES_FOR         reduce using rule 52 (estatutos -> lectura .)
    RES_CASE        reduce using rule 52 (estatutos -> lectura .)
    E_END           reduce using rule 52 (estatutos -> lectura .)
    RES_ELSE        reduce using rule 52 (estatutos -> lectura .)
    RES_END         reduce using rule 52 (estatutos -> lectura .)
    RES_START       reduce using rule 52 (estatutos -> lectura .)
    RES_FUNC        reduce using rule 52 (estatutos -> lectura .)
    $end            reduce using rule 52 (estatutos -> lectura .)


state 64

    (49) bloque -> empty .

    RES_START       reduce using rule 49 (bloque -> empty .)
    RES_FUNC        reduce using rule 49 (bloque -> empty .)
    $end            reduce using rule 49 (bloque -> empty .)
    E_END           reduce using rule 49 (bloque -> empty .)
    RES_END         reduce using rule 49 (bloque -> empty .)
    RES_ELSE        reduce using rule 49 (bloque -> empty .)
    RES_CASE        reduce using rule 49 (bloque -> empty .)


state 65

    (48) bloque -> estatutos . bloque
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_END         reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_ELSE        reduce using rule 126 (empty -> .)
    RES_CASE        reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 88
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 66

    (79) while -> RES_WHILE . LPAREN expresion RPAREN COL bloque

    LPAREN          shift and go to state 89


state 67

    (68) asignacion -> ID . seen_id_asignacion
    (61) llamada -> ID . LPAREN llamada1 RPAREN
    (69) seen_id_asignacion -> . EQUALS asignacion1

    LPAREN          shift and go to state 92
    EQUALS          shift and go to state 91

    seen_id_asignacion             shift and go to state 90

state 68

    (64) lectura -> RES_READ . LPAREN tipo RPAREN

    LPAREN          shift and go to state 93


state 69

    (54) estatutos -> asignacion .

    RES_READ        reduce using rule 54 (estatutos -> asignacion .)
    RES_PRINT       reduce using rule 54 (estatutos -> asignacion .)
    ID              reduce using rule 54 (estatutos -> asignacion .)
    RES_DEF         reduce using rule 54 (estatutos -> asignacion .)
    RES_IF          reduce using rule 54 (estatutos -> asignacion .)
    RES_SWITCH      reduce using rule 54 (estatutos -> asignacion .)
    RES_WHILE       reduce using rule 54 (estatutos -> asignacion .)
    RES_FOR         reduce using rule 54 (estatutos -> asignacion .)
    RES_CASE        reduce using rule 54 (estatutos -> asignacion .)
    E_END           reduce using rule 54 (estatutos -> asignacion .)
    RES_ELSE        reduce using rule 54 (estatutos -> asignacion .)
    RES_END         reduce using rule 54 (estatutos -> asignacion .)
    RES_START       reduce using rule 54 (estatutos -> asignacion .)
    RES_FUNC        reduce using rule 54 (estatutos -> asignacion .)
    $end            reduce using rule 54 (estatutos -> asignacion .)


state 70

    (85) switch -> RES_SWITCH . COL switch2

    COL             shift and go to state 94


state 71

    (57) ciclo -> while .

    E_END           reduce using rule 57 (ciclo -> while .)


state 72

    (53) estatutos -> escritura .

    RES_READ        reduce using rule 53 (estatutos -> escritura .)
    RES_PRINT       reduce using rule 53 (estatutos -> escritura .)
    ID              reduce using rule 53 (estatutos -> escritura .)
    RES_DEF         reduce using rule 53 (estatutos -> escritura .)
    RES_IF          reduce using rule 53 (estatutos -> escritura .)
    RES_SWITCH      reduce using rule 53 (estatutos -> escritura .)
    RES_WHILE       reduce using rule 53 (estatutos -> escritura .)
    RES_FOR         reduce using rule 53 (estatutos -> escritura .)
    RES_CASE        reduce using rule 53 (estatutos -> escritura .)
    E_END           reduce using rule 53 (estatutos -> escritura .)
    RES_ELSE        reduce using rule 53 (estatutos -> escritura .)
    RES_END         reduce using rule 53 (estatutos -> escritura .)
    RES_START       reduce using rule 53 (estatutos -> escritura .)
    RES_FUNC        reduce using rule 53 (estatutos -> escritura .)
    $end            reduce using rule 53 (estatutos -> escritura .)


state 73

    (120) main -> RES_START comienza_main COL bloque . RES_END

    RES_END         shift and go to state 95


state 74

    (35) list -> RES_LIST dato ID . list1
    (36) list1 -> . LCURLY cons_loop RCURLY
    (37) list1 -> . empty
    (126) empty -> .

    LCURLY          shift and go to state 97
    RES_INT         reduce using rule 126 (empty -> .)
    RES_FLOAT       reduce using rule 126 (empty -> .)
    RES_DOUBLE      reduce using rule 126 (empty -> .)
    RES_BOOLEAN     reduce using rule 126 (empty -> .)
    RES_STRING      reduce using rule 126 (empty -> .)
    RES_LIST        reduce using rule 126 (empty -> .)
    RES_ARRAY       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RPAREN          reduce using rule 126 (empty -> .)

    list1                          shift and go to state 96
    empty                          shift and go to state 98

state 75

    (31) vars2 -> EQUALS . cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    conslist                       shift and go to state 105
    consarray                      shift and go to state 102
    cons                           shift and go to state 100

state 76

    (32) vars2 -> vars3 .

    RES_INT         reduce using rule 32 (vars2 -> vars3 .)
    RES_FLOAT       reduce using rule 32 (vars2 -> vars3 .)
    RES_DOUBLE      reduce using rule 32 (vars2 -> vars3 .)
    RES_BOOLEAN     reduce using rule 32 (vars2 -> vars3 .)
    RES_STRING      reduce using rule 32 (vars2 -> vars3 .)
    RES_LIST        reduce using rule 32 (vars2 -> vars3 .)
    RES_ARRAY       reduce using rule 32 (vars2 -> vars3 .)
    RES_DEF         reduce using rule 32 (vars2 -> vars3 .)
    RES_START       reduce using rule 32 (vars2 -> vars3 .)
    RES_FUNC        reduce using rule 32 (vars2 -> vars3 .)
    RES_READ        reduce using rule 32 (vars2 -> vars3 .)
    RES_PRINT       reduce using rule 32 (vars2 -> vars3 .)
    ID              reduce using rule 32 (vars2 -> vars3 .)
    RES_IF          reduce using rule 32 (vars2 -> vars3 .)
    RES_SWITCH      reduce using rule 32 (vars2 -> vars3 .)
    RES_WHILE       reduce using rule 32 (vars2 -> vars3 .)
    RES_FOR         reduce using rule 32 (vars2 -> vars3 .)
    $end            reduce using rule 32 (vars2 -> vars3 .)
    RES_END         reduce using rule 32 (vars2 -> vars3 .)
    E_END           reduce using rule 32 (vars2 -> vars3 .)
    RES_ELSE        reduce using rule 32 (vars2 -> vars3 .)
    RES_CASE        reduce using rule 32 (vars2 -> vars3 .)


state 77

    (28) vars1 -> dato ID vars2 . vars1_1
    (29) vars1_1 -> . vars1
    (30) vars1_1 -> . empty
    (27) vars1 -> . estructura vars1
    (28) vars1 -> . dato ID vars2 vars1_1
    (126) empty -> .
    (24) estructura -> . list
    (25) estructura -> . array
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING
    (35) list -> . RES_LIST dato ID list1
    (41) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_DEF         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    RES_READ        reduce using rule 126 (empty -> .)
    RES_PRINT       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RES_IF          reduce using rule 126 (empty -> .)
    RES_SWITCH      reduce using rule 126 (empty -> .)
    RES_WHILE       reduce using rule 126 (empty -> .)
    RES_FOR         reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_END         reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_ELSE        reduce using rule 126 (empty -> .)
    RES_CASE        reduce using rule 126 (empty -> .)
    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13
    RES_LIST        shift and go to state 37
    RES_ARRAY       shift and go to state 40

    list                           shift and go to state 39
    estructura                     shift and go to state 36
    dato                           shift and go to state 38
    vars1                          shift and go to state 109
    vars1_1                        shift and go to state 110
    array                          shift and go to state 34
    empty                          shift and go to state 111

state 78

    (33) vars3 -> COMMA . ID vars3

    ID              shift and go to state 112


state 79

    (34) vars3 -> empty .

    RES_INT         reduce using rule 34 (vars3 -> empty .)
    RES_FLOAT       reduce using rule 34 (vars3 -> empty .)
    RES_DOUBLE      reduce using rule 34 (vars3 -> empty .)
    RES_BOOLEAN     reduce using rule 34 (vars3 -> empty .)
    RES_STRING      reduce using rule 34 (vars3 -> empty .)
    RES_LIST        reduce using rule 34 (vars3 -> empty .)
    RES_ARRAY       reduce using rule 34 (vars3 -> empty .)
    RES_DEF         reduce using rule 34 (vars3 -> empty .)
    RES_START       reduce using rule 34 (vars3 -> empty .)
    RES_FUNC        reduce using rule 34 (vars3 -> empty .)
    RES_READ        reduce using rule 34 (vars3 -> empty .)
    RES_PRINT       reduce using rule 34 (vars3 -> empty .)
    ID              reduce using rule 34 (vars3 -> empty .)
    RES_IF          reduce using rule 34 (vars3 -> empty .)
    RES_SWITCH      reduce using rule 34 (vars3 -> empty .)
    RES_WHILE       reduce using rule 34 (vars3 -> empty .)
    RES_FOR         reduce using rule 34 (vars3 -> empty .)
    $end            reduce using rule 34 (vars3 -> empty .)
    RES_END         reduce using rule 34 (vars3 -> empty .)
    E_END           reduce using rule 34 (vars3 -> empty .)
    RES_ELSE        reduce using rule 34 (vars3 -> empty .)
    RES_CASE        reduce using rule 34 (vars3 -> empty .)


state 80

    (41) array -> RES_ARRAY dato ID . LBRACKET CTE_INT RBRACKET array1

    LBRACKET        shift and go to state 113


state 81

    (12) prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .

    RES_PROTO       reduce using rule 12 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_DEF         reduce using rule 12 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_START       reduce using rule 12 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    RES_FUNC        reduce using rule 12 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)
    COL             reduce using rule 12 (prototipos -> RES_FUNC dato seen_dato ID LPAREN prototipos_1 RPAREN .)


state 82

    (14) prototipos_1 -> tipo ID . prototipos_2
    (15) prototipos_2 -> . COMMA prototipos_1
    (16) prototipos_2 -> . empty
    (126) empty -> .

    COMMA           shift and go to state 115
    RPAREN          reduce using rule 126 (empty -> .)

    prototipos_2                   shift and go to state 114
    empty                          shift and go to state 116

state 83

    (80) for -> RES_FOR LPAREN . forexp RPAREN COL bloque
    (81) forexp -> . ID EQUALS cons COL expresion COL ID EQUALS expresion

    ID              shift and go to state 117

    forexp                         shift and go to state 118

state 84

    (82) if -> RES_IF LPAREN . expresion RPAREN COL bloque ifelse
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 125
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 85

    (51) estatutos -> ciclo E_END .

    RES_READ        reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_PRINT       reduce using rule 51 (estatutos -> ciclo E_END .)
    ID              reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_DEF         reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_IF          reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_SWITCH      reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_WHILE       reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_FOR         reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_CASE        reduce using rule 51 (estatutos -> ciclo E_END .)
    E_END           reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_ELSE        reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_END         reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_START       reduce using rule 51 (estatutos -> ciclo E_END .)
    RES_FUNC        reduce using rule 51 (estatutos -> ciclo E_END .)
    $end            reduce using rule 51 (estatutos -> ciclo E_END .)


state 86

    (50) estatutos -> condicion E_END .

    RES_READ        reduce using rule 50 (estatutos -> condicion E_END .)
    RES_PRINT       reduce using rule 50 (estatutos -> condicion E_END .)
    ID              reduce using rule 50 (estatutos -> condicion E_END .)
    RES_DEF         reduce using rule 50 (estatutos -> condicion E_END .)
    RES_IF          reduce using rule 50 (estatutos -> condicion E_END .)
    RES_SWITCH      reduce using rule 50 (estatutos -> condicion E_END .)
    RES_WHILE       reduce using rule 50 (estatutos -> condicion E_END .)
    RES_FOR         reduce using rule 50 (estatutos -> condicion E_END .)
    RES_CASE        reduce using rule 50 (estatutos -> condicion E_END .)
    E_END           reduce using rule 50 (estatutos -> condicion E_END .)
    RES_ELSE        reduce using rule 50 (estatutos -> condicion E_END .)
    RES_END         reduce using rule 50 (estatutos -> condicion E_END .)
    RES_START       reduce using rule 50 (estatutos -> condicion E_END .)
    RES_FUNC        reduce using rule 50 (estatutos -> condicion E_END .)
    $end            reduce using rule 50 (estatutos -> condicion E_END .)


state 87

    (65) escritura -> RES_PRINT LPAREN . escritura1 RPAREN
    (66) escritura1 -> . expresion
    (67) escritura1 -> . CTE_STRING
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    CTE_STRING      shift and go to state 127
    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 129
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    escritura1                     shift and go to state 128
    consarray                      shift and go to state 102

state 88

    (48) bloque -> estatutos bloque .

    RES_START       reduce using rule 48 (bloque -> estatutos bloque .)
    RES_FUNC        reduce using rule 48 (bloque -> estatutos bloque .)
    $end            reduce using rule 48 (bloque -> estatutos bloque .)
    E_END           reduce using rule 48 (bloque -> estatutos bloque .)
    RES_END         reduce using rule 48 (bloque -> estatutos bloque .)
    RES_ELSE        reduce using rule 48 (bloque -> estatutos bloque .)
    RES_CASE        reduce using rule 48 (bloque -> estatutos bloque .)


state 89

    (79) while -> RES_WHILE LPAREN . expresion RPAREN COL bloque
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 130
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 90

    (68) asignacion -> ID seen_id_asignacion .

    RES_READ        reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_PRINT       reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    ID              reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_DEF         reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_IF          reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_SWITCH      reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_WHILE       reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_FOR         reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_START       reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_FUNC        reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    $end            reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_END         reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    E_END           reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_ELSE        reduce using rule 68 (asignacion -> ID seen_id_asignacion .)
    RES_CASE        reduce using rule 68 (asignacion -> ID seen_id_asignacion .)


state 91

    (69) seen_id_asignacion -> EQUALS . asignacion1
    (70) asignacion1 -> . exp
    (71) asignacion1 -> . asignlist
    (72) asignacion1 -> . asignarray
    (96) exp -> . termino exp1
    (73) asignlist -> . LCURLY asignlist1 RCURLY
    (76) asignarray -> . LBRACKET asignarray1 RBRACKET
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LCURLY          shift and go to state 132
    LBRACKET        shift and go to state 131
    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    asignarray                     shift and go to state 133
    factor                         shift and go to state 123
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 135
    asignlist                      shift and go to state 134
    asignacion1                    shift and go to state 136
    consarray                      shift and go to state 102

state 92

    (61) llamada -> ID LPAREN . llamada1 RPAREN
    (62) llamada1 -> . expresion
    (63) llamada1 -> . empty
    (88) expresion -> . exp expresion_1
    (126) empty -> .
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    RPAREN          reduce using rule 126 (empty -> .)
    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 139
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    llamada1                       shift and go to state 137
    empty                          shift and go to state 138
    consarray                      shift and go to state 102

state 93

    (64) lectura -> RES_READ LPAREN . tipo RPAREN
    (22) tipo -> . dato
    (23) tipo -> . estructura
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING
    (24) estructura -> . list
    (25) estructura -> . array
    (35) list -> . RES_LIST dato ID list1
    (41) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13
    RES_LIST        shift and go to state 37
    RES_ARRAY       shift and go to state 40

    tipo                           shift and go to state 140
    list                           shift and go to state 39
    estructura                     shift and go to state 50
    dato                           shift and go to state 51
    array                          shift and go to state 34

state 94

    (85) switch -> RES_SWITCH COL . switch2
    (86) switch2 -> . RES_CASE expresion COL bloque switch2
    (87) switch2 -> . empty
    (126) empty -> .

    RES_CASE        shift and go to state 142
    E_END           reduce using rule 126 (empty -> .)

    switch2                        shift and go to state 141
    empty                          shift and go to state 143

state 95

    (120) main -> RES_START comienza_main COL bloque RES_END .

    RES_FUNC        reduce using rule 120 (main -> RES_START comienza_main COL bloque RES_END .)
    $end            reduce using rule 120 (main -> RES_START comienza_main COL bloque RES_END .)


state 96

    (35) list -> RES_LIST dato ID list1 .

    ID              reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_INT         reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_FLOAT       reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_DOUBLE      reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_BOOLEAN     reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_STRING      reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_LIST        reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RES_ARRAY       reduce using rule 35 (list -> RES_LIST dato ID list1 .)
    RPAREN          reduce using rule 35 (list -> RES_LIST dato ID list1 .)


state 97

    (36) list1 -> LCURLY . cons_loop RCURLY
    (38) cons_loop -> . cons cons_loop_1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 144
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105
    cons_loop                      shift and go to state 145

state 98

    (37) list1 -> empty .

    RES_INT         reduce using rule 37 (list1 -> empty .)
    RES_FLOAT       reduce using rule 37 (list1 -> empty .)
    RES_DOUBLE      reduce using rule 37 (list1 -> empty .)
    RES_BOOLEAN     reduce using rule 37 (list1 -> empty .)
    RES_STRING      reduce using rule 37 (list1 -> empty .)
    RES_LIST        reduce using rule 37 (list1 -> empty .)
    RES_ARRAY       reduce using rule 37 (list1 -> empty .)
    ID              reduce using rule 37 (list1 -> empty .)
    RPAREN          reduce using rule 37 (list1 -> empty .)


state 99

    (112) cons -> CTE_STRING .

    TIMES           reduce using rule 112 (cons -> CTE_STRING .)
    DIVIDE          reduce using rule 112 (cons -> CTE_STRING .)
    PLUS            reduce using rule 112 (cons -> CTE_STRING .)
    MINUS           reduce using rule 112 (cons -> CTE_STRING .)
    MIN             reduce using rule 112 (cons -> CTE_STRING .)
    MIN_EQ          reduce using rule 112 (cons -> CTE_STRING .)
    MAY             reduce using rule 112 (cons -> CTE_STRING .)
    MAY_EQ          reduce using rule 112 (cons -> CTE_STRING .)
    DIF             reduce using rule 112 (cons -> CTE_STRING .)
    EQ_EQ           reduce using rule 112 (cons -> CTE_STRING .)
    RPAREN          reduce using rule 112 (cons -> CTE_STRING .)
    RES_READ        reduce using rule 112 (cons -> CTE_STRING .)
    RES_PRINT       reduce using rule 112 (cons -> CTE_STRING .)
    ID              reduce using rule 112 (cons -> CTE_STRING .)
    RES_DEF         reduce using rule 112 (cons -> CTE_STRING .)
    RES_IF          reduce using rule 112 (cons -> CTE_STRING .)
    RES_SWITCH      reduce using rule 112 (cons -> CTE_STRING .)
    RES_WHILE       reduce using rule 112 (cons -> CTE_STRING .)
    RES_FOR         reduce using rule 112 (cons -> CTE_STRING .)
    RES_START       reduce using rule 112 (cons -> CTE_STRING .)
    RES_FUNC        reduce using rule 112 (cons -> CTE_STRING .)
    $end            reduce using rule 112 (cons -> CTE_STRING .)
    RES_END         reduce using rule 112 (cons -> CTE_STRING .)
    E_END           reduce using rule 112 (cons -> CTE_STRING .)
    RES_ELSE        reduce using rule 112 (cons -> CTE_STRING .)
    RES_CASE        reduce using rule 112 (cons -> CTE_STRING .)
    COL             reduce using rule 112 (cons -> CTE_STRING .)
    RES_INT         reduce using rule 112 (cons -> CTE_STRING .)
    RES_FLOAT       reduce using rule 112 (cons -> CTE_STRING .)
    RES_DOUBLE      reduce using rule 112 (cons -> CTE_STRING .)
    RES_BOOLEAN     reduce using rule 112 (cons -> CTE_STRING .)
    RES_STRING      reduce using rule 112 (cons -> CTE_STRING .)
    RES_LIST        reduce using rule 112 (cons -> CTE_STRING .)
    RES_ARRAY       reduce using rule 112 (cons -> CTE_STRING .)
    COMMA           reduce using rule 112 (cons -> CTE_STRING .)
    RCURLY          reduce using rule 112 (cons -> CTE_STRING .)
    RBRACKET        reduce using rule 112 (cons -> CTE_STRING .)


state 100

    (31) vars2 -> EQUALS cons .

    RES_INT         reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_FLOAT       reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_DOUBLE      reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_BOOLEAN     reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_STRING      reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_LIST        reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_ARRAY       reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_DEF         reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_START       reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_FUNC        reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_READ        reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_PRINT       reduce using rule 31 (vars2 -> EQUALS cons .)
    ID              reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_IF          reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_SWITCH      reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_WHILE       reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_FOR         reduce using rule 31 (vars2 -> EQUALS cons .)
    $end            reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_END         reduce using rule 31 (vars2 -> EQUALS cons .)
    E_END           reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_ELSE        reduce using rule 31 (vars2 -> EQUALS cons .)
    RES_CASE        reduce using rule 31 (vars2 -> EQUALS cons .)


state 101

    (111) cons -> CTE_DOUBLE .

    TIMES           reduce using rule 111 (cons -> CTE_DOUBLE .)
    DIVIDE          reduce using rule 111 (cons -> CTE_DOUBLE .)
    PLUS            reduce using rule 111 (cons -> CTE_DOUBLE .)
    MINUS           reduce using rule 111 (cons -> CTE_DOUBLE .)
    MIN             reduce using rule 111 (cons -> CTE_DOUBLE .)
    MIN_EQ          reduce using rule 111 (cons -> CTE_DOUBLE .)
    MAY             reduce using rule 111 (cons -> CTE_DOUBLE .)
    MAY_EQ          reduce using rule 111 (cons -> CTE_DOUBLE .)
    DIF             reduce using rule 111 (cons -> CTE_DOUBLE .)
    EQ_EQ           reduce using rule 111 (cons -> CTE_DOUBLE .)
    RPAREN          reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_READ        reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_PRINT       reduce using rule 111 (cons -> CTE_DOUBLE .)
    ID              reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_DEF         reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_IF          reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_SWITCH      reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_WHILE       reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_FOR         reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_START       reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_FUNC        reduce using rule 111 (cons -> CTE_DOUBLE .)
    $end            reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_END         reduce using rule 111 (cons -> CTE_DOUBLE .)
    E_END           reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_ELSE        reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_CASE        reduce using rule 111 (cons -> CTE_DOUBLE .)
    COL             reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_INT         reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_FLOAT       reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_DOUBLE      reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_BOOLEAN     reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_STRING      reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_LIST        reduce using rule 111 (cons -> CTE_DOUBLE .)
    RES_ARRAY       reduce using rule 111 (cons -> CTE_DOUBLE .)
    COMMA           reduce using rule 111 (cons -> CTE_DOUBLE .)
    RCURLY          reduce using rule 111 (cons -> CTE_DOUBLE .)
    RBRACKET        reduce using rule 111 (cons -> CTE_DOUBLE .)


state 102

    (115) cons -> consarray .

    TIMES           reduce using rule 115 (cons -> consarray .)
    DIVIDE          reduce using rule 115 (cons -> consarray .)
    PLUS            reduce using rule 115 (cons -> consarray .)
    MINUS           reduce using rule 115 (cons -> consarray .)
    MIN             reduce using rule 115 (cons -> consarray .)
    MIN_EQ          reduce using rule 115 (cons -> consarray .)
    MAY             reduce using rule 115 (cons -> consarray .)
    MAY_EQ          reduce using rule 115 (cons -> consarray .)
    DIF             reduce using rule 115 (cons -> consarray .)
    EQ_EQ           reduce using rule 115 (cons -> consarray .)
    RPAREN          reduce using rule 115 (cons -> consarray .)
    RES_READ        reduce using rule 115 (cons -> consarray .)
    RES_PRINT       reduce using rule 115 (cons -> consarray .)
    ID              reduce using rule 115 (cons -> consarray .)
    RES_DEF         reduce using rule 115 (cons -> consarray .)
    RES_IF          reduce using rule 115 (cons -> consarray .)
    RES_SWITCH      reduce using rule 115 (cons -> consarray .)
    RES_WHILE       reduce using rule 115 (cons -> consarray .)
    RES_FOR         reduce using rule 115 (cons -> consarray .)
    RES_START       reduce using rule 115 (cons -> consarray .)
    RES_FUNC        reduce using rule 115 (cons -> consarray .)
    $end            reduce using rule 115 (cons -> consarray .)
    RES_END         reduce using rule 115 (cons -> consarray .)
    E_END           reduce using rule 115 (cons -> consarray .)
    RES_ELSE        reduce using rule 115 (cons -> consarray .)
    RES_CASE        reduce using rule 115 (cons -> consarray .)
    COL             reduce using rule 115 (cons -> consarray .)
    RES_INT         reduce using rule 115 (cons -> consarray .)
    RES_FLOAT       reduce using rule 115 (cons -> consarray .)
    RES_DOUBLE      reduce using rule 115 (cons -> consarray .)
    RES_BOOLEAN     reduce using rule 115 (cons -> consarray .)
    RES_STRING      reduce using rule 115 (cons -> consarray .)
    RES_LIST        reduce using rule 115 (cons -> consarray .)
    RES_ARRAY       reduce using rule 115 (cons -> consarray .)
    COMMA           reduce using rule 115 (cons -> consarray .)
    RCURLY          reduce using rule 115 (cons -> consarray .)
    RBRACKET        reduce using rule 115 (cons -> consarray .)


state 103

    (110) cons -> CTE_FLOAT . exp_3
    (119) exp_3 -> .

    RES_INT         reduce using rule 119 (exp_3 -> .)
    RES_FLOAT       reduce using rule 119 (exp_3 -> .)
    RES_DOUBLE      reduce using rule 119 (exp_3 -> .)
    RES_BOOLEAN     reduce using rule 119 (exp_3 -> .)
    RES_STRING      reduce using rule 119 (exp_3 -> .)
    RES_LIST        reduce using rule 119 (exp_3 -> .)
    RES_ARRAY       reduce using rule 119 (exp_3 -> .)
    RES_DEF         reduce using rule 119 (exp_3 -> .)
    RES_START       reduce using rule 119 (exp_3 -> .)
    RES_FUNC        reduce using rule 119 (exp_3 -> .)
    RES_READ        reduce using rule 119 (exp_3 -> .)
    RES_PRINT       reduce using rule 119 (exp_3 -> .)
    ID              reduce using rule 119 (exp_3 -> .)
    RES_IF          reduce using rule 119 (exp_3 -> .)
    RES_SWITCH      reduce using rule 119 (exp_3 -> .)
    RES_WHILE       reduce using rule 119 (exp_3 -> .)
    RES_FOR         reduce using rule 119 (exp_3 -> .)
    $end            reduce using rule 119 (exp_3 -> .)
    RES_END         reduce using rule 119 (exp_3 -> .)
    E_END           reduce using rule 119 (exp_3 -> .)
    RES_ELSE        reduce using rule 119 (exp_3 -> .)
    RES_CASE        reduce using rule 119 (exp_3 -> .)
    TIMES           reduce using rule 119 (exp_3 -> .)
    DIVIDE          reduce using rule 119 (exp_3 -> .)
    PLUS            reduce using rule 119 (exp_3 -> .)
    MINUS           reduce using rule 119 (exp_3 -> .)
    MIN             reduce using rule 119 (exp_3 -> .)
    MIN_EQ          reduce using rule 119 (exp_3 -> .)
    MAY             reduce using rule 119 (exp_3 -> .)
    MAY_EQ          reduce using rule 119 (exp_3 -> .)
    DIF             reduce using rule 119 (exp_3 -> .)
    EQ_EQ           reduce using rule 119 (exp_3 -> .)
    RPAREN          reduce using rule 119 (exp_3 -> .)
    COMMA           reduce using rule 119 (exp_3 -> .)
    RCURLY          reduce using rule 119 (exp_3 -> .)
    COL             reduce using rule 119 (exp_3 -> .)
    RBRACKET        reduce using rule 119 (exp_3 -> .)

    exp_3                          shift and go to state 146

state 104

    (113) cons -> RES_TRUE .

    TIMES           reduce using rule 113 (cons -> RES_TRUE .)
    DIVIDE          reduce using rule 113 (cons -> RES_TRUE .)
    PLUS            reduce using rule 113 (cons -> RES_TRUE .)
    MINUS           reduce using rule 113 (cons -> RES_TRUE .)
    MIN             reduce using rule 113 (cons -> RES_TRUE .)
    MIN_EQ          reduce using rule 113 (cons -> RES_TRUE .)
    MAY             reduce using rule 113 (cons -> RES_TRUE .)
    MAY_EQ          reduce using rule 113 (cons -> RES_TRUE .)
    DIF             reduce using rule 113 (cons -> RES_TRUE .)
    EQ_EQ           reduce using rule 113 (cons -> RES_TRUE .)
    RPAREN          reduce using rule 113 (cons -> RES_TRUE .)
    RES_READ        reduce using rule 113 (cons -> RES_TRUE .)
    RES_PRINT       reduce using rule 113 (cons -> RES_TRUE .)
    ID              reduce using rule 113 (cons -> RES_TRUE .)
    RES_DEF         reduce using rule 113 (cons -> RES_TRUE .)
    RES_IF          reduce using rule 113 (cons -> RES_TRUE .)
    RES_SWITCH      reduce using rule 113 (cons -> RES_TRUE .)
    RES_WHILE       reduce using rule 113 (cons -> RES_TRUE .)
    RES_FOR         reduce using rule 113 (cons -> RES_TRUE .)
    RES_START       reduce using rule 113 (cons -> RES_TRUE .)
    RES_FUNC        reduce using rule 113 (cons -> RES_TRUE .)
    $end            reduce using rule 113 (cons -> RES_TRUE .)
    RES_END         reduce using rule 113 (cons -> RES_TRUE .)
    E_END           reduce using rule 113 (cons -> RES_TRUE .)
    RES_ELSE        reduce using rule 113 (cons -> RES_TRUE .)
    RES_CASE        reduce using rule 113 (cons -> RES_TRUE .)
    COL             reduce using rule 113 (cons -> RES_TRUE .)
    RES_INT         reduce using rule 113 (cons -> RES_TRUE .)
    RES_FLOAT       reduce using rule 113 (cons -> RES_TRUE .)
    RES_DOUBLE      reduce using rule 113 (cons -> RES_TRUE .)
    RES_BOOLEAN     reduce using rule 113 (cons -> RES_TRUE .)
    RES_STRING      reduce using rule 113 (cons -> RES_TRUE .)
    RES_LIST        reduce using rule 113 (cons -> RES_TRUE .)
    RES_ARRAY       reduce using rule 113 (cons -> RES_TRUE .)
    COMMA           reduce using rule 113 (cons -> RES_TRUE .)
    RCURLY          reduce using rule 113 (cons -> RES_TRUE .)
    RBRACKET        reduce using rule 113 (cons -> RES_TRUE .)


state 105

    (116) cons -> conslist .

    TIMES           reduce using rule 116 (cons -> conslist .)
    DIVIDE          reduce using rule 116 (cons -> conslist .)
    PLUS            reduce using rule 116 (cons -> conslist .)
    MINUS           reduce using rule 116 (cons -> conslist .)
    MIN             reduce using rule 116 (cons -> conslist .)
    MIN_EQ          reduce using rule 116 (cons -> conslist .)
    MAY             reduce using rule 116 (cons -> conslist .)
    MAY_EQ          reduce using rule 116 (cons -> conslist .)
    DIF             reduce using rule 116 (cons -> conslist .)
    EQ_EQ           reduce using rule 116 (cons -> conslist .)
    RPAREN          reduce using rule 116 (cons -> conslist .)
    RES_READ        reduce using rule 116 (cons -> conslist .)
    RES_PRINT       reduce using rule 116 (cons -> conslist .)
    ID              reduce using rule 116 (cons -> conslist .)
    RES_DEF         reduce using rule 116 (cons -> conslist .)
    RES_IF          reduce using rule 116 (cons -> conslist .)
    RES_SWITCH      reduce using rule 116 (cons -> conslist .)
    RES_WHILE       reduce using rule 116 (cons -> conslist .)
    RES_FOR         reduce using rule 116 (cons -> conslist .)
    RES_START       reduce using rule 116 (cons -> conslist .)
    RES_FUNC        reduce using rule 116 (cons -> conslist .)
    $end            reduce using rule 116 (cons -> conslist .)
    RES_END         reduce using rule 116 (cons -> conslist .)
    E_END           reduce using rule 116 (cons -> conslist .)
    RES_ELSE        reduce using rule 116 (cons -> conslist .)
    RES_CASE        reduce using rule 116 (cons -> conslist .)
    COL             reduce using rule 116 (cons -> conslist .)
    RES_INT         reduce using rule 116 (cons -> conslist .)
    RES_FLOAT       reduce using rule 116 (cons -> conslist .)
    RES_DOUBLE      reduce using rule 116 (cons -> conslist .)
    RES_BOOLEAN     reduce using rule 116 (cons -> conslist .)
    RES_STRING      reduce using rule 116 (cons -> conslist .)
    RES_LIST        reduce using rule 116 (cons -> conslist .)
    RES_ARRAY       reduce using rule 116 (cons -> conslist .)
    COMMA           reduce using rule 116 (cons -> conslist .)
    RCURLY          reduce using rule 116 (cons -> conslist .)
    RBRACKET        reduce using rule 116 (cons -> conslist .)


state 106

    (109) cons -> CTE_INT . exp_2
    (118) exp_2 -> .

    RES_INT         reduce using rule 118 (exp_2 -> .)
    RES_FLOAT       reduce using rule 118 (exp_2 -> .)
    RES_DOUBLE      reduce using rule 118 (exp_2 -> .)
    RES_BOOLEAN     reduce using rule 118 (exp_2 -> .)
    RES_STRING      reduce using rule 118 (exp_2 -> .)
    RES_LIST        reduce using rule 118 (exp_2 -> .)
    RES_ARRAY       reduce using rule 118 (exp_2 -> .)
    RES_DEF         reduce using rule 118 (exp_2 -> .)
    RES_START       reduce using rule 118 (exp_2 -> .)
    RES_FUNC        reduce using rule 118 (exp_2 -> .)
    RES_READ        reduce using rule 118 (exp_2 -> .)
    RES_PRINT       reduce using rule 118 (exp_2 -> .)
    ID              reduce using rule 118 (exp_2 -> .)
    RES_IF          reduce using rule 118 (exp_2 -> .)
    RES_SWITCH      reduce using rule 118 (exp_2 -> .)
    RES_WHILE       reduce using rule 118 (exp_2 -> .)
    RES_FOR         reduce using rule 118 (exp_2 -> .)
    $end            reduce using rule 118 (exp_2 -> .)
    RES_END         reduce using rule 118 (exp_2 -> .)
    E_END           reduce using rule 118 (exp_2 -> .)
    RES_ELSE        reduce using rule 118 (exp_2 -> .)
    RES_CASE        reduce using rule 118 (exp_2 -> .)
    TIMES           reduce using rule 118 (exp_2 -> .)
    DIVIDE          reduce using rule 118 (exp_2 -> .)
    PLUS            reduce using rule 118 (exp_2 -> .)
    MINUS           reduce using rule 118 (exp_2 -> .)
    MIN             reduce using rule 118 (exp_2 -> .)
    MIN_EQ          reduce using rule 118 (exp_2 -> .)
    MAY             reduce using rule 118 (exp_2 -> .)
    MAY_EQ          reduce using rule 118 (exp_2 -> .)
    DIF             reduce using rule 118 (exp_2 -> .)
    EQ_EQ           reduce using rule 118 (exp_2 -> .)
    RPAREN          reduce using rule 118 (exp_2 -> .)
    COMMA           reduce using rule 118 (exp_2 -> .)
    RCURLY          reduce using rule 118 (exp_2 -> .)
    COL             reduce using rule 118 (exp_2 -> .)
    RBRACKET        reduce using rule 118 (exp_2 -> .)

    exp_2                          shift and go to state 147

state 107

    (108) cons -> ID . exp_1
    (122) consarray -> ID . LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> ID . EQUALS LCURLY conslist1 RCURLY
    (117) exp_1 -> .

    LBRACKET        shift and go to state 149
    EQUALS          shift and go to state 148
    RES_INT         reduce using rule 117 (exp_1 -> .)
    RES_FLOAT       reduce using rule 117 (exp_1 -> .)
    RES_DOUBLE      reduce using rule 117 (exp_1 -> .)
    RES_BOOLEAN     reduce using rule 117 (exp_1 -> .)
    RES_STRING      reduce using rule 117 (exp_1 -> .)
    RES_LIST        reduce using rule 117 (exp_1 -> .)
    RES_ARRAY       reduce using rule 117 (exp_1 -> .)
    RES_DEF         reduce using rule 117 (exp_1 -> .)
    RES_START       reduce using rule 117 (exp_1 -> .)
    RES_FUNC        reduce using rule 117 (exp_1 -> .)
    RES_READ        reduce using rule 117 (exp_1 -> .)
    RES_PRINT       reduce using rule 117 (exp_1 -> .)
    ID              reduce using rule 117 (exp_1 -> .)
    RES_IF          reduce using rule 117 (exp_1 -> .)
    RES_SWITCH      reduce using rule 117 (exp_1 -> .)
    RES_WHILE       reduce using rule 117 (exp_1 -> .)
    RES_FOR         reduce using rule 117 (exp_1 -> .)
    $end            reduce using rule 117 (exp_1 -> .)
    RES_END         reduce using rule 117 (exp_1 -> .)
    E_END           reduce using rule 117 (exp_1 -> .)
    RES_ELSE        reduce using rule 117 (exp_1 -> .)
    RES_CASE        reduce using rule 117 (exp_1 -> .)
    TIMES           reduce using rule 117 (exp_1 -> .)
    DIVIDE          reduce using rule 117 (exp_1 -> .)
    PLUS            reduce using rule 117 (exp_1 -> .)
    MINUS           reduce using rule 117 (exp_1 -> .)
    MIN             reduce using rule 117 (exp_1 -> .)
    MIN_EQ          reduce using rule 117 (exp_1 -> .)
    MAY             reduce using rule 117 (exp_1 -> .)
    MAY_EQ          reduce using rule 117 (exp_1 -> .)
    DIF             reduce using rule 117 (exp_1 -> .)
    EQ_EQ           reduce using rule 117 (exp_1 -> .)
    RPAREN          reduce using rule 117 (exp_1 -> .)
    COMMA           reduce using rule 117 (exp_1 -> .)
    RCURLY          reduce using rule 117 (exp_1 -> .)
    COL             reduce using rule 117 (exp_1 -> .)
    RBRACKET        reduce using rule 117 (exp_1 -> .)

    exp_1                          shift and go to state 150

state 108

    (114) cons -> RES_FALSE .

    TIMES           reduce using rule 114 (cons -> RES_FALSE .)
    DIVIDE          reduce using rule 114 (cons -> RES_FALSE .)
    PLUS            reduce using rule 114 (cons -> RES_FALSE .)
    MINUS           reduce using rule 114 (cons -> RES_FALSE .)
    MIN             reduce using rule 114 (cons -> RES_FALSE .)
    MIN_EQ          reduce using rule 114 (cons -> RES_FALSE .)
    MAY             reduce using rule 114 (cons -> RES_FALSE .)
    MAY_EQ          reduce using rule 114 (cons -> RES_FALSE .)
    DIF             reduce using rule 114 (cons -> RES_FALSE .)
    EQ_EQ           reduce using rule 114 (cons -> RES_FALSE .)
    RPAREN          reduce using rule 114 (cons -> RES_FALSE .)
    RES_READ        reduce using rule 114 (cons -> RES_FALSE .)
    RES_PRINT       reduce using rule 114 (cons -> RES_FALSE .)
    ID              reduce using rule 114 (cons -> RES_FALSE .)
    RES_DEF         reduce using rule 114 (cons -> RES_FALSE .)
    RES_IF          reduce using rule 114 (cons -> RES_FALSE .)
    RES_SWITCH      reduce using rule 114 (cons -> RES_FALSE .)
    RES_WHILE       reduce using rule 114 (cons -> RES_FALSE .)
    RES_FOR         reduce using rule 114 (cons -> RES_FALSE .)
    RES_START       reduce using rule 114 (cons -> RES_FALSE .)
    RES_FUNC        reduce using rule 114 (cons -> RES_FALSE .)
    $end            reduce using rule 114 (cons -> RES_FALSE .)
    RES_END         reduce using rule 114 (cons -> RES_FALSE .)
    E_END           reduce using rule 114 (cons -> RES_FALSE .)
    RES_ELSE        reduce using rule 114 (cons -> RES_FALSE .)
    RES_CASE        reduce using rule 114 (cons -> RES_FALSE .)
    COL             reduce using rule 114 (cons -> RES_FALSE .)
    RES_INT         reduce using rule 114 (cons -> RES_FALSE .)
    RES_FLOAT       reduce using rule 114 (cons -> RES_FALSE .)
    RES_DOUBLE      reduce using rule 114 (cons -> RES_FALSE .)
    RES_BOOLEAN     reduce using rule 114 (cons -> RES_FALSE .)
    RES_STRING      reduce using rule 114 (cons -> RES_FALSE .)
    RES_LIST        reduce using rule 114 (cons -> RES_FALSE .)
    RES_ARRAY       reduce using rule 114 (cons -> RES_FALSE .)
    COMMA           reduce using rule 114 (cons -> RES_FALSE .)
    RCURLY          reduce using rule 114 (cons -> RES_FALSE .)
    RBRACKET        reduce using rule 114 (cons -> RES_FALSE .)


state 109

    (29) vars1_1 -> vars1 .

    RES_DEF         reduce using rule 29 (vars1_1 -> vars1 .)
    RES_START       reduce using rule 29 (vars1_1 -> vars1 .)
    RES_FUNC        reduce using rule 29 (vars1_1 -> vars1 .)
    RES_READ        reduce using rule 29 (vars1_1 -> vars1 .)
    RES_PRINT       reduce using rule 29 (vars1_1 -> vars1 .)
    ID              reduce using rule 29 (vars1_1 -> vars1 .)
    RES_IF          reduce using rule 29 (vars1_1 -> vars1 .)
    RES_SWITCH      reduce using rule 29 (vars1_1 -> vars1 .)
    RES_WHILE       reduce using rule 29 (vars1_1 -> vars1 .)
    RES_FOR         reduce using rule 29 (vars1_1 -> vars1 .)
    $end            reduce using rule 29 (vars1_1 -> vars1 .)
    RES_END         reduce using rule 29 (vars1_1 -> vars1 .)
    E_END           reduce using rule 29 (vars1_1 -> vars1 .)
    RES_ELSE        reduce using rule 29 (vars1_1 -> vars1 .)
    RES_CASE        reduce using rule 29 (vars1_1 -> vars1 .)


state 110

    (28) vars1 -> dato ID vars2 vars1_1 .

    RES_DEF         reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_START       reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_FUNC        reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_READ        reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_PRINT       reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    ID              reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_IF          reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_SWITCH      reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_WHILE       reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_FOR         reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    $end            reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_END         reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    E_END           reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_ELSE        reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)
    RES_CASE        reduce using rule 28 (vars1 -> dato ID vars2 vars1_1 .)


state 111

    (30) vars1_1 -> empty .

    RES_DEF         reduce using rule 30 (vars1_1 -> empty .)
    RES_START       reduce using rule 30 (vars1_1 -> empty .)
    RES_FUNC        reduce using rule 30 (vars1_1 -> empty .)
    RES_READ        reduce using rule 30 (vars1_1 -> empty .)
    RES_PRINT       reduce using rule 30 (vars1_1 -> empty .)
    ID              reduce using rule 30 (vars1_1 -> empty .)
    RES_IF          reduce using rule 30 (vars1_1 -> empty .)
    RES_SWITCH      reduce using rule 30 (vars1_1 -> empty .)
    RES_WHILE       reduce using rule 30 (vars1_1 -> empty .)
    RES_FOR         reduce using rule 30 (vars1_1 -> empty .)
    $end            reduce using rule 30 (vars1_1 -> empty .)
    RES_END         reduce using rule 30 (vars1_1 -> empty .)
    E_END           reduce using rule 30 (vars1_1 -> empty .)
    RES_ELSE        reduce using rule 30 (vars1_1 -> empty .)
    RES_CASE        reduce using rule 30 (vars1_1 -> empty .)


state 112

    (33) vars3 -> COMMA ID . vars3
    (33) vars3 -> . COMMA ID vars3
    (34) vars3 -> . empty
    (126) empty -> .

    COMMA           shift and go to state 78
    RES_INT         reduce using rule 126 (empty -> .)
    RES_FLOAT       reduce using rule 126 (empty -> .)
    RES_DOUBLE      reduce using rule 126 (empty -> .)
    RES_BOOLEAN     reduce using rule 126 (empty -> .)
    RES_STRING      reduce using rule 126 (empty -> .)
    RES_LIST        reduce using rule 126 (empty -> .)
    RES_ARRAY       reduce using rule 126 (empty -> .)
    RES_DEF         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    RES_READ        reduce using rule 126 (empty -> .)
    RES_PRINT       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RES_IF          reduce using rule 126 (empty -> .)
    RES_SWITCH      reduce using rule 126 (empty -> .)
    RES_WHILE       reduce using rule 126 (empty -> .)
    RES_FOR         reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_END         reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_ELSE        reduce using rule 126 (empty -> .)
    RES_CASE        reduce using rule 126 (empty -> .)

    vars3                          shift and go to state 151
    empty                          shift and go to state 79

state 113

    (41) array -> RES_ARRAY dato ID LBRACKET . CTE_INT RBRACKET array1

    CTE_INT         shift and go to state 152


state 114

    (14) prototipos_1 -> tipo ID prototipos_2 .

    RPAREN          reduce using rule 14 (prototipos_1 -> tipo ID prototipos_2 .)


state 115

    (15) prototipos_2 -> COMMA . prototipos_1
    (14) prototipos_1 -> . tipo ID prototipos_2
    (22) tipo -> . dato
    (23) tipo -> . estructura
    (17) dato -> . RES_INT
    (18) dato -> . RES_FLOAT
    (19) dato -> . RES_DOUBLE
    (20) dato -> . RES_BOOLEAN
    (21) dato -> . RES_STRING
    (24) estructura -> . list
    (25) estructura -> . array
    (35) list -> . RES_LIST dato ID list1
    (41) array -> . RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1

    RES_INT         shift and go to state 12
    RES_FLOAT       shift and go to state 16
    RES_DOUBLE      shift and go to state 14
    RES_BOOLEAN     shift and go to state 11
    RES_STRING      shift and go to state 13
    RES_LIST        shift and go to state 37
    RES_ARRAY       shift and go to state 40

    tipo                           shift and go to state 49
    prototipos_1                   shift and go to state 153
    list                           shift and go to state 39
    estructura                     shift and go to state 50
    dato                           shift and go to state 51
    array                          shift and go to state 34

state 116

    (16) prototipos_2 -> empty .

    RPAREN          reduce using rule 16 (prototipos_2 -> empty .)


state 117

    (81) forexp -> ID . EQUALS cons COL expresion COL ID EQUALS expresion

    EQUALS          shift and go to state 154


state 118

    (80) for -> RES_FOR LPAREN forexp . RPAREN COL bloque

    RPAREN          shift and go to state 155


state 119

    (105) factor -> cons .

    TIMES           reduce using rule 105 (factor -> cons .)
    DIVIDE          reduce using rule 105 (factor -> cons .)
    PLUS            reduce using rule 105 (factor -> cons .)
    MINUS           reduce using rule 105 (factor -> cons .)
    RES_READ        reduce using rule 105 (factor -> cons .)
    RES_PRINT       reduce using rule 105 (factor -> cons .)
    ID              reduce using rule 105 (factor -> cons .)
    RES_DEF         reduce using rule 105 (factor -> cons .)
    RES_IF          reduce using rule 105 (factor -> cons .)
    RES_SWITCH      reduce using rule 105 (factor -> cons .)
    RES_WHILE       reduce using rule 105 (factor -> cons .)
    RES_FOR         reduce using rule 105 (factor -> cons .)
    RES_START       reduce using rule 105 (factor -> cons .)
    RES_FUNC        reduce using rule 105 (factor -> cons .)
    $end            reduce using rule 105 (factor -> cons .)
    RES_END         reduce using rule 105 (factor -> cons .)
    E_END           reduce using rule 105 (factor -> cons .)
    RES_ELSE        reduce using rule 105 (factor -> cons .)
    RES_CASE        reduce using rule 105 (factor -> cons .)
    MIN             reduce using rule 105 (factor -> cons .)
    MIN_EQ          reduce using rule 105 (factor -> cons .)
    MAY             reduce using rule 105 (factor -> cons .)
    MAY_EQ          reduce using rule 105 (factor -> cons .)
    DIF             reduce using rule 105 (factor -> cons .)
    EQ_EQ           reduce using rule 105 (factor -> cons .)
    RPAREN          reduce using rule 105 (factor -> cons .)
    COL             reduce using rule 105 (factor -> cons .)


state 120

    (104) factor -> LPAREN . expresion RPAREN
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 156
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 121

    (96) exp -> termino . exp1
    (97) exp1 -> . PLUS exp
    (98) exp1 -> . MINUS exp
    (99) exp1 -> . empty
    (126) empty -> .

    PLUS            shift and go to state 158
    MINUS           shift and go to state 159
    MIN             reduce using rule 126 (empty -> .)
    MIN_EQ          reduce using rule 126 (empty -> .)
    MAY             reduce using rule 126 (empty -> .)
    MAY_EQ          reduce using rule 126 (empty -> .)
    DIF             reduce using rule 126 (empty -> .)
    EQ_EQ           reduce using rule 126 (empty -> .)
    RPAREN          reduce using rule 126 (empty -> .)
    RES_READ        reduce using rule 126 (empty -> .)
    RES_PRINT       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RES_DEF         reduce using rule 126 (empty -> .)
    RES_IF          reduce using rule 126 (empty -> .)
    RES_SWITCH      reduce using rule 126 (empty -> .)
    RES_WHILE       reduce using rule 126 (empty -> .)
    RES_FOR         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_END         reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_ELSE        reduce using rule 126 (empty -> .)
    RES_CASE        reduce using rule 126 (empty -> .)
    COL             reduce using rule 126 (empty -> .)

    exp1                           shift and go to state 157
    empty                          shift and go to state 160

state 122

    (107) factor -> MINUS . cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    conslist                       shift and go to state 105
    consarray                      shift and go to state 102
    cons                           shift and go to state 161

state 123

    (100) termino -> factor . termino1
    (101) termino1 -> . TIMES termino
    (102) termino1 -> . DIVIDE termino
    (103) termino1 -> . empty
    (126) empty -> .

    TIMES           shift and go to state 164
    DIVIDE          shift and go to state 162
    PLUS            reduce using rule 126 (empty -> .)
    MINUS           reduce using rule 126 (empty -> .)
    MIN             reduce using rule 126 (empty -> .)
    MIN_EQ          reduce using rule 126 (empty -> .)
    MAY             reduce using rule 126 (empty -> .)
    MAY_EQ          reduce using rule 126 (empty -> .)
    DIF             reduce using rule 126 (empty -> .)
    EQ_EQ           reduce using rule 126 (empty -> .)
    RPAREN          reduce using rule 126 (empty -> .)
    RES_READ        reduce using rule 126 (empty -> .)
    RES_PRINT       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RES_DEF         reduce using rule 126 (empty -> .)
    RES_IF          reduce using rule 126 (empty -> .)
    RES_SWITCH      reduce using rule 126 (empty -> .)
    RES_WHILE       reduce using rule 126 (empty -> .)
    RES_FOR         reduce using rule 126 (empty -> .)
    RES_START       reduce using rule 126 (empty -> .)
    RES_FUNC        reduce using rule 126 (empty -> .)
    $end            reduce using rule 126 (empty -> .)
    RES_END         reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_ELSE        reduce using rule 126 (empty -> .)
    RES_CASE        reduce using rule 126 (empty -> .)
    COL             reduce using rule 126 (empty -> .)

    termino1                       shift and go to state 163
    empty                          shift and go to state 165

state 124

    (106) factor -> PLUS . cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    conslist                       shift and go to state 105
    consarray                      shift and go to state 102
    cons                           shift and go to state 166

state 125

    (82) if -> RES_IF LPAREN expresion . RPAREN COL bloque ifelse

    RPAREN          shift and go to state 167


state 126

    (88) expresion -> exp . expresion_1
    (89) expresion_1 -> . MIN exp
    (90) expresion_1 -> . MIN_EQ exp
    (91) expresion_1 -> . MAY exp
    (92) expresion_1 -> . MAY_EQ exp
    (93) expresion_1 -> . DIF exp
    (94) expresion_1 -> . EQ_EQ exp
    (95) expresion_1 -> . empty
    (126) empty -> .

    MIN             shift and go to state 169
    MIN_EQ          shift and go to state 168
    MAY             shift and go to state 170
    MAY_EQ          shift and go to state 171
    DIF             shift and go to state 174
    EQ_EQ           shift and go to state 172
    RPAREN          reduce using rule 126 (empty -> .)
    COL             reduce using rule 126 (empty -> .)

    empty                          shift and go to state 175
    expresion_1                    shift and go to state 173

state 127

    (67) escritura1 -> CTE_STRING .
    (112) cons -> CTE_STRING .

  ! reduce/reduce conflict for RPAREN resolved using rule 67 (escritura1 -> CTE_STRING .)
    RPAREN          reduce using rule 67 (escritura1 -> CTE_STRING .)
    TIMES           reduce using rule 112 (cons -> CTE_STRING .)
    DIVIDE          reduce using rule 112 (cons -> CTE_STRING .)
    PLUS            reduce using rule 112 (cons -> CTE_STRING .)
    MINUS           reduce using rule 112 (cons -> CTE_STRING .)
    MIN             reduce using rule 112 (cons -> CTE_STRING .)
    MIN_EQ          reduce using rule 112 (cons -> CTE_STRING .)
    MAY             reduce using rule 112 (cons -> CTE_STRING .)
    MAY_EQ          reduce using rule 112 (cons -> CTE_STRING .)
    DIF             reduce using rule 112 (cons -> CTE_STRING .)
    EQ_EQ           reduce using rule 112 (cons -> CTE_STRING .)

  ! RPAREN          [ reduce using rule 112 (cons -> CTE_STRING .) ]


state 128

    (65) escritura -> RES_PRINT LPAREN escritura1 . RPAREN

    RPAREN          shift and go to state 176


state 129

    (66) escritura1 -> expresion .

    RPAREN          reduce using rule 66 (escritura1 -> expresion .)


state 130

    (79) while -> RES_WHILE LPAREN expresion . RPAREN COL bloque

    RPAREN          shift and go to state 177


state 131

    (76) asignarray -> LBRACKET . asignarray1 RBRACKET
    (77) asignarray1 -> . cons
    (78) asignarray1 -> . cons COMMA asignarray1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 178
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105
    asignarray1                    shift and go to state 179

state 132

    (73) asignlist -> LCURLY . asignlist1 RCURLY
    (74) asignlist1 -> . cons
    (75) asignlist1 -> . cons COMMA asignlist1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    asignlist1                     shift and go to state 180
    cons                           shift and go to state 181
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105

state 133

    (72) asignacion1 -> asignarray .

    RES_READ        reduce using rule 72 (asignacion1 -> asignarray .)
    RES_PRINT       reduce using rule 72 (asignacion1 -> asignarray .)
    ID              reduce using rule 72 (asignacion1 -> asignarray .)
    RES_DEF         reduce using rule 72 (asignacion1 -> asignarray .)
    RES_IF          reduce using rule 72 (asignacion1 -> asignarray .)
    RES_SWITCH      reduce using rule 72 (asignacion1 -> asignarray .)
    RES_WHILE       reduce using rule 72 (asignacion1 -> asignarray .)
    RES_FOR         reduce using rule 72 (asignacion1 -> asignarray .)
    RES_START       reduce using rule 72 (asignacion1 -> asignarray .)
    RES_FUNC        reduce using rule 72 (asignacion1 -> asignarray .)
    $end            reduce using rule 72 (asignacion1 -> asignarray .)
    RES_END         reduce using rule 72 (asignacion1 -> asignarray .)
    E_END           reduce using rule 72 (asignacion1 -> asignarray .)
    RES_ELSE        reduce using rule 72 (asignacion1 -> asignarray .)
    RES_CASE        reduce using rule 72 (asignacion1 -> asignarray .)


state 134

    (71) asignacion1 -> asignlist .

    RES_READ        reduce using rule 71 (asignacion1 -> asignlist .)
    RES_PRINT       reduce using rule 71 (asignacion1 -> asignlist .)
    ID              reduce using rule 71 (asignacion1 -> asignlist .)
    RES_DEF         reduce using rule 71 (asignacion1 -> asignlist .)
    RES_IF          reduce using rule 71 (asignacion1 -> asignlist .)
    RES_SWITCH      reduce using rule 71 (asignacion1 -> asignlist .)
    RES_WHILE       reduce using rule 71 (asignacion1 -> asignlist .)
    RES_FOR         reduce using rule 71 (asignacion1 -> asignlist .)
    RES_START       reduce using rule 71 (asignacion1 -> asignlist .)
    RES_FUNC        reduce using rule 71 (asignacion1 -> asignlist .)
    $end            reduce using rule 71 (asignacion1 -> asignlist .)
    RES_END         reduce using rule 71 (asignacion1 -> asignlist .)
    E_END           reduce using rule 71 (asignacion1 -> asignlist .)
    RES_ELSE        reduce using rule 71 (asignacion1 -> asignlist .)
    RES_CASE        reduce using rule 71 (asignacion1 -> asignlist .)


state 135

    (70) asignacion1 -> exp .

    RES_READ        reduce using rule 70 (asignacion1 -> exp .)
    RES_PRINT       reduce using rule 70 (asignacion1 -> exp .)
    ID              reduce using rule 70 (asignacion1 -> exp .)
    RES_DEF         reduce using rule 70 (asignacion1 -> exp .)
    RES_IF          reduce using rule 70 (asignacion1 -> exp .)
    RES_SWITCH      reduce using rule 70 (asignacion1 -> exp .)
    RES_WHILE       reduce using rule 70 (asignacion1 -> exp .)
    RES_FOR         reduce using rule 70 (asignacion1 -> exp .)
    RES_START       reduce using rule 70 (asignacion1 -> exp .)
    RES_FUNC        reduce using rule 70 (asignacion1 -> exp .)
    $end            reduce using rule 70 (asignacion1 -> exp .)
    RES_END         reduce using rule 70 (asignacion1 -> exp .)
    E_END           reduce using rule 70 (asignacion1 -> exp .)
    RES_ELSE        reduce using rule 70 (asignacion1 -> exp .)
    RES_CASE        reduce using rule 70 (asignacion1 -> exp .)


state 136

    (69) seen_id_asignacion -> EQUALS asignacion1 .

    RES_READ        reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_PRINT       reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    ID              reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_DEF         reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_IF          reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_SWITCH      reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_WHILE       reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_FOR         reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_START       reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_FUNC        reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    $end            reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_END         reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    E_END           reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_ELSE        reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)
    RES_CASE        reduce using rule 69 (seen_id_asignacion -> EQUALS asignacion1 .)


state 137

    (61) llamada -> ID LPAREN llamada1 . RPAREN

    RPAREN          shift and go to state 182


state 138

    (63) llamada1 -> empty .

    RPAREN          reduce using rule 63 (llamada1 -> empty .)


state 139

    (62) llamada1 -> expresion .

    RPAREN          reduce using rule 62 (llamada1 -> expresion .)


state 140

    (64) lectura -> RES_READ LPAREN tipo . RPAREN

    RPAREN          shift and go to state 183


state 141

    (85) switch -> RES_SWITCH COL switch2 .

    E_END           reduce using rule 85 (switch -> RES_SWITCH COL switch2 .)


state 142

    (86) switch2 -> RES_CASE . expresion COL bloque switch2
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 184
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 143

    (87) switch2 -> empty .

    E_END           reduce using rule 87 (switch2 -> empty .)


state 144

    (38) cons_loop -> cons . cons_loop_1
    (39) cons_loop_1 -> . COMMA cons_loop
    (40) cons_loop_1 -> . empty
    (126) empty -> .

    COMMA           shift and go to state 185
    RCURLY          reduce using rule 126 (empty -> .)

    empty                          shift and go to state 186
    cons_loop_1                    shift and go to state 187

state 145

    (36) list1 -> LCURLY cons_loop . RCURLY

    RCURLY          shift and go to state 188


state 146

    (110) cons -> CTE_FLOAT exp_3 .

    TIMES           reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    DIVIDE          reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    PLUS            reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    MINUS           reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    MIN             reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    MIN_EQ          reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    MAY             reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    MAY_EQ          reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    DIF             reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    EQ_EQ           reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RPAREN          reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_READ        reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_PRINT       reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    ID              reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_DEF         reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_IF          reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_SWITCH      reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_WHILE       reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_FOR         reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_START       reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_FUNC        reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    $end            reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_END         reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    E_END           reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_ELSE        reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_CASE        reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    COL             reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_INT         reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_FLOAT       reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_DOUBLE      reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_BOOLEAN     reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_STRING      reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_LIST        reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RES_ARRAY       reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    COMMA           reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RCURLY          reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)
    RBRACKET        reduce using rule 110 (cons -> CTE_FLOAT exp_3 .)


state 147

    (109) cons -> CTE_INT exp_2 .

    TIMES           reduce using rule 109 (cons -> CTE_INT exp_2 .)
    DIVIDE          reduce using rule 109 (cons -> CTE_INT exp_2 .)
    PLUS            reduce using rule 109 (cons -> CTE_INT exp_2 .)
    MINUS           reduce using rule 109 (cons -> CTE_INT exp_2 .)
    MIN             reduce using rule 109 (cons -> CTE_INT exp_2 .)
    MIN_EQ          reduce using rule 109 (cons -> CTE_INT exp_2 .)
    MAY             reduce using rule 109 (cons -> CTE_INT exp_2 .)
    MAY_EQ          reduce using rule 109 (cons -> CTE_INT exp_2 .)
    DIF             reduce using rule 109 (cons -> CTE_INT exp_2 .)
    EQ_EQ           reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RPAREN          reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_READ        reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_PRINT       reduce using rule 109 (cons -> CTE_INT exp_2 .)
    ID              reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_DEF         reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_IF          reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_SWITCH      reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_WHILE       reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_FOR         reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_START       reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_FUNC        reduce using rule 109 (cons -> CTE_INT exp_2 .)
    $end            reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_END         reduce using rule 109 (cons -> CTE_INT exp_2 .)
    E_END           reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_ELSE        reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_CASE        reduce using rule 109 (cons -> CTE_INT exp_2 .)
    COL             reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_INT         reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_FLOAT       reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_DOUBLE      reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_BOOLEAN     reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_STRING      reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_LIST        reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RES_ARRAY       reduce using rule 109 (cons -> CTE_INT exp_2 .)
    COMMA           reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RCURLY          reduce using rule 109 (cons -> CTE_INT exp_2 .)
    RBRACKET        reduce using rule 109 (cons -> CTE_INT exp_2 .)


state 148

    (123) conslist -> ID EQUALS . LCURLY conslist1 RCURLY

    LCURLY          shift and go to state 189


state 149

    (122) consarray -> ID LBRACKET . CTE_INT RBRACKET EQUALS cons

    CTE_INT         shift and go to state 190


state 150

    (108) cons -> ID exp_1 .

    TIMES           reduce using rule 108 (cons -> ID exp_1 .)
    DIVIDE          reduce using rule 108 (cons -> ID exp_1 .)
    PLUS            reduce using rule 108 (cons -> ID exp_1 .)
    MINUS           reduce using rule 108 (cons -> ID exp_1 .)
    MIN             reduce using rule 108 (cons -> ID exp_1 .)
    MIN_EQ          reduce using rule 108 (cons -> ID exp_1 .)
    MAY             reduce using rule 108 (cons -> ID exp_1 .)
    MAY_EQ          reduce using rule 108 (cons -> ID exp_1 .)
    DIF             reduce using rule 108 (cons -> ID exp_1 .)
    EQ_EQ           reduce using rule 108 (cons -> ID exp_1 .)
    RPAREN          reduce using rule 108 (cons -> ID exp_1 .)
    RES_READ        reduce using rule 108 (cons -> ID exp_1 .)
    RES_PRINT       reduce using rule 108 (cons -> ID exp_1 .)
    ID              reduce using rule 108 (cons -> ID exp_1 .)
    RES_DEF         reduce using rule 108 (cons -> ID exp_1 .)
    RES_IF          reduce using rule 108 (cons -> ID exp_1 .)
    RES_SWITCH      reduce using rule 108 (cons -> ID exp_1 .)
    RES_WHILE       reduce using rule 108 (cons -> ID exp_1 .)
    RES_FOR         reduce using rule 108 (cons -> ID exp_1 .)
    RES_START       reduce using rule 108 (cons -> ID exp_1 .)
    RES_FUNC        reduce using rule 108 (cons -> ID exp_1 .)
    $end            reduce using rule 108 (cons -> ID exp_1 .)
    RES_END         reduce using rule 108 (cons -> ID exp_1 .)
    E_END           reduce using rule 108 (cons -> ID exp_1 .)
    RES_ELSE        reduce using rule 108 (cons -> ID exp_1 .)
    RES_CASE        reduce using rule 108 (cons -> ID exp_1 .)
    COL             reduce using rule 108 (cons -> ID exp_1 .)
    RES_INT         reduce using rule 108 (cons -> ID exp_1 .)
    RES_FLOAT       reduce using rule 108 (cons -> ID exp_1 .)
    RES_DOUBLE      reduce using rule 108 (cons -> ID exp_1 .)
    RES_BOOLEAN     reduce using rule 108 (cons -> ID exp_1 .)
    RES_STRING      reduce using rule 108 (cons -> ID exp_1 .)
    RES_LIST        reduce using rule 108 (cons -> ID exp_1 .)
    RES_ARRAY       reduce using rule 108 (cons -> ID exp_1 .)
    COMMA           reduce using rule 108 (cons -> ID exp_1 .)
    RCURLY          reduce using rule 108 (cons -> ID exp_1 .)
    RBRACKET        reduce using rule 108 (cons -> ID exp_1 .)


state 151

    (33) vars3 -> COMMA ID vars3 .

    RES_INT         reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_FLOAT       reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_DOUBLE      reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_BOOLEAN     reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_STRING      reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_LIST        reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_ARRAY       reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_DEF         reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_START       reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_FUNC        reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_READ        reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_PRINT       reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    ID              reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_IF          reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_SWITCH      reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_WHILE       reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_FOR         reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    $end            reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_END         reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    E_END           reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_ELSE        reduce using rule 33 (vars3 -> COMMA ID vars3 .)
    RES_CASE        reduce using rule 33 (vars3 -> COMMA ID vars3 .)


state 152

    (41) array -> RES_ARRAY dato ID LBRACKET CTE_INT . RBRACKET array1

    RBRACKET        shift and go to state 191


state 153

    (15) prototipos_2 -> COMMA prototipos_1 .

    RPAREN          reduce using rule 15 (prototipos_2 -> COMMA prototipos_1 .)


state 154

    (81) forexp -> ID EQUALS . cons COL expresion COL ID EQUALS expresion
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 192
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105

state 155

    (80) for -> RES_FOR LPAREN forexp RPAREN . COL bloque

    COL             shift and go to state 193


state 156

    (104) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 194


state 157

    (96) exp -> termino exp1 .

    MIN             reduce using rule 96 (exp -> termino exp1 .)
    MIN_EQ          reduce using rule 96 (exp -> termino exp1 .)
    MAY             reduce using rule 96 (exp -> termino exp1 .)
    MAY_EQ          reduce using rule 96 (exp -> termino exp1 .)
    DIF             reduce using rule 96 (exp -> termino exp1 .)
    EQ_EQ           reduce using rule 96 (exp -> termino exp1 .)
    RPAREN          reduce using rule 96 (exp -> termino exp1 .)
    COL             reduce using rule 96 (exp -> termino exp1 .)
    RES_READ        reduce using rule 96 (exp -> termino exp1 .)
    RES_PRINT       reduce using rule 96 (exp -> termino exp1 .)
    ID              reduce using rule 96 (exp -> termino exp1 .)
    RES_DEF         reduce using rule 96 (exp -> termino exp1 .)
    RES_IF          reduce using rule 96 (exp -> termino exp1 .)
    RES_SWITCH      reduce using rule 96 (exp -> termino exp1 .)
    RES_WHILE       reduce using rule 96 (exp -> termino exp1 .)
    RES_FOR         reduce using rule 96 (exp -> termino exp1 .)
    RES_START       reduce using rule 96 (exp -> termino exp1 .)
    RES_FUNC        reduce using rule 96 (exp -> termino exp1 .)
    $end            reduce using rule 96 (exp -> termino exp1 .)
    RES_END         reduce using rule 96 (exp -> termino exp1 .)
    E_END           reduce using rule 96 (exp -> termino exp1 .)
    RES_ELSE        reduce using rule 96 (exp -> termino exp1 .)
    RES_CASE        reduce using rule 96 (exp -> termino exp1 .)


state 158

    (97) exp1 -> PLUS . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 195
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 159

    (98) exp1 -> MINUS . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 196
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 160

    (99) exp1 -> empty .

    MIN             reduce using rule 99 (exp1 -> empty .)
    MIN_EQ          reduce using rule 99 (exp1 -> empty .)
    MAY             reduce using rule 99 (exp1 -> empty .)
    MAY_EQ          reduce using rule 99 (exp1 -> empty .)
    DIF             reduce using rule 99 (exp1 -> empty .)
    EQ_EQ           reduce using rule 99 (exp1 -> empty .)
    RPAREN          reduce using rule 99 (exp1 -> empty .)
    RES_READ        reduce using rule 99 (exp1 -> empty .)
    RES_PRINT       reduce using rule 99 (exp1 -> empty .)
    ID              reduce using rule 99 (exp1 -> empty .)
    RES_DEF         reduce using rule 99 (exp1 -> empty .)
    RES_IF          reduce using rule 99 (exp1 -> empty .)
    RES_SWITCH      reduce using rule 99 (exp1 -> empty .)
    RES_WHILE       reduce using rule 99 (exp1 -> empty .)
    RES_FOR         reduce using rule 99 (exp1 -> empty .)
    RES_START       reduce using rule 99 (exp1 -> empty .)
    RES_FUNC        reduce using rule 99 (exp1 -> empty .)
    $end            reduce using rule 99 (exp1 -> empty .)
    RES_END         reduce using rule 99 (exp1 -> empty .)
    E_END           reduce using rule 99 (exp1 -> empty .)
    RES_ELSE        reduce using rule 99 (exp1 -> empty .)
    RES_CASE        reduce using rule 99 (exp1 -> empty .)
    COL             reduce using rule 99 (exp1 -> empty .)


state 161

    (107) factor -> MINUS cons .

    TIMES           reduce using rule 107 (factor -> MINUS cons .)
    DIVIDE          reduce using rule 107 (factor -> MINUS cons .)
    PLUS            reduce using rule 107 (factor -> MINUS cons .)
    MINUS           reduce using rule 107 (factor -> MINUS cons .)
    RES_READ        reduce using rule 107 (factor -> MINUS cons .)
    RES_PRINT       reduce using rule 107 (factor -> MINUS cons .)
    ID              reduce using rule 107 (factor -> MINUS cons .)
    RES_DEF         reduce using rule 107 (factor -> MINUS cons .)
    RES_IF          reduce using rule 107 (factor -> MINUS cons .)
    RES_SWITCH      reduce using rule 107 (factor -> MINUS cons .)
    RES_WHILE       reduce using rule 107 (factor -> MINUS cons .)
    RES_FOR         reduce using rule 107 (factor -> MINUS cons .)
    RES_START       reduce using rule 107 (factor -> MINUS cons .)
    RES_FUNC        reduce using rule 107 (factor -> MINUS cons .)
    $end            reduce using rule 107 (factor -> MINUS cons .)
    RES_END         reduce using rule 107 (factor -> MINUS cons .)
    E_END           reduce using rule 107 (factor -> MINUS cons .)
    RES_ELSE        reduce using rule 107 (factor -> MINUS cons .)
    RES_CASE        reduce using rule 107 (factor -> MINUS cons .)
    MIN             reduce using rule 107 (factor -> MINUS cons .)
    MIN_EQ          reduce using rule 107 (factor -> MINUS cons .)
    MAY             reduce using rule 107 (factor -> MINUS cons .)
    MAY_EQ          reduce using rule 107 (factor -> MINUS cons .)
    DIF             reduce using rule 107 (factor -> MINUS cons .)
    EQ_EQ           reduce using rule 107 (factor -> MINUS cons .)
    RPAREN          reduce using rule 107 (factor -> MINUS cons .)
    COL             reduce using rule 107 (factor -> MINUS cons .)


state 162

    (102) termino1 -> DIVIDE . termino
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 197
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 163

    (100) termino -> factor termino1 .

    PLUS            reduce using rule 100 (termino -> factor termino1 .)
    MINUS           reduce using rule 100 (termino -> factor termino1 .)
    RPAREN          reduce using rule 100 (termino -> factor termino1 .)
    COL             reduce using rule 100 (termino -> factor termino1 .)
    MIN             reduce using rule 100 (termino -> factor termino1 .)
    MIN_EQ          reduce using rule 100 (termino -> factor termino1 .)
    MAY             reduce using rule 100 (termino -> factor termino1 .)
    MAY_EQ          reduce using rule 100 (termino -> factor termino1 .)
    DIF             reduce using rule 100 (termino -> factor termino1 .)
    EQ_EQ           reduce using rule 100 (termino -> factor termino1 .)
    RES_READ        reduce using rule 100 (termino -> factor termino1 .)
    RES_PRINT       reduce using rule 100 (termino -> factor termino1 .)
    ID              reduce using rule 100 (termino -> factor termino1 .)
    RES_DEF         reduce using rule 100 (termino -> factor termino1 .)
    RES_IF          reduce using rule 100 (termino -> factor termino1 .)
    RES_SWITCH      reduce using rule 100 (termino -> factor termino1 .)
    RES_WHILE       reduce using rule 100 (termino -> factor termino1 .)
    RES_FOR         reduce using rule 100 (termino -> factor termino1 .)
    RES_START       reduce using rule 100 (termino -> factor termino1 .)
    RES_FUNC        reduce using rule 100 (termino -> factor termino1 .)
    $end            reduce using rule 100 (termino -> factor termino1 .)
    RES_END         reduce using rule 100 (termino -> factor termino1 .)
    E_END           reduce using rule 100 (termino -> factor termino1 .)
    RES_ELSE        reduce using rule 100 (termino -> factor termino1 .)
    RES_CASE        reduce using rule 100 (termino -> factor termino1 .)


state 164

    (101) termino1 -> TIMES . termino
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 198
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 165

    (103) termino1 -> empty .

    PLUS            reduce using rule 103 (termino1 -> empty .)
    MINUS           reduce using rule 103 (termino1 -> empty .)
    MIN             reduce using rule 103 (termino1 -> empty .)
    MIN_EQ          reduce using rule 103 (termino1 -> empty .)
    MAY             reduce using rule 103 (termino1 -> empty .)
    MAY_EQ          reduce using rule 103 (termino1 -> empty .)
    DIF             reduce using rule 103 (termino1 -> empty .)
    EQ_EQ           reduce using rule 103 (termino1 -> empty .)
    RPAREN          reduce using rule 103 (termino1 -> empty .)
    RES_READ        reduce using rule 103 (termino1 -> empty .)
    RES_PRINT       reduce using rule 103 (termino1 -> empty .)
    ID              reduce using rule 103 (termino1 -> empty .)
    RES_DEF         reduce using rule 103 (termino1 -> empty .)
    RES_IF          reduce using rule 103 (termino1 -> empty .)
    RES_SWITCH      reduce using rule 103 (termino1 -> empty .)
    RES_WHILE       reduce using rule 103 (termino1 -> empty .)
    RES_FOR         reduce using rule 103 (termino1 -> empty .)
    RES_START       reduce using rule 103 (termino1 -> empty .)
    RES_FUNC        reduce using rule 103 (termino1 -> empty .)
    $end            reduce using rule 103 (termino1 -> empty .)
    RES_END         reduce using rule 103 (termino1 -> empty .)
    E_END           reduce using rule 103 (termino1 -> empty .)
    RES_ELSE        reduce using rule 103 (termino1 -> empty .)
    RES_CASE        reduce using rule 103 (termino1 -> empty .)
    COL             reduce using rule 103 (termino1 -> empty .)


state 166

    (106) factor -> PLUS cons .

    TIMES           reduce using rule 106 (factor -> PLUS cons .)
    DIVIDE          reduce using rule 106 (factor -> PLUS cons .)
    PLUS            reduce using rule 106 (factor -> PLUS cons .)
    MINUS           reduce using rule 106 (factor -> PLUS cons .)
    RES_READ        reduce using rule 106 (factor -> PLUS cons .)
    RES_PRINT       reduce using rule 106 (factor -> PLUS cons .)
    ID              reduce using rule 106 (factor -> PLUS cons .)
    RES_DEF         reduce using rule 106 (factor -> PLUS cons .)
    RES_IF          reduce using rule 106 (factor -> PLUS cons .)
    RES_SWITCH      reduce using rule 106 (factor -> PLUS cons .)
    RES_WHILE       reduce using rule 106 (factor -> PLUS cons .)
    RES_FOR         reduce using rule 106 (factor -> PLUS cons .)
    RES_START       reduce using rule 106 (factor -> PLUS cons .)
    RES_FUNC        reduce using rule 106 (factor -> PLUS cons .)
    $end            reduce using rule 106 (factor -> PLUS cons .)
    RES_END         reduce using rule 106 (factor -> PLUS cons .)
    E_END           reduce using rule 106 (factor -> PLUS cons .)
    RES_ELSE        reduce using rule 106 (factor -> PLUS cons .)
    RES_CASE        reduce using rule 106 (factor -> PLUS cons .)
    MIN             reduce using rule 106 (factor -> PLUS cons .)
    MIN_EQ          reduce using rule 106 (factor -> PLUS cons .)
    MAY             reduce using rule 106 (factor -> PLUS cons .)
    MAY_EQ          reduce using rule 106 (factor -> PLUS cons .)
    DIF             reduce using rule 106 (factor -> PLUS cons .)
    EQ_EQ           reduce using rule 106 (factor -> PLUS cons .)
    RPAREN          reduce using rule 106 (factor -> PLUS cons .)
    COL             reduce using rule 106 (factor -> PLUS cons .)


state 167

    (82) if -> RES_IF LPAREN expresion RPAREN . COL bloque ifelse

    COL             shift and go to state 199


state 168

    (90) expresion_1 -> MIN_EQ . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 200
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 169

    (89) expresion_1 -> MIN . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 201
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 170

    (91) expresion_1 -> MAY . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 202
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 171

    (92) expresion_1 -> MAY_EQ . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 203
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 172

    (94) expresion_1 -> EQ_EQ . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 204
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 173

    (88) expresion -> exp expresion_1 .

    RPAREN          reduce using rule 88 (expresion -> exp expresion_1 .)
    COL             reduce using rule 88 (expresion -> exp expresion_1 .)


state 174

    (93) expresion_1 -> DIF . exp
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 119
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    exp                            shift and go to state 205
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 175

    (95) expresion_1 -> empty .

    RPAREN          reduce using rule 95 (expresion_1 -> empty .)
    COL             reduce using rule 95 (expresion_1 -> empty .)


state 176

    (65) escritura -> RES_PRINT LPAREN escritura1 RPAREN .

    RES_READ        reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_PRINT       reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    ID              reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_DEF         reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_IF          reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_SWITCH      reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_WHILE       reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_FOR         reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_START       reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_FUNC        reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    $end            reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_CASE        reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    E_END           reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_END         reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)
    RES_ELSE        reduce using rule 65 (escritura -> RES_PRINT LPAREN escritura1 RPAREN .)


state 177

    (79) while -> RES_WHILE LPAREN expresion RPAREN . COL bloque

    COL             shift and go to state 206


state 178

    (77) asignarray1 -> cons .
    (78) asignarray1 -> cons . COMMA asignarray1

    RBRACKET        reduce using rule 77 (asignarray1 -> cons .)
    COMMA           shift and go to state 207


state 179

    (76) asignarray -> LBRACKET asignarray1 . RBRACKET

    RBRACKET        shift and go to state 208


state 180

    (73) asignlist -> LCURLY asignlist1 . RCURLY

    RCURLY          shift and go to state 209


state 181

    (74) asignlist1 -> cons .
    (75) asignlist1 -> cons . COMMA asignlist1

    RCURLY          reduce using rule 74 (asignlist1 -> cons .)
    COMMA           shift and go to state 210


state 182

    (61) llamada -> ID LPAREN llamada1 RPAREN .

    RES_READ        reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_PRINT       reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    ID              reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_DEF         reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_IF          reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_SWITCH      reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_WHILE       reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_FOR         reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    E_END           reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_CASE        reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_START       reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_FUNC        reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    $end            reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_END         reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)
    RES_ELSE        reduce using rule 61 (llamada -> ID LPAREN llamada1 RPAREN .)


state 183

    (64) lectura -> RES_READ LPAREN tipo RPAREN .

    RES_READ        reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_PRINT       reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    ID              reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_DEF         reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_IF          reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_SWITCH      reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_WHILE       reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_FOR         reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_START       reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_FUNC        reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    $end            reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_END         reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    E_END           reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_ELSE        reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)
    RES_CASE        reduce using rule 64 (lectura -> RES_READ LPAREN tipo RPAREN .)


state 184

    (86) switch2 -> RES_CASE expresion . COL bloque switch2

    COL             shift and go to state 211


state 185

    (39) cons_loop_1 -> COMMA . cons_loop
    (38) cons_loop -> . cons cons_loop_1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 144
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105
    cons_loop                      shift and go to state 212

state 186

    (40) cons_loop_1 -> empty .

    RCURLY          reduce using rule 40 (cons_loop_1 -> empty .)


state 187

    (38) cons_loop -> cons cons_loop_1 .

    RCURLY          reduce using rule 38 (cons_loop -> cons cons_loop_1 .)


state 188

    (36) list1 -> LCURLY cons_loop RCURLY .

    RES_INT         reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RES_FLOAT       reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RES_DOUBLE      reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RES_BOOLEAN     reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RES_STRING      reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RES_LIST        reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RES_ARRAY       reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    ID              reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)
    RPAREN          reduce using rule 36 (list1 -> LCURLY cons_loop RCURLY .)


state 189

    (123) conslist -> ID EQUALS LCURLY . conslist1 RCURLY
    (124) conslist1 -> . cons
    (125) conslist1 -> . cons COMMA conslist1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 213
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105
    conslist1                      shift and go to state 214

state 190

    (122) consarray -> ID LBRACKET CTE_INT . RBRACKET EQUALS cons

    RBRACKET        shift and go to state 215


state 191

    (41) array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET . array1
    (42) array1 -> . COL LBRACKET array2 RBRACKET
    (43) array1 -> . empty
    (126) empty -> .

    COL             shift and go to state 217
    RES_INT         reduce using rule 126 (empty -> .)
    RES_FLOAT       reduce using rule 126 (empty -> .)
    RES_DOUBLE      reduce using rule 126 (empty -> .)
    RES_BOOLEAN     reduce using rule 126 (empty -> .)
    RES_STRING      reduce using rule 126 (empty -> .)
    RES_LIST        reduce using rule 126 (empty -> .)
    RES_ARRAY       reduce using rule 126 (empty -> .)
    ID              reduce using rule 126 (empty -> .)
    RPAREN          reduce using rule 126 (empty -> .)

    array1                         shift and go to state 216
    empty                          shift and go to state 218

state 192

    (81) forexp -> ID EQUALS cons . COL expresion COL ID EQUALS expresion

    COL             shift and go to state 219


state 193

    (80) for -> RES_FOR LPAREN forexp RPAREN COL . bloque
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    E_END           reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 220
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 194

    (104) factor -> LPAREN expresion RPAREN .

    TIMES           reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_READ        reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_PRINT       reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    ID              reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_DEF         reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_IF          reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_SWITCH      reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_WHILE       reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_FOR         reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_START       reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_FUNC        reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    $end            reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_END         reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    E_END           reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_ELSE        reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RES_CASE        reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    MIN             reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    MIN_EQ          reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    MAY             reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    MAY_EQ          reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    DIF             reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    EQ_EQ           reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 104 (factor -> LPAREN expresion RPAREN .)
    COL             reduce using rule 104 (factor -> LPAREN expresion RPAREN .)


state 195

    (97) exp1 -> PLUS exp .

    MIN             reduce using rule 97 (exp1 -> PLUS exp .)
    MIN_EQ          reduce using rule 97 (exp1 -> PLUS exp .)
    MAY             reduce using rule 97 (exp1 -> PLUS exp .)
    MAY_EQ          reduce using rule 97 (exp1 -> PLUS exp .)
    DIF             reduce using rule 97 (exp1 -> PLUS exp .)
    EQ_EQ           reduce using rule 97 (exp1 -> PLUS exp .)
    RPAREN          reduce using rule 97 (exp1 -> PLUS exp .)
    RES_READ        reduce using rule 97 (exp1 -> PLUS exp .)
    RES_PRINT       reduce using rule 97 (exp1 -> PLUS exp .)
    ID              reduce using rule 97 (exp1 -> PLUS exp .)
    RES_DEF         reduce using rule 97 (exp1 -> PLUS exp .)
    RES_IF          reduce using rule 97 (exp1 -> PLUS exp .)
    RES_SWITCH      reduce using rule 97 (exp1 -> PLUS exp .)
    RES_WHILE       reduce using rule 97 (exp1 -> PLUS exp .)
    RES_FOR         reduce using rule 97 (exp1 -> PLUS exp .)
    RES_START       reduce using rule 97 (exp1 -> PLUS exp .)
    RES_FUNC        reduce using rule 97 (exp1 -> PLUS exp .)
    $end            reduce using rule 97 (exp1 -> PLUS exp .)
    RES_END         reduce using rule 97 (exp1 -> PLUS exp .)
    E_END           reduce using rule 97 (exp1 -> PLUS exp .)
    RES_ELSE        reduce using rule 97 (exp1 -> PLUS exp .)
    RES_CASE        reduce using rule 97 (exp1 -> PLUS exp .)
    COL             reduce using rule 97 (exp1 -> PLUS exp .)


state 196

    (98) exp1 -> MINUS exp .

    MIN             reduce using rule 98 (exp1 -> MINUS exp .)
    MIN_EQ          reduce using rule 98 (exp1 -> MINUS exp .)
    MAY             reduce using rule 98 (exp1 -> MINUS exp .)
    MAY_EQ          reduce using rule 98 (exp1 -> MINUS exp .)
    DIF             reduce using rule 98 (exp1 -> MINUS exp .)
    EQ_EQ           reduce using rule 98 (exp1 -> MINUS exp .)
    RPAREN          reduce using rule 98 (exp1 -> MINUS exp .)
    RES_READ        reduce using rule 98 (exp1 -> MINUS exp .)
    RES_PRINT       reduce using rule 98 (exp1 -> MINUS exp .)
    ID              reduce using rule 98 (exp1 -> MINUS exp .)
    RES_DEF         reduce using rule 98 (exp1 -> MINUS exp .)
    RES_IF          reduce using rule 98 (exp1 -> MINUS exp .)
    RES_SWITCH      reduce using rule 98 (exp1 -> MINUS exp .)
    RES_WHILE       reduce using rule 98 (exp1 -> MINUS exp .)
    RES_FOR         reduce using rule 98 (exp1 -> MINUS exp .)
    RES_START       reduce using rule 98 (exp1 -> MINUS exp .)
    RES_FUNC        reduce using rule 98 (exp1 -> MINUS exp .)
    $end            reduce using rule 98 (exp1 -> MINUS exp .)
    RES_END         reduce using rule 98 (exp1 -> MINUS exp .)
    E_END           reduce using rule 98 (exp1 -> MINUS exp .)
    RES_ELSE        reduce using rule 98 (exp1 -> MINUS exp .)
    RES_CASE        reduce using rule 98 (exp1 -> MINUS exp .)
    COL             reduce using rule 98 (exp1 -> MINUS exp .)


state 197

    (102) termino1 -> DIVIDE termino .

    PLUS            reduce using rule 102 (termino1 -> DIVIDE termino .)
    MINUS           reduce using rule 102 (termino1 -> DIVIDE termino .)
    MIN             reduce using rule 102 (termino1 -> DIVIDE termino .)
    MIN_EQ          reduce using rule 102 (termino1 -> DIVIDE termino .)
    MAY             reduce using rule 102 (termino1 -> DIVIDE termino .)
    MAY_EQ          reduce using rule 102 (termino1 -> DIVIDE termino .)
    DIF             reduce using rule 102 (termino1 -> DIVIDE termino .)
    EQ_EQ           reduce using rule 102 (termino1 -> DIVIDE termino .)
    RPAREN          reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_READ        reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_PRINT       reduce using rule 102 (termino1 -> DIVIDE termino .)
    ID              reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_DEF         reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_IF          reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_SWITCH      reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_WHILE       reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_FOR         reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_START       reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_FUNC        reduce using rule 102 (termino1 -> DIVIDE termino .)
    $end            reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_END         reduce using rule 102 (termino1 -> DIVIDE termino .)
    E_END           reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_ELSE        reduce using rule 102 (termino1 -> DIVIDE termino .)
    RES_CASE        reduce using rule 102 (termino1 -> DIVIDE termino .)
    COL             reduce using rule 102 (termino1 -> DIVIDE termino .)


state 198

    (101) termino1 -> TIMES termino .

    PLUS            reduce using rule 101 (termino1 -> TIMES termino .)
    MINUS           reduce using rule 101 (termino1 -> TIMES termino .)
    MIN             reduce using rule 101 (termino1 -> TIMES termino .)
    MIN_EQ          reduce using rule 101 (termino1 -> TIMES termino .)
    MAY             reduce using rule 101 (termino1 -> TIMES termino .)
    MAY_EQ          reduce using rule 101 (termino1 -> TIMES termino .)
    DIF             reduce using rule 101 (termino1 -> TIMES termino .)
    EQ_EQ           reduce using rule 101 (termino1 -> TIMES termino .)
    RPAREN          reduce using rule 101 (termino1 -> TIMES termino .)
    RES_READ        reduce using rule 101 (termino1 -> TIMES termino .)
    RES_PRINT       reduce using rule 101 (termino1 -> TIMES termino .)
    ID              reduce using rule 101 (termino1 -> TIMES termino .)
    RES_DEF         reduce using rule 101 (termino1 -> TIMES termino .)
    RES_IF          reduce using rule 101 (termino1 -> TIMES termino .)
    RES_SWITCH      reduce using rule 101 (termino1 -> TIMES termino .)
    RES_WHILE       reduce using rule 101 (termino1 -> TIMES termino .)
    RES_FOR         reduce using rule 101 (termino1 -> TIMES termino .)
    RES_START       reduce using rule 101 (termino1 -> TIMES termino .)
    RES_FUNC        reduce using rule 101 (termino1 -> TIMES termino .)
    $end            reduce using rule 101 (termino1 -> TIMES termino .)
    RES_END         reduce using rule 101 (termino1 -> TIMES termino .)
    E_END           reduce using rule 101 (termino1 -> TIMES termino .)
    RES_ELSE        reduce using rule 101 (termino1 -> TIMES termino .)
    RES_CASE        reduce using rule 101 (termino1 -> TIMES termino .)
    COL             reduce using rule 101 (termino1 -> TIMES termino .)


state 199

    (82) if -> RES_IF LPAREN expresion RPAREN COL . bloque ifelse
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_ELSE        reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 221
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 200

    (90) expresion_1 -> MIN_EQ exp .

    RPAREN          reduce using rule 90 (expresion_1 -> MIN_EQ exp .)
    COL             reduce using rule 90 (expresion_1 -> MIN_EQ exp .)


state 201

    (89) expresion_1 -> MIN exp .

    RPAREN          reduce using rule 89 (expresion_1 -> MIN exp .)
    COL             reduce using rule 89 (expresion_1 -> MIN exp .)


state 202

    (91) expresion_1 -> MAY exp .

    RPAREN          reduce using rule 91 (expresion_1 -> MAY exp .)
    COL             reduce using rule 91 (expresion_1 -> MAY exp .)


state 203

    (92) expresion_1 -> MAY_EQ exp .

    RPAREN          reduce using rule 92 (expresion_1 -> MAY_EQ exp .)
    COL             reduce using rule 92 (expresion_1 -> MAY_EQ exp .)


state 204

    (94) expresion_1 -> EQ_EQ exp .

    RPAREN          reduce using rule 94 (expresion_1 -> EQ_EQ exp .)
    COL             reduce using rule 94 (expresion_1 -> EQ_EQ exp .)


state 205

    (93) expresion_1 -> DIF exp .

    RPAREN          reduce using rule 93 (expresion_1 -> DIF exp .)
    COL             reduce using rule 93 (expresion_1 -> DIF exp .)


state 206

    (79) while -> RES_WHILE LPAREN expresion RPAREN COL . bloque
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    E_END           reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 222
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 207

    (78) asignarray1 -> cons COMMA . asignarray1
    (77) asignarray1 -> . cons
    (78) asignarray1 -> . cons COMMA asignarray1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 178
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105
    asignarray1                    shift and go to state 223

state 208

    (76) asignarray -> LBRACKET asignarray1 RBRACKET .

    RES_READ        reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_PRINT       reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    ID              reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_DEF         reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_IF          reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_SWITCH      reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_WHILE       reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_FOR         reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_START       reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_FUNC        reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    $end            reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_END         reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    E_END           reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_ELSE        reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)
    RES_CASE        reduce using rule 76 (asignarray -> LBRACKET asignarray1 RBRACKET .)


state 209

    (73) asignlist -> LCURLY asignlist1 RCURLY .

    RES_READ        reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_PRINT       reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    ID              reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_DEF         reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_IF          reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_SWITCH      reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_WHILE       reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_FOR         reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_START       reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_FUNC        reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    $end            reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_END         reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    E_END           reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_ELSE        reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)
    RES_CASE        reduce using rule 73 (asignlist -> LCURLY asignlist1 RCURLY .)


state 210

    (75) asignlist1 -> cons COMMA . asignlist1
    (74) asignlist1 -> . cons
    (75) asignlist1 -> . cons COMMA asignlist1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    asignlist1                     shift and go to state 224
    cons                           shift and go to state 181
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105

state 211

    (86) switch2 -> RES_CASE expresion COL . bloque switch2
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    RES_CASE        reduce using rule 126 (empty -> .)
    E_END           reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 225
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 212

    (39) cons_loop_1 -> COMMA cons_loop .

    RCURLY          reduce using rule 39 (cons_loop_1 -> COMMA cons_loop .)


state 213

    (124) conslist1 -> cons .
    (125) conslist1 -> cons . COMMA conslist1

    RCURLY          reduce using rule 124 (conslist1 -> cons .)
    COMMA           shift and go to state 226


state 214

    (123) conslist -> ID EQUALS LCURLY conslist1 . RCURLY

    RCURLY          shift and go to state 227


state 215

    (122) consarray -> ID LBRACKET CTE_INT RBRACKET . EQUALS cons

    EQUALS          shift and go to state 228


state 216

    (41) array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .

    RES_INT         reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_FLOAT       reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_DOUBLE      reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_BOOLEAN     reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_STRING      reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_LIST        reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RES_ARRAY       reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    ID              reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)
    RPAREN          reduce using rule 41 (array -> RES_ARRAY dato ID LBRACKET CTE_INT RBRACKET array1 .)


state 217

    (42) array1 -> COL . LBRACKET array2 RBRACKET

    LBRACKET        shift and go to state 229


state 218

    (43) array1 -> empty .

    RES_INT         reduce using rule 43 (array1 -> empty .)
    RES_FLOAT       reduce using rule 43 (array1 -> empty .)
    RES_DOUBLE      reduce using rule 43 (array1 -> empty .)
    RES_BOOLEAN     reduce using rule 43 (array1 -> empty .)
    RES_STRING      reduce using rule 43 (array1 -> empty .)
    RES_LIST        reduce using rule 43 (array1 -> empty .)
    RES_ARRAY       reduce using rule 43 (array1 -> empty .)
    ID              reduce using rule 43 (array1 -> empty .)
    RPAREN          reduce using rule 43 (array1 -> empty .)


state 219

    (81) forexp -> ID EQUALS cons COL . expresion COL ID EQUALS expresion
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 230
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 220

    (80) for -> RES_FOR LPAREN forexp RPAREN COL bloque .

    E_END           reduce using rule 80 (for -> RES_FOR LPAREN forexp RPAREN COL bloque .)


state 221

    (82) if -> RES_IF LPAREN expresion RPAREN COL bloque . ifelse
    (83) ifelse -> . RES_ELSE COL bloque
    (84) ifelse -> . empty
    (126) empty -> .

    RES_ELSE        shift and go to state 231
    E_END           reduce using rule 126 (empty -> .)

    ifelse                         shift and go to state 232
    empty                          shift and go to state 233

state 222

    (79) while -> RES_WHILE LPAREN expresion RPAREN COL bloque .

    E_END           reduce using rule 79 (while -> RES_WHILE LPAREN expresion RPAREN COL bloque .)


state 223

    (78) asignarray1 -> cons COMMA asignarray1 .

    RBRACKET        reduce using rule 78 (asignarray1 -> cons COMMA asignarray1 .)


state 224

    (75) asignlist1 -> cons COMMA asignlist1 .

    RCURLY          reduce using rule 75 (asignlist1 -> cons COMMA asignlist1 .)


state 225

    (86) switch2 -> RES_CASE expresion COL bloque . switch2
    (86) switch2 -> . RES_CASE expresion COL bloque switch2
    (87) switch2 -> . empty
    (126) empty -> .

    RES_CASE        shift and go to state 142
    E_END           reduce using rule 126 (empty -> .)

    switch2                        shift and go to state 234
    empty                          shift and go to state 143

state 226

    (125) conslist1 -> cons COMMA . conslist1
    (124) conslist1 -> . cons
    (125) conslist1 -> . cons COMMA conslist1
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 213
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105
    conslist1                      shift and go to state 235

state 227

    (123) conslist -> ID EQUALS LCURLY conslist1 RCURLY .

    COMMA           reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RBRACKET        reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    TIMES           reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    DIVIDE          reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    PLUS            reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MINUS           reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MIN             reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MIN_EQ          reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MAY             reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    MAY_EQ          reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    DIF             reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    EQ_EQ           reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RPAREN          reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_READ        reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_PRINT       reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    ID              reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_DEF         reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_IF          reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_SWITCH      reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_WHILE       reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_FOR         reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_START       reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_FUNC        reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    $end            reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_END         reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    E_END           reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_ELSE        reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_CASE        reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    COL             reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RCURLY          reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_INT         reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_FLOAT       reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_DOUBLE      reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_BOOLEAN     reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_STRING      reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_LIST        reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)
    RES_ARRAY       reduce using rule 123 (conslist -> ID EQUALS LCURLY conslist1 RCURLY .)


state 228

    (122) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS . cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    conslist                       shift and go to state 105
    consarray                      shift and go to state 102
    cons                           shift and go to state 236

state 229

    (42) array1 -> COL LBRACKET . array2 RBRACKET
    (44) array2 -> . cons
    (45) array2 -> . cons COMMA array2
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 237
    array2                         shift and go to state 238
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105

state 230

    (81) forexp -> ID EQUALS cons COL expresion . COL ID EQUALS expresion

    COL             shift and go to state 239


state 231

    (83) ifelse -> RES_ELSE . COL bloque

    COL             shift and go to state 240


state 232

    (82) if -> RES_IF LPAREN expresion RPAREN COL bloque ifelse .

    E_END           reduce using rule 82 (if -> RES_IF LPAREN expresion RPAREN COL bloque ifelse .)


state 233

    (84) ifelse -> empty .

    E_END           reduce using rule 84 (ifelse -> empty .)


state 234

    (86) switch2 -> RES_CASE expresion COL bloque switch2 .

    E_END           reduce using rule 86 (switch2 -> RES_CASE expresion COL bloque switch2 .)


state 235

    (125) conslist1 -> cons COMMA conslist1 .

    RCURLY          reduce using rule 125 (conslist1 -> cons COMMA conslist1 .)


state 236

    (122) consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .

    TIMES           reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    DIVIDE          reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    PLUS            reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MINUS           reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MIN             reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MIN_EQ          reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MAY             reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    MAY_EQ          reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    DIF             reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    EQ_EQ           reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    COL             reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RPAREN          reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    COMMA           reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RCURLY          reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RBRACKET        reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_READ        reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_PRINT       reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    ID              reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_DEF         reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_IF          reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_SWITCH      reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_WHILE       reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_FOR         reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_START       reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_FUNC        reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    $end            reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_END         reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    E_END           reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_ELSE        reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_CASE        reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_INT         reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_FLOAT       reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_DOUBLE      reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_BOOLEAN     reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_STRING      reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_LIST        reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)
    RES_ARRAY       reduce using rule 122 (consarray -> ID LBRACKET CTE_INT RBRACKET EQUALS cons .)


state 237

    (44) array2 -> cons .
    (45) array2 -> cons . COMMA array2

    RBRACKET        reduce using rule 44 (array2 -> cons .)
    COMMA           shift and go to state 241


state 238

    (42) array1 -> COL LBRACKET array2 . RBRACKET

    RBRACKET        shift and go to state 242


state 239

    (81) forexp -> ID EQUALS cons COL expresion COL . ID EQUALS expresion

    ID              shift and go to state 243


state 240

    (83) ifelse -> RES_ELSE COL . bloque
    (48) bloque -> . estatutos bloque
    (49) bloque -> . empty
    (50) estatutos -> . condicion E_END
    (51) estatutos -> . ciclo E_END
    (52) estatutos -> . lectura
    (53) estatutos -> . escritura
    (54) estatutos -> . asignacion
    (55) estatutos -> . llamada
    (56) estatutos -> . vars
    (126) empty -> .
    (59) condicion -> . if
    (60) condicion -> . switch
    (57) ciclo -> . while
    (58) ciclo -> . for
    (64) lectura -> . RES_READ LPAREN tipo RPAREN
    (65) escritura -> . RES_PRINT LPAREN escritura1 RPAREN
    (68) asignacion -> . ID seen_id_asignacion
    (61) llamada -> . ID LPAREN llamada1 RPAREN
    (26) vars -> . RES_DEF COL vars1
    (82) if -> . RES_IF LPAREN expresion RPAREN COL bloque ifelse
    (85) switch -> . RES_SWITCH COL switch2
    (79) while -> . RES_WHILE LPAREN expresion RPAREN COL bloque
    (80) for -> . RES_FOR LPAREN forexp RPAREN COL bloque

    E_END           reduce using rule 126 (empty -> .)
    RES_READ        shift and go to state 68
    RES_PRINT       shift and go to state 62
    ID              shift and go to state 67
    RES_DEF         shift and go to state 19
    RES_IF          shift and go to state 55
    RES_SWITCH      shift and go to state 70
    RES_WHILE       shift and go to state 66
    RES_FOR         shift and go to state 53

    vars                           shift and go to state 52
    bloque                         shift and go to state 244
    if                             shift and go to state 56
    ciclo                          shift and go to state 57
    switch                         shift and go to state 58
    llamada                        shift and go to state 60
    condicion                      shift and go to state 61
    lectura                        shift and go to state 63
    empty                          shift and go to state 64
    estatutos                      shift and go to state 65
    for                            shift and go to state 59
    asignacion                     shift and go to state 69
    while                          shift and go to state 71
    escritura                      shift and go to state 72

state 241

    (45) array2 -> cons COMMA . array2
    (44) array2 -> . cons
    (45) array2 -> . cons COMMA array2
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    cons                           shift and go to state 237
    array2                         shift and go to state 245
    consarray                      shift and go to state 102
    conslist                       shift and go to state 105

state 242

    (42) array1 -> COL LBRACKET array2 RBRACKET .

    RES_INT         reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_FLOAT       reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_DOUBLE      reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_BOOLEAN     reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_STRING      reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_LIST        reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RES_ARRAY       reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    ID              reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)
    RPAREN          reduce using rule 42 (array1 -> COL LBRACKET array2 RBRACKET .)


state 243

    (81) forexp -> ID EQUALS cons COL expresion COL ID . EQUALS expresion

    EQUALS          shift and go to state 246


state 244

    (83) ifelse -> RES_ELSE COL bloque .

    E_END           reduce using rule 83 (ifelse -> RES_ELSE COL bloque .)


state 245

    (45) array2 -> cons COMMA array2 .

    RBRACKET        reduce using rule 45 (array2 -> cons COMMA array2 .)


state 246

    (81) forexp -> ID EQUALS cons COL expresion COL ID EQUALS . expresion
    (88) expresion -> . exp expresion_1
    (96) exp -> . termino exp1
    (100) termino -> . factor termino1
    (104) factor -> . LPAREN expresion RPAREN
    (105) factor -> . cons
    (106) factor -> . PLUS cons
    (107) factor -> . MINUS cons
    (108) cons -> . ID exp_1
    (109) cons -> . CTE_INT exp_2
    (110) cons -> . CTE_FLOAT exp_3
    (111) cons -> . CTE_DOUBLE
    (112) cons -> . CTE_STRING
    (113) cons -> . RES_TRUE
    (114) cons -> . RES_FALSE
    (115) cons -> . consarray
    (116) cons -> . conslist
    (122) consarray -> . ID LBRACKET CTE_INT RBRACKET EQUALS cons
    (123) conslist -> . ID EQUALS LCURLY conslist1 RCURLY

    LPAREN          shift and go to state 120
    PLUS            shift and go to state 124
    MINUS           shift and go to state 122
    ID              shift and go to state 107
    CTE_INT         shift and go to state 106
    CTE_FLOAT       shift and go to state 103
    CTE_DOUBLE      shift and go to state 101
    CTE_STRING      shift and go to state 99
    RES_TRUE        shift and go to state 104
    RES_FALSE       shift and go to state 108

    expresion                      shift and go to state 247
    cons                           shift and go to state 119
    exp                            shift and go to state 126
    conslist                       shift and go to state 105
    termino                        shift and go to state 121
    factor                         shift and go to state 123
    consarray                      shift and go to state 102

state 247

    (81) forexp -> ID EQUALS cons COL expresion COL ID EQUALS expresion .

    RPAREN          reduce using rule 81 (forexp -> ID EQUALS cons COL expresion COL ID EQUALS expresion .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 127 resolved using rule (escritura1 -> CTE_STRING)
WARNING: rejected rule (cons -> CTE_STRING) in state 127
